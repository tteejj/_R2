####\components\advanced-data-components.psm1
# Advanced Data Components Module
# Enhanced data display components with sorting, filtering, and pagination

#region Advanced Table Component

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "DataTable"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 80 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Title = $Props.Title
        ShowBorder = if ($null -ne $Props.ShowBorder) { $Props.ShowBorder } else { $true }  # <-- NEW: Controls whether component draws its own border
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortDirection = "Ascending"
        FilterText = ""
        FilterColumn = $null
        PageSize = 0  # 0 = auto-calculate
        CurrentPage = 0
        ShowHeader = if ($null -ne $Props.ShowHeader) { $Props.ShowHeader } else { $true }
        ShowFooter = if ($null -ne $Props.ShowFooter) { $Props.ShowFooter } else { $true }
        ShowRowNumbers = if ($null -ne $Props.ShowRowNumbers) { $Props.ShowRowNumbers } else { $false }
        AllowSort = if ($null -ne $Props.AllowSort) { $Props.AllowSort } else { $true }
        AllowFilter = if ($null -ne $Props.AllowFilter) { $Props.AllowFilter } else { $true }
        AllowSelection = if ($null -ne $Props.AllowSelection) { $Props.AllowSelection } else { $true }
        MultiSelect = if ($null -ne $Props.MultiSelect) { $Props.MultiSelect } else { $false }
        SelectedRows = @()
        IsFocusable = if ($null -ne $Props.IsFocusable) { $Props.IsFocusable } else { $true }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        Name = $Props.Name
        FilteredData = @()
        ProcessedData = @()
        _lastRenderedWidth = 0
        _lastRenderedHeight = 0
        
        # Event handlers from Props
        OnRowSelect = $Props.OnRowSelect
        OnSelectionChange = $Props.OnSelectionChange
        
        # Column configuration example:
        # @{
        #     Name = "PropertyName"
        #     Header = "Display Header"
        #     Width = 20
        #     Align = "Left"  # Left, Right, Center
        #     Format = { param($value) $value.ToString("N2") }
        #     Sortable = $true
        #     Filterable = $true
        #     Color = { param($value, $row) if ($value -lt 0) { "Red" } else { "Green" } }
        # }
        
        ProcessData = {
            param($self)
            try {
                # Filter data
                if ([string]::IsNullOrWhiteSpace($self.FilterText)) {
                    $self.FilteredData = $self.Data
                } else {
                    if ($self.FilterColumn) {
                        # Filter specific column
                        $self.FilteredData = @($self.Data | Where-Object {
                            $value = $_."$($self.FilterColumn)"
                            $value -and $value.ToString() -like "*$($self.FilterText)*"
                        })
                    } else {
                        # Filter all columns
                        $self.FilteredData = @($self.Data | Where-Object {
                            $row = $_
                            $matched = $false
                            foreach ($col in $self.Columns) {
                                if ($col.Filterable -ne $false) {
                                    $value = $row."$($col.Name)"
                                    if ($value -and $value.ToString() -like "*$($self.FilterText)*") {
                                        $matched = $true
                                        break
                                    }
                                }
                            }
                            $matched
                        })
                    }
                }
                
                # Sort data
                if ($self.SortColumn -and $self.AllowSort) {
                    $self.ProcessedData = $self.FilteredData | Sort-Object -Property $self.SortColumn -Descending:($self.SortDirection -eq "Descending")
                } else {
                    $self.ProcessedData = $self.FilteredData
                }
                
                # Reset selection if needed
                if ($self.SelectedRow -ge $self.ProcessedData.Count) {
                    $self.SelectedRow = [Math]::Max(0, $self.ProcessedData.Count - 1)
                }
                
                # Calculate page size if auto
                if ($self.PageSize -eq 0) {
                    $headerLines = if ($self.ShowHeader) { 3 } else { 0 }
                    $footerLines = if ($self.ShowFooter) { 2 } else { 0 }
                    $filterLines = if ($self.AllowFilter) { 2 } else { 0 }
                    $borderAdjust = if ($self.ShowBorder) { 2 } else { 0 }
                    $self.PageSize = $self.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                }
                
                # Adjust current page
                $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                if ($self.CurrentPage -ge $totalPages) {
                    $self.CurrentPage = [Math]::Max(0, $totalPages - 1)
                }
            } catch {
                Write-Log -Level Error -Message "DataTable ProcessData error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        Render = {
            param($self)
            try {
                # CRITICAL: Check if component is visible
                if ($self.Visible -eq $false) { return }
                
                # Force ProcessData if dimensions changed
                if ($self._lastRenderedWidth -ne $self.Width -or $self._lastRenderedHeight -ne $self.Height) {
                    & $self.ProcessData -self $self
                    $self._lastRenderedWidth = $self.Width
                    $self._lastRenderedHeight = $self.Height
                }
                
                # NOTE: ProcessData is now called by external code when data changes
                # This prevents unnecessary recalculation on every render frame
                
                # Calculate content area based on border settings
                if ($self.ShowBorder) {
                    $borderColor = if ($self.IsFocusable -and $self.IsFocused) { 
                        Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                    } else { 
                        Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                    }
                    
                    $titleText = if ($null -ne $self.Title) { $self.Title } else { 'Data Table' }
                    Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                        -BorderColor $borderColor -Title " $titleText "
                    
                    # Adjust content area for border
                    $contentX = $self.X + 1
                    $contentY = $self.Y + 1
                    $contentWidth = $self.Width - 2
                    $contentHeight = $self.Height - 2
                } else {
                    # No border, use full dimensions
                    $contentX = $self.X
                    $contentY = $self.Y
                    $contentWidth = $self.Width
                    $contentHeight = $self.Height
                }
                
                $currentY = $contentY
                $innerWidth = $contentWidth
                
                # Filter bar
                if ($self.AllowFilter) {
                    $filterBg = if ($self.FilterText) { Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    $filterFg = if ($self.FilterText) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                    
                    Write-BufferString -X ($contentX + 1) -Y $currentY -Text "Filter: " -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
                    
                    $filterDisplayText = if ($self.FilterText) { $self.FilterText } else { "Type to filter..." }
                    Write-BufferString -X ($contentX + 9) -Y $currentY -Text $filterDisplayText `
                        -ForegroundColor $filterFg -BackgroundColor $filterBg
                    
                    if ($self.FilterColumn) {
                        $filterCol = $self.Columns | Where-Object { $_.Name -eq $self.FilterColumn }
                        $colName = if ($filterCol -and $filterCol.Header) { $filterCol.Header } else { $self.FilterColumn }
                        Write-BufferString -X ($contentX + $contentWidth - 19) -Y $currentY `
                            -Text "Column: $colName" -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                    }
                    
                    $currentY += 2
                }
                
                # Calculate column widths - FIXED VERSION
                $totalDefinedWidth = ($self.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum
                if ($null -eq $totalDefinedWidth) { $totalDefinedWidth = 0 }
                $flexColumns = @($self.Columns | Where-Object { -not $_.Width })
                $columnSeparators = if ($self.Columns.Count -gt 1) { $self.Columns.Count - 1 } else { 0 }  # Only add separators if multiple columns
                $rowNumberWidth = if ($self.ShowRowNumbers) { 5 } else { 0 }
                $remainingWidth = $innerWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
                
                # CRITICAL FIX: Ensure flex columns get adequate width, especially for single-column tables
                $flexWidth = 0
                if ($flexColumns.Count -gt 0) {
                    $flexWidth = [Math]::Floor($remainingWidth / $flexColumns.Count)
                }
                
                # Assign calculated widths
                foreach ($col in $self.Columns) {
                    if ($col.Width) {
                        $col.CalculatedWidth = $col.Width
                    } else {
                        # For flex columns, use the calculated flex width
                        $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
                    }
                }
                
                # Header
                if ($self.ShowHeader) {
                    $headerX = $contentX
                    
                    # Row number header
                    if ($self.ShowRowNumbers) {
                        Write-BufferString -X $headerX -Y $currentY -Text "#".PadRight(4) `
                            -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                        $headerX += 5
                    }
                    
                    # Column headers
                    foreach ($col in $self.Columns) {
                        $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                        $width = $col.CalculatedWidth
                        
                        # Add sort indicator
                        if ($self.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $self.SortColumn) {
                            $sortIndicator = if ($self.SortDirection -eq "Ascending") { "▲" } else { "▼" }
                            $headerText = "$headerText $sortIndicator"
                        }
                        
                        # Truncate if needed
                        if ($headerText.Length -gt $width) {
                            # FIX: Robust substring
                            $maxLength = [Math]::Max(0, $width - 3)
                            $headerText = $headerText.Substring(0, $maxLength) + "..."
                        }
                        
                        # Align header
                        if ($col.Align -eq "Right") {
                            $alignedText = $headerText.PadLeft($width)
                        } elseif ($col.Align -eq "Center") {
                            $padding = $width - $headerText.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            $alignedText = " " * $leftPad + $headerText + " " * $rightPad
                        } else {
                            $alignedText = $headerText.PadRight($width)
                        }
                        
                        Write-BufferString -X $headerX -Y $currentY -Text $alignedText `
                            -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                        
                        $headerX += $width + 1
                    }
                    
                    $currentY++
                    
                    # Header separator
                    $separatorColor = Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                    Write-BufferString -X $contentX -Y $currentY `
                        -Text ("─" * $contentWidth) -ForegroundColor $separatorColor
                    $currentY++
                }
                
                # Data rows
                $startIdx = $self.CurrentPage * $self.PageSize
                $endIdx = [Math]::Min($startIdx + $self.PageSize - 1, $self.ProcessedData.Count - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.ProcessedData[$i]
                    $rowX = $contentX
                    
                    # Selection highlighting
                    $isSelected = if ($self.MultiSelect) {
                        $self.SelectedRows -contains $i
                    } else {
                        $i -eq $self.SelectedRow
                    }
                    
                    $rowBg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    $rowFg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                    
                    # Clear row background if selected - FIXED to respect actual component width
                    if ($isSelected) {
                        # Calculate actual row width based on column widths and separators
                        $actualRowWidth = 0
                        if ($self.ShowRowNumbers) { $actualRowWidth += 5 }
                        foreach ($col in $self.Columns) {
                            $actualRowWidth += $col.CalculatedWidth
                        }
                        # Add column separators
                        if ($self.Columns.Count -gt 1) {
                            $actualRowWidth += ($self.Columns.Count - 1)
                        }
                        # Ensure we don't exceed content width
                        $actualRowWidth = [Math]::Min($actualRowWidth, $contentWidth)
                        
                        Write-BufferString -X $rowX -Y $currentY -Text (" " * $actualRowWidth) `
                            -BackgroundColor $rowBg
                    }
                    
                    # Row number
                    if ($self.ShowRowNumbers) {
                        Write-BufferString -X $rowX -Y $currentY -Text ($i + 1).ToString().PadRight(4) `
                            -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)) -BackgroundColor $rowBg
                        $rowX += 5
                    }
                    
                    # Cell data
                    foreach ($col in $self.Columns) {
                        $value = $row."$($col.Name)"
                        $width = $col.CalculatedWidth
                        
                        # Format value
                        $displayValue = if ($col.Format -and $value -ne $null) {
                            & $col.Format $value
                        } elseif ($value -ne $null) {
                            $value.ToString()
                        } else {
                            ""
                        }
                        
                        # Truncate if needed
                        if ($displayValue.Length -gt $width) {
                            # FIX: Robust substring
                            $maxLength = [Math]::Max(0, $width - 3)
                            if ($maxLength -le 0) {
                                Write-Log -Level Warning -Message "DataTable '$($self.Title)' column '$($col.Name)' width too small: $width (max length: $maxLength)"
                                $displayValue = "..."
                            } else {
                                $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                            }
                        }
                        
                        
                        # Align value
                        if ($col.Align -eq "Right") {
                            $alignedValue = $displayValue.PadLeft($width)
                        } elseif ($col.Align -eq "Center") {
                            $padding = $width - $displayValue.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            $alignedValue = " " * $leftPad + $displayValue + " " * $rightPad
                        } else {
                            $alignedValue = $displayValue.PadRight($width)
                        }
                        
                        # Determine color
                        $cellFg = if ($col.Color -and -not $isSelected) {
                            $colorName = & $col.Color $value $row
                            Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                        } else {
                            $rowFg
                        }
                        
                        # Ensure we don't write beyond component boundaries
                        if ($rowX + $alignedValue.Length -le $contentX + $contentWidth) {
                            Write-BufferString -X $rowX -Y $currentY -Text $alignedValue `
                                -ForegroundColor $cellFg -BackgroundColor $rowBg
                        } else {
                            # Clip the text to fit within boundaries
                            $availableWidth = ($contentX + $contentWidth) - $rowX
                            if ($availableWidth -gt 0) {
                                $clippedText = $alignedValue.Substring(0, [Math]::Min($alignedValue.Length, $availableWidth))
                                Write-BufferString -X $rowX -Y $currentY -Text $clippedText `
                                    -ForegroundColor $cellFg -BackgroundColor $rowBg
                            }
                        }
                        
                        $rowX += $width + 1
                    }
                    
                    $currentY++
                }
                
                # Empty state
                if ($self.ProcessedData.Count -eq 0) {
                    $emptyMessage = if ($self.FilterText) {
                        "No results match the filter"
                    } else {
                        "No data to display"
                    }
                    $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
                    $msgY = $contentY + [Math]::Floor($contentHeight / 2)
                    Write-BufferString -X $msgX -Y $msgY -Text $emptyMessage `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                }
                
                # Footer
                if ($self.ShowFooter) {
                    $footerY = $contentY + $contentHeight - 1
                    
                    # Status
                    $statusText = "$($self.ProcessedData.Count) rows"
                    if ($self.FilterText) {
                        $statusText += " (filtered from $($self.Data.Count))"
                    }
                    if ($self.MultiSelect) {
                        $statusText += " | $($self.SelectedRows.Count) selected"
                    }
                    Write-BufferString -X ($contentX + 1) -Y $footerY -Text $statusText `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                    
                    # Pagination
                    if ($self.ProcessedData.Count -gt $self.PageSize) {
                        $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                        $pageText = "Page $($self.CurrentPage + 1)/$totalPages"
                        Write-BufferString -X ($contentX + $contentWidth - $pageText.Length - 1) -Y $footerY `
                            -Text $pageText -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                    }
                    
                    # Scrollbar
                    if ($self.ProcessedData.Count -gt $self.PageSize) {
                        $scrollHeight = $contentHeight - 4 - (if ($self.ShowHeader) { 2 } else { 0 }) - (if ($self.AllowFilter) { 2 } else { 0 })
                        $scrollPos = [Math]::Floor(($self.SelectedRow / ($self.ProcessedData.Count - 1)) * ($scrollHeight - 1))
                        $scrollX = $contentX + $contentWidth - 1
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $scrollY = $currentY - $scrollHeight + $i
                            $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                            Write-BufferString -X $scrollX -Y $scrollY -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "DataTable Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                # Filter mode
                if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                    switch ($Key.Key) {
                        ([ConsoleKey]::F) {
                            # Toggle filter focus
                            $self.FilterMode = -not $self.FilterMode
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::S) {
                            # Cycle sort column
                            if ($self.AllowSort) {
                                $sortableCols = @($self.Columns | Where-Object { $_.Sortable -ne $false })
                                if ($sortableCols.Count -gt 0) {
                                    $currentIdx = [array]::IndexOf($sortableCols.Name, $self.SortColumn)
                                    $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                                    $self.SortColumn = $sortableCols[$nextIdx].Name
                                    & $self.ProcessData -self $self
                                    Request-TuiRefresh
                                }
                            }
                            return $true
                        }
                        ([ConsoleKey]::A) {
                            # Select all (if multi-select)
                            if ($self.MultiSelect) {
                                if ($self.SelectedRows.Count -eq $self.ProcessedData.Count) {
                                    $self.SelectedRows = @()
                                } else {
                                    $self.SelectedRows = @(0..($self.ProcessedData.Count - 1))
                                }
                                if ($self.OnSelectionChange) {
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnSelectionChange" -ScriptBlock {
                                        & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                                    } -Context @{ Component = $self.Name; SelectedRows = $self.SelectedRows } -ErrorHandler {
                                        param($Exception)
                                        Write-Log -Level Error -Message "DataTable OnSelectionChange error: $($Exception.Message)" -Data $Exception.Context
                                    }
                                }
                                Request-TuiRefresh
                            }
                            return $true
                        }
                    }
                }
                
                # Filter text input
                if ($self.FilterMode) {
                    switch ($Key.Key) {
                        ([ConsoleKey]::Escape) {
                            $self.FilterMode = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Enter) {
                            $self.FilterMode = $false
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Backspace) {
                            if ($self.FilterText.Length -gt 0) {
                                $self.FilterText = $self.FilterText.Substring(0, $self.FilterText.Length - 1)
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                            return $true
                        }
                        default {
                            if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                $self.FilterText += $Key.KeyChar
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                                return $true
                            }
                        }
                    }
                    return $false
                }
                
                # Normal navigation
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedRow -gt 0) {
                            $self.SelectedRow--
                            
                            # Adjust page if needed
                            if ($self.SelectedRow -lt ($self.CurrentPage * $self.PageSize)) {
                                $self.CurrentPage--
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedRow -lt ($self.ProcessedData.Count - 1)) {
                            $self.SelectedRow++
                            
                            # Adjust page if needed
                            if ($self.SelectedRow -ge (($self.CurrentPage + 1) * $self.PageSize)) {
                                $self.CurrentPage++
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::PageUp) {
                        if ($self.CurrentPage -gt 0) {
                            $self.CurrentPage--
                            $self.SelectedRow = $self.CurrentPage * $self.PageSize
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::PageDown) {
                        $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                        if ($self.CurrentPage -lt ($totalPages - 1)) {
                            $self.CurrentPage++
                            $self.SelectedRow = $self.CurrentPage * $self.PageSize
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.SelectedRow = 0
                        $self.CurrentPage = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.SelectedRow = $self.ProcessedData.Count - 1
                        $self.CurrentPage = [Math]::Floor($self.SelectedRow / [Math]::Max(1, $self.PageSize))
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.MultiSelect) {
                            if ($self.SelectedRows -contains $self.SelectedRow) {
                                $self.SelectedRows = @($self.SelectedRows | Where-Object { $_ -ne $self.SelectedRow })
                            } else {
                                $self.SelectedRows += $self.SelectedRow
                            }
                            if ($self.OnSelectionChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnSelectionChange" -ScriptBlock {
                                    & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                                } -Context @{ Component = $self.Name; SelectedRows = $self.SelectedRows } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "DataTable OnSelectionChange error: $($Exception.Message)" -Data $Exception.Context
                                }
                            }
                            Request-TuiRefresh
                        } elseif ($self.AllowSort) {
                            # Toggle sort direction
                            if ($self.SortDirection -eq "Ascending") {
                                $self.SortDirection = "Descending"
                            } else {
                                $self.SortDirection = "Ascending"
                            }
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnRowSelect -and $self.ProcessedData.Count -gt 0) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -ScriptBlock {
                                $selectedData = if ($self.MultiSelect) {
                                    @($self.SelectedRows | ForEach-Object { $self.ProcessedData[$_] })
                                } else {
                                    $self.ProcessedData[$self.SelectedRow]
                                }
                                & $self.OnRowSelect -SelectedData $selectedData -SelectedIndex $self.SelectedRow
                            } -Context @{ Component = $self.Name; SelectedRow = $self.SelectedRow; MultiSelect = $self.MultiSelect } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "DataTable OnRowSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::F) {
                        if ($self.AllowFilter) {
                            $self.FilterMode = $true
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        # Number keys for column sorting
                        if ($Key.KeyChar -match '\d' -and $self.AllowSort) {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $col = $self.Columns[$colIndex]
                                if ($col.Sortable -ne $false) {
                                    if ($self.SortColumn -eq $col.Name) {
                                        # Toggle direction
                                        $self.SortDirection = if ($self.SortDirection -eq "Ascending") { "Descending" } else { "Ascending" }
                                    } else {
                                        $self.SortColumn = $col.Name
                                        $self.SortDirection = "Ascending"
                                    }
                                    & $self.ProcessData -self $self
                                    Request-TuiRefresh
                                }
                            }
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "DataTable HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
        
        # Public methods
        RefreshData = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).RefreshData" -ScriptBlock {
                & $self.ProcessData -self $self
                Request-TuiRefresh
            } -Context @{ Component = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "DataTable RefreshData error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        SetFilter = {
            param($self, $FilterText, $FilterColumn)
            Invoke-WithErrorHandling -Component "$($self.Name).SetFilter" -ScriptBlock {
                $self.FilterText = $FilterText
                $self.FilterColumn = $FilterColumn
                & $self.ProcessData -self $self
                Request-TuiRefresh
            } -Context @{ Component = $self.Name; FilterText = $FilterText; FilterColumn = $FilterColumn } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "DataTable SetFilter error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        ExportData = {
            param($self, $Format = "CSV", $FilePath)
            Invoke-WithErrorHandling -Component "$($self.Name).ExportData" -ScriptBlock {
                $exportData = if ($self.FilterText) { $self.ProcessedData } else { $self.Data }
                
                switch ($Format.ToUpper()) {
                    "CSV" {
                        $exportData | Export-Csv -Path $FilePath -NoTypeInformation
                    }
                    "JSON" {
                        $exportData | ConvertTo-Json -Depth 10 | Set-Content -Path $FilePath
                    }
                    "HTML" {
                        # Simple HTML table export
                        $html = "<table border='1'><tr>"
                        foreach ($col in $self.Columns) {
                            $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                            $html += "<th>$headerText</th>"
                        }
                        $html += "</tr>"
                        
                        foreach ($row in $exportData) {
                            $html += "<tr>"
                            foreach ($col in $self.Columns) {
                                $value = $row."$($col.Name)"
                                $html += "<td>$value</td>"
                            }
                            $html += "</tr>"
                        }
                        $html += "</table>"
                        
                        $html | Set-Content -Path $FilePath
                    }
                }
            } -Context @{ Component = $self.Name; Format = $Format; FilePath = $FilePath } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "DataTable ExportData error: $($Exception.Message)" -Data $Exception.Context
            }
        }
    }
    
    # Initialize data processing after component is created
    & $component.ProcessData -self $component
    
    return $component
}

#endregion

#region Tree View Component

function global:New-TuiTreeView {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TreeView"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        RootNode = if ($null -ne $Props.RootNode) { $Props.RootNode } else { @{ Name = "Root"; Children = @(); Expanded = $true } }
        SelectedNode = $null
        SelectedPath = @()
        FlattenedNodes = @()
        ScrollOffset = 0
        ShowRoot = if ($null -ne $Props.ShowRoot) { $Props.ShowRoot } else { $true }
        IsFocusable = $true
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        Name = $Props.Name
        OnNodeSelect = $Props.OnNodeSelect
        
        # Node structure:
        # @{
        #     Name = "Node Name"
        #     Data = @{}  # Custom data
        #     Children = @()
        #     Expanded = $false
        #     Icon = "📁"  # Optional
        #     Parent = $null  # Set automatically
        # }
        
        FlattenTree = {
            param($self)
            try {
                $flattened = @()
                
                $processNode = {
                    param($Node, $Level, $Parent)
                    
                    $node.Parent = $Parent
                    $node.Level = $Level
                    
                    if ($self.ShowRoot -or $Level -gt 0) {
                        $flattened += $Node
                    }
                    
                    if ($Node.Expanded -and $Node.Children) {
                        foreach ($child in $Node.Children) {
                            & $processNode $child ($Level + 1) $Node
                        }
                    }
                }
                
                & $processNode $self.RootNode 0 $null
                $self.FlattenedNodes = $flattened
            } catch {
                Write-Log -Level Error -Message "TreeView FlattenTree error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        Render = {
            param($self)
            try {
                # Check if component is visible
                if ($self.Visible -eq $false) { return }
                
                # Flatten tree first
                & $self.FlattenTree -self $self
                
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Tree View "
                
                $visibleHeight = $self.Height - 2
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.FlattenedNodes.Count - 1, $startIdx + $visibleHeight - 1)
                
                $currentY = $self.Y + 1
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $node = $self.FlattenedNodes[$i]
                    $isSelected = ($node -eq $self.SelectedNode)
                    
                    # Indentation
                    $indent = "  " * $node.Level
                    
                    # Expand/collapse indicator
                    $expandIcon = if ($node.Children -and $node.Children.Count -gt 0) {
                        if ($node.Expanded) { "▼" } else { "▶" }
                    } else {
                        " "
                    }
                    
                    # Node icon
                    $nodeIcon = if ($node.Icon) { 
                        $node.Icon 
                    } elseif ($node.Children -and $node.Children.Count -gt 0) {
                        if ($node.Expanded) { "📂" } else { "📁" }
                    } else {
                        "📄"
                    }
                    
                    # Colors
                    $fg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                    $bg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    
                    # Clear line if selected
                    if ($isSelected) {
                        Write-BufferString -X ($self.X + 1) -Y $currentY -Text (" " * ($self.Width - 2)) `
                            -BackgroundColor $bg
                    }
                    
                    # Render node
                    $nodeText = "$indent$expandIcon $nodeIcon $($node.Name)"
                    if ($nodeText.Length -gt ($self.Width - 3)) {
                        $nodeText = $nodeText.Substring(0, $self.Width - 6) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 1) -Y $currentY -Text $nodeText `
                        -ForegroundColor $fg -BackgroundColor $bg
                    
                    $currentY++
                }
                
                # Scrollbar
                if ($self.FlattenedNodes.Count -gt $visibleHeight) {
                    $scrollHeight = $visibleHeight
                    $scrollPos = if ($self.FlattenedNodes.Count -gt 1) {
                        $selectedIdx = [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                        [Math]::Floor(($selectedIdx / ($self.FlattenedNodes.Count - 1)) * ($scrollHeight - 1))
                    } else { 0 }
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) `
                            -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TreeView Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.FlattenedNodes.Count -eq 0) { return $false }
                
                $currentIdx = if ($self.SelectedNode) {
                    [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                } else { 0 }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($currentIdx -gt 0) {
                            $currentIdx--
                            $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                            
                            # Adjust scroll
                            if ($currentIdx -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $currentIdx
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($currentIdx -lt ($self.FlattenedNodes.Count - 1)) {
                            $currentIdx++
                            $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                            
                            # Adjust scroll
                            $visibleHeight = $self.Height - 2
                            if ($currentIdx -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $currentIdx - $visibleHeight + 1
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.SelectedNode) {
                            if ($self.SelectedNode.Expanded -and $self.SelectedNode.Children) {
                                # Collapse
                                $self.SelectedNode.Expanded = $false
                                Request-TuiRefresh
                            } elseif ($self.SelectedNode.Parent) {
                                # Move to parent
                                $self.SelectedNode = $self.SelectedNode.Parent
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                            if (-not $self.SelectedNode.Expanded) {
                                # Expand
                                $self.SelectedNode.Expanded = $true
                                Request-TuiRefresh
                            } else {
                                # Move to first child
                                $self.SelectedNode = $self.SelectedNode.Children[0]
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                            $self.SelectedNode.Expanded = -not $self.SelectedNode.Expanded
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnNodeSelect -and $self.SelectedNode) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnNodeSelect" -ScriptBlock {
                                # Build path
                                $path = @()
                                $current = $self.SelectedNode
                                while ($current) {
                                    $path = @($current.Name) + $path
                                    $current = $current.Parent
                                }
                                
                                & $self.OnNodeSelect -Node $self.SelectedNode -Path $path
                            } -Context @{ Component = $self.Name; SelectedNode = $self.SelectedNode.Name } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "TreeView OnNodeSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        if ($self.FlattenedNodes.Count -gt 0) {
                            $self.SelectedNode = $self.FlattenedNodes[0]
                            $self.ScrollOffset = 0
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        if ($self.FlattenedNodes.Count -gt 0) {
                            $self.SelectedNode = $self.FlattenedNodes[-1]
                            $visibleHeight = $self.Height - 2
                            $self.ScrollOffset = [Math]::Max(0, $self.FlattenedNodes.Count - $visibleHeight)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    { $_ -in @([ConsoleKey]::Add, [ConsoleKey]::OemPlus) } {
                        # Expand all
                        $expandAll = {
                            param($Node)
                            $Node.Expanded = $true
                            foreach ($child in $Node.Children) {
                                & $expandAll $child
                            }
                        }
                        & $expandAll $self.RootNode
                        Request-TuiRefresh
                        return $true
                    }
                    { $_ -in @([ConsoleKey]::Subtract, [ConsoleKey]::OemMinus) } {
                        # Collapse all
                        $collapseAll = {
                            param($Node)
                            $Node.Expanded = $false
                            foreach ($child in $Node.Children) {
                                & $collapseAll $child
                            }
                        }
                        & $collapseAll $self.RootNode
                        $self.RootNode.Expanded = $true  # Keep root expanded
                        Request-TuiRefresh
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TreeView HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
        
        # Public methods
        AddNode = {
            param($self, $ParentNode, $NewNode)
            Invoke-WithErrorHandling -Component "$($self.Name).AddNode" -ScriptBlock {
                if (-not $ParentNode.Children) {
                    $ParentNode.Children = @()
                }
                $ParentNode.Children += $NewNode
                $NewNode.Parent = $ParentNode
                Request-TuiRefresh
            } -Context @{ Component = $self.Name; ParentNode = $ParentNode.Name; NewNode = $NewNode.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "TreeView AddNode error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        RemoveNode = {
            param($self, $Node)
            Invoke-WithErrorHandling -Component "$($self.Name).RemoveNode" -ScriptBlock {
                if ($Node.Parent) {
                    $Node.Parent.Children = @($Node.Parent.Children | Where-Object { $_ -ne $Node })
                    if ($self.SelectedNode -eq $Node) {
                        $self.SelectedNode = $Node.Parent
                    }
                    Request-TuiRefresh
                }
            } -Context @{ Component = $self.Name; Node = $Node.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "TreeView RemoveNode error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        FindNode = {
            param($self, $Predicate)
            Invoke-WithErrorHandling -Component "$($self.Name).FindNode" -ScriptBlock {
                $find = {
                    param($Node)
                    if (& $Predicate $Node) { return $Node }
                    foreach ($child in $Node.Children) {
                        $found = & $find $child
                        if ($found) { return $found }
                    }
                    return $null
                }
                
                return & $find $self.RootNode
            } -Context @{ Component = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "TreeView FindNode error: $($Exception.Message)" -Data $Exception.Context
                return $null
            }
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiDataTable',
    'New-TuiTreeView'
)


####\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Mode = if ($null -ne $Props.Mode) { $Props.Mode } else { "Date" } # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        ViewDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                            continue
                        }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { 
                                Get-ThemeColor "Background" 
                            } elseif ($isToday) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Primary" 
                            }
                            
                            $bg = if ($isSelected) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Background" 
                            }
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                                -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                        -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Previous month
                            $self.ViewDate = $viewDate.AddMonths(-1)
                        } else {
                            # Previous day
                            $date = $date.AddDays(-1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Next month
                            $self.ViewDate = $viewDate.AddMonths(1)
                        } else {
                            # Next day
                            $date = $date.AddDays(1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::UpArrow) {
                        $date = $date.AddDays(-7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        $date = $date.AddDays(7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) {
                        $date = Get-Date
                        $self.ViewDate = $date
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock {
                                & $self.OnSelect -Date $date
                            } -Context @{ Component = $self.Name; SelectedDate = $date } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "CalendarPicker OnSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $date
                        } -Context @{ Component = $self.Name; NewValue = $date } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "CalendarPicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Type to search..." }
        MaxDisplayItems = if ($null -ne $Props.MaxDisplayItems) { $Props.MaxDisplayItems } else { 5 }
        AllowCustomValue = if ($null -ne $Props.AllowCustomValue) { $Props.AllowCustomValue } else { $false }
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        if ($selected) {
                            $displayText = $selected.Display
                        } else {
                            $displayText = $self.Value.ToString()
                        }
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                    -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = 0
                    if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                        $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                    }
                    
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                # Draw text before match
                                if ($matchIndex -gt 0) {
                                    Write-BufferString -X ($self.X + 2) -Y $y `
                                        -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                                }
                                
                                # Draw matching text highlighted
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                    -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                    -ForegroundColor (Get-ThemeColor "Warning")
                                
                                # Draw text after match
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) {
                                    Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                        -Text $text.Substring($afterMatch) -ForegroundColor $fg
                                }
                                
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                            -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                                -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.FilteredOptions = $this.Options
                } else {
                    $this.FilteredOptions = @($this.Options | Where-Object {
                        $_.Display -like "*$($this.SearchText)*"
                    })
                    
                    # Add custom value option if allowed and no exact match
                    if ($this.AllowCustomValue) {
                        $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                        if (-not $exactMatch) {
                            $this.FilteredOptions = @(@{
                                Display = $this.SearchText
                                Value = $this.SearchText
                                IsCustom = $true
                            }) + $this.FilteredOptions
                        }
                    }
                }
                
                # Reset selection to first item
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    switch ($Key.Key) {
                        { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                            $self.IsOpen = $true
                            $self.SearchText = ""
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    return $false
                }
                
                # Handle open dropdown
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                    & $self.OnChange -NewValue $selected.Value -Option $selected
                                } -Context @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "SearchableDropdown OnChange error: $($Exception.Message)" -Data $Exception.Context
                                }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedIndex -gt 0) {
                            $self.SelectedIndex--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                            $self.SelectedIndex++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        SelectedValues = if ($null -ne $Props.SelectedValues) { $Props.SelectedValues } else { @() }
        Title = if ($null -ne $Props.Title) { $Props.Title } else { "Select items" }
        AllowSelectAll = if ($null -ne $Props.AllowSelectAll) { $Props.AllowSelectAll } else { $true }
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title) "
                
                # Select all option
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                    $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                        -ForegroundColor $fg
                    $currentY += 2
                }
                
                # Options
                $visibleHeight = $self.Height - 4
                if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                    $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                # Status line
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $maxIndex = $self.Options.Count - 1
                if ($self.AllowSelectAll) { $maxIndex++ }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                            $self.SelectedIndex = -1
                        } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $self.SelectedIndex
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4
                            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            # Toggle all
                            if ($self.SelectedValues.Count -eq $self.Options.Count) {
                                $self.SelectedValues = @()
                            } else {
                                $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                            }
                        } elseif ($self.SelectedIndex -ge 0) {
                            # Toggle individual
                            $option = $self.Options[$self.SelectedIndex]
                            if ($self.SelectedValues -contains $option.Value) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                            } else {
                                $self.SelectedValues += $option.Value
                            }
                        }
                        
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -SelectedValues $self.SelectedValues
                            } -Context @{ Component = $self.Name; SelectedValues = $self.SelectedValues } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "MultiSelect OnChange error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock {
                                & $self.OnSubmit -SelectedValues $self.SelectedValues
                            } -Context @{ Component = $self.Name; SelectedValues = $self.SelectedValues } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "MultiSelect OnSubmit error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        DecimalPlaces = if ($null -ne $Props.DecimalPlaces) { $Props.DecimalPlaces } else { 0 }
        IsFocusable = $true
        TextValue = (if ($null -ne $Props.Value) { $Props.Value } else { 0 }).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Value display
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) {
                    $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                # Cursor
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Spinner buttons
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" `
                    -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" `
                    -ForegroundColor $borderColor
                
                # Min/Max indicators
                if ($self.Value -le $self.Min) {
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
                if ($self.Value -ge $self.Max) {
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $newValue
                    } -Context @{ Component = $this.Name; NewValue = $newValue } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "NumberInput OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -Context @{ Component = $self.Name; NewValue = $self.Value } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "NumberInput OnChange error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -Context @{ Component = $self.Name; NewValue = $self.Value } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "NumberInput OnChange error: $($Exception.Message)" -Data $Exception.Context
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.CursorPosition++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.TextValue.Length
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.CursorPosition -gt 0) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        & $self.ValidateAndUpdate -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 50 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        ShowValue = if ($null -ne $Props.ShowValue) { $Props.ShowValue } else { $true }
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                }
                
                # Calculate position
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                # Draw track
                $track = "─" * $trackWidth
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
                
                # Draw filled portion
                if ($thumbPos -gt 0) {
                    $filled = "═" * $thumbPos
                    Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
                }
                
                # Draw thumb
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                
                # Draw bounds
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                # Show value
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch {
                Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    }
                    ([ConsoleKey]::Home) {
                        $self.Value = $self.Min
                    }
                    ([ConsoleKey]::End) {
                        $self.Value = $self.Max
                    }
                    ([ConsoleKey]::PageDown) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                    }
                    ([ConsoleKey]::PageUp) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $self.Value
                        } -Context @{ Component = $self.Name; NewValue = $self.Value } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Slider OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)


####\components\tui-components.psm1
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture
# LEGACY New-TuiPanel has been REMOVED.

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
                Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "Label Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Label HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Button" }
        Name = $Props.Name
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor
                    
                $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
                Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                    -ForegroundColor $fgColor -BackgroundColor $bgColor
            } catch {
                Write-Log -Level Error -Message "Button Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    if ($self.OnClick) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnClick" -ScriptBlock {
                            & $self.OnClick
                        } -Context @{ Component = $self.Name; Key = $Key } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Button OnClick error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Button HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "" }
        MaxLength = if ($null -ne $Props.MaxLength) { $Props.MaxLength } else { 100 }
        Name = $Props.Name
        
        # Internal State
        CursorPosition = if ($null -ne $Props.CursorPosition) { $Props.CursorPosition } else { 0 }
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = if ($self.Text) { $self.Text } else { "" }
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                    $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
                }
                
                $maxDisplayLength = $self.Width - 4
                if ($displayText.Length -gt $maxDisplayLength) {
                    $displayText = $displayText.Substring(0, $maxDisplayLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            } catch {
                Write-Log -Level Error -Message "TextBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $text = if ($self.Text) { $self.Text } else { "" }
                $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
                $oldText = $text
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) { 
                        if ($cursorPos -gt 0) { 
                            $text = $text.Remove($cursorPos - 1, 1)
                            $cursorPos-- 
                        }
                    }
                    ([ConsoleKey]::Delete) { 
                        if ($cursorPos -lt $text.Length) { 
                            $text = $text.Remove($cursorPos, 1) 
                        }
                    }
                    ([ConsoleKey]::LeftArrow) { 
                        if ($cursorPos -gt 0) { $cursorPos-- }
                    }
                    ([ConsoleKey]::RightArrow) { 
                        if ($cursorPos -lt $text.Length) { $cursorPos++ }
                    }
                    ([ConsoleKey]::Home) { $cursorPos = 0 }
                    ([ConsoleKey]::End) { $cursorPos = $text.Length }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Remove newlines for single-line textbox
                                    $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                    
                                    # Insert as much as will fit
                                    $remainingSpace = $self.MaxLength - $text.Length
                                    if ($remainingSpace -gt 0) {
                                        $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                            $clipboardText.Substring(0, $remainingSpace)
                                        } else {
                                            $clipboardText
                                        }
                                        
                                        $text = $text.Insert($cursorPos, $toInsert)
                                        $cursorPos += $toInsert.Length
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextBox clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                                $text = $text.Insert($cursorPos, $Key.KeyChar)
                                $cursorPos++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                    $self.Text = $text
                    $self.CursorPosition = $cursorPos
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $text
                        } -Context @{ Component = $self.Name; NewValue = $text } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "TextBox OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                return $true
            } catch {
                Write-Log -Level Error -Message "TextBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Checkbox" }
        Checked = if ($null -ne $Props.Checked) { $Props.Checked } else { $false }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
                Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "CheckBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    $self.Checked = -not $self.Checked
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $self.Checked 
                        } -Context @{ Component = $self.Name; NewValue = $self.Checked } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "CheckBox OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "CheckBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Select..." }
        Name = $Props.Name
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Placeholder
                if ($self.Value -and $self.Options) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) { $displayText = $selected.Display }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
                
                if ($self.IsOpen -and $self.Options.Count -gt 0) {
                    $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                    Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $displayCount = [Math]::Min($self.Options.Count, 6)
                    for ($i = 0; $i -lt $displayCount; $i++) {
                        $option = $self.Options[$i]
                        $y = $self.Y + 4 + $i
                        $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                        $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) { 
                            $text = $text.Substring(0, $self.Width - 7) + "..." 
                        }
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        Request-TuiRefresh
                        return $true
                    }
                } else {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { 
                            if ($self.SelectedIndex -gt 0) { 
                                $self.SelectedIndex--
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::DownArrow) { 
                            if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                                $self.SelectedIndex++
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::Enter) {
                            if ($self.Options.Count -gt 0) {
                                $selected = $self.Options[$self.SelectedIndex]
                                $self.Value = $selected.Value
                                
                                if ($self.OnChange) { 
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                        & $self.OnChange -NewValue $selected.Value 
                                    } -Context @{ Component = $self.Name; NewValue = $selected.Value } -ErrorHandler {
                                        param($Exception)
                                        Write-Log -Level Error -Message "Dropdown OnChange error: $($Exception.Message)" -Data $Exception.Context
                                    }
                                }
                            }
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Escape) { 
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        ShowPercent = if ($null -ne $Props.ShowPercent) { $Props.ShowPercent } else { $false }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
                $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
                $empty = ($self.Width - 2) - $filled
                
                $bar = "█" * $filled + "░" * $empty
                Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
                
                if ($self.ShowPercent) {
                    $percentText = "$([Math]::Round($percent))%"
                    $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "ProgressBar Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "ProgressBar HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 6 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Enter text..." }
        WrapText = if ($null -ne $Props.WrapText) { $Props.WrapText } else { $true }
        Name = $Props.Name
        
        # Internal State
        Lines = @((if ($null -ne $Props.Text) { $Props.Text } else { "" }) -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $innerWidth = $self.Width - 4
                $innerHeight = $self.Height - 2
                $displayLines = @()
                if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
                
                foreach ($line in $self.Lines) {
                    if ($self.WrapText -and $line.Length -gt $innerWidth) {
                        for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                            $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                        }
                    } else { 
                        $displayLines += $line 
                    }
                }
                
                if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                    Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                    return
                }
                
                $startLine = $self.ScrollOffset
                $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
                
                for ($i = $startLine; $i -le $endLine; $i++) {
                    $y = $self.Y + 1 + ($i - $startLine)
                    $line = $displayLines[$i]
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $line
                }
                
                if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                    $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                    $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                    Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
                
                if ($displayLines.Count -gt $innerHeight) {
                    $scrollbarHeight = $innerHeight
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TextArea Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $lines = $self.Lines
                $cursorY = $self.CursorY
                $cursorX = $self.CursorX
                $innerHeight = $self.Height - 2
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($cursorY -gt 0) {
                            $cursorY--
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $cursorY 
                            }
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($cursorY -lt $lines.Count - 1) {
                            $cursorY++
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                $self.ScrollOffset = $cursorY - $innerHeight + 1 
                            }
                        }
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($cursorX -gt 0) { 
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) { 
                            $cursorY--
                            $cursorX = $lines[$cursorY].Length 
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $cursorX++ 
                        } elseif ($cursorY -lt $lines.Count - 1) { 
                            $cursorY++
                            $cursorX = 0 
                        }
                    }
                    ([ConsoleKey]::Home) { $cursorX = 0 }
                    ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                    ([ConsoleKey]::Enter) {
                        $currentLine = $lines[$cursorY]
                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                        $afterCursor = $currentLine.Substring($cursorX)
                        $lines[$cursorY] = $beforeCursor
                        $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                        $cursorY++
                        $cursorX = 0
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($cursorX -gt 0) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) {
                            $prevLineLength = $lines[$cursorY - 1].Length
                            $lines[$cursorY - 1] += $lines[$cursorY]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                            $cursorY--
                            $cursorX = $prevLineLength
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                        } elseif ($cursorY -lt $lines.Count - 1) {
                            $lines[$cursorY] += $lines[$cursorY + 1]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                        }
                    }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Split clipboard text into lines
                                    $clipboardLines = $clipboardText -split '[\r\n]+'
                                    
                                    if ($clipboardLines.Count -eq 1) {
                                        # Single line paste - insert at cursor
                                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                        $cursorX += $clipboardLines[0].Length
                                    } else {
                                        # Multi-line paste
                                        $currentLine = $lines[$cursorY]
                                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                                        $afterCursor = $currentLine.Substring($cursorX)
                                        
                                        # First line
                                        $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                        
                                        # Insert middle lines
                                        $insertLines = @()
                                        for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                            $insertLines += $clipboardLines[$i]
                                        }
                                        
                                        # Last line
                                        $lastLine = $clipboardLines[-1] + $afterCursor
                                        $insertLines += $lastLine
                                        
                                        # Insert all new lines
                                        $newLines = @()
                                        for ($i = 0; $i -le $cursorY; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        $newLines += $insertLines
                                        for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        
                                        $lines = $newLines
                                        $cursorY += $clipboardLines.Count - 1
                                        $cursorX = $clipboardLines[-1].Length
                                    }
                                    
                                    # Adjust scroll if needed
                                    $innerHeight = $self.Height - 2
                                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextArea clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar)) {
                                $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                                $cursorX++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                $self.Lines = $lines
                $self.CursorX = $cursorX
                $self.CursorY = $cursorY
                $self.Text = $lines -join "`n"
                
                if ($self.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                        & $self.OnChange -NewValue $self.Text 
                    } -Context @{ Component = $self.Name; NewValue = $self.Text } -ErrorHandler {
                        param($Exception)
                        Write-Log -Level Error -Message "TextArea OnChange error: $($Exception.Message)" -Data $Exception.Context
                    }
                }
                Request-TuiRefresh
                return $true
            } catch {
                Write-Log -Level Error -Message "TextArea HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Format = if ($null -ne $Props.Format) { $Props.Format } else { "yyyy-MM-dd" }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                $dateStr = $self.Value.ToString($self.Format)
                
                # Truncate date string if too long
                $maxLength = $self.Width - 6
                if ($dateStr.Length -gt $maxLength) {
                    $dateStr = $dateStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "DatePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $date = $self.Value
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                    ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                    ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                    ([ConsoleKey]::Home)      { $date = Get-Date }
                    ([ConsoleKey]::T) { 
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                            $date = Get-Date 
                        } else { 
                            $handled = $false 
                        } 
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Value = $date
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $date 
                        } -Context @{ Component = $self.Name; NewValue = $date } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "DatePicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "DatePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 15 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Hour = if ($null -ne $Props.Hour) { $Props.Hour } else { 0 }
        Minute = if ($null -ne $Props.Minute) { $Props.Minute } else { 0 }
        Format24H = if ($null -ne $Props.Format24H) { $Props.Format24H } else { $true }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                if ($self.Format24H) { 
                    $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
                } else {
                    $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                    $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                    $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
                }
                
                # Truncate time string if too long
                $maxLength = $self.Width - 6
                if ($timeStr.Length -gt $maxLength) {
                    $timeStr = $timeStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "TimePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $hour = $self.Hour
                $minute = $self.Minute
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        $minute = ($minute + 15) % 60
                        if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        $minute = ($minute - 15 + 60) % 60
                        if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                    }
                    ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                    ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Hour = $hour
                    $self.Minute = $minute
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewHour $hour -NewMinute $minute 
                        } -Context @{ Component = $self.Name; NewHour = $hour; NewMinute = $minute } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "TimePicker OnChange error: $($Exception.Message)" -Data $Exception.Context
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "TimePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 60 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 15 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        Rows = if ($null -ne $Props.Rows) { $Props.Rows } else { @() }
        Name = $Props.Name
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $totalWidth = $self.Width - 4
                $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
                $headerY = $self.Y + 1
                $currentX = $self.X + 2
                
                # Draw headers
                foreach ($col in $self.Columns) {
                    $header = $col.Header
                    if ($col.Name -eq $self.SortColumn) { 
                        $arrow = if ($self.SortAscending) { "▲" } else { "▼" }
                        $header = "$header $arrow" 
                    }
                    if ($header.Length -gt $colWidth - 1) { 
                        $header = $header.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                    $currentX += $colWidth
                }
                
                # Header separator
                Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
                
                # Draw rows
                $visibleRows = $self.Height - 5
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.Rows[$i]
                    $rowY = ($headerY + 2) + ($i - $startIdx)
                    $currentX = $self.X + 2
                    $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                    $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    
                    if ($isSelected) { 
                        Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                    }
                    
                    foreach ($col in $self.Columns) {
                        $value = $row.($col.Name)
                        if ($null -eq $value) { $value = "" }
                        $text = $value.ToString()
                        if ($text.Length -gt $colWidth - 1) { 
                            $text = $text.Substring(0, $colWidth - 4) + "..." 
                        }
                        Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                        $currentX += $colWidth
                    }
                }
                
                # Scrollbar
                if ($self.Rows.Count -gt $visibleRows) {
                    $scrollbarHeight = $visibleRows
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.Rows.Count -eq 0) { return $false }
                
                $visibleRows = $self.Height - 5
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedRow -gt 0) { 
                            $self.SelectedRow--
                            if ($self.SelectedRow -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $self.SelectedRow 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                            $self.SelectedRow++
                            if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                                $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::PageUp) { 
                        $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                        $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::PageDown) { 
                        $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                        $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Home) { 
                        $self.SelectedRow = 0
                        $self.ScrollOffset = 0
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::End) { 
                        $self.SelectedRow = $self.Rows.Count - 1
                        $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Enter) { 
                        if ($self.OnRowSelect) { 
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -ScriptBlock {
                                & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                            } -Context @{ Component = $self.Name; SelectedRow = $self.SelectedRow } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "Table OnRowSelect error: $($Exception.Message)" -Data $Exception.Context
                            }
                        } 
                    }
                    default {
                        if ($Key.KeyChar -match '\d') {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $colName = $self.Columns[$colIndex].Name
                                if ($self.SortColumn -eq $colName) { 
                                    $self.SortAscending = -not $self.SortAscending 
                                } else { 
                                    $self.SortColumn = $colName
                                    $self.SortAscending = $true 
                                }
                                $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                                Request-TuiRefresh
                            }
                        } else { 
                            $handled = $false 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        ChartType = if ($null -ne $Props.ChartType) { $Props.ChartType } else { "Bar" }
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        ShowValues = if ($null -ne $Props.ShowValues) { $Props.ShowValues } else { $true }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
                
                switch ($self.ChartType) {
                    "Bar" {
                        $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $chartHeight = $self.Height - 2
                        $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                        
                        for ($i = 0; $i -lt $self.Data.Count; $i++) {
                            $item = $self.Data[$i]
                            $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                            $barX = $self.X + 2 + ($i * $barWidth)
                            
                            for ($y = 0; $y -lt $barHeight; $y++) { 
                                $barY = $self.Y + $self.Height - 2 - $y
                                Write-BufferString -X $barX -Y $barY -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                            }
                            
                            if ($item.Label -and $barWidth -gt 3) { 
                                $label = $item.Label
                                if ($label.Length -gt $barWidth - 1) { 
                                    $label = $label.Substring(0, $barWidth - 2) 
                                }
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                            }
                            
                            if ($self.ShowValues -and $barHeight -gt 0) { 
                                $valueText = $item.Value.ToString()
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                            }
                        }
                    }
                    "Sparkline" {
                        $width = $self.Width - 2
                        $height = $self.Height - 1
                        $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        
                        $sparkChars = @(" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
                        $sparkline = ""
                        
                        foreach ($value in $self.Data) { 
                            $normalized = ($value / $maxValue)
                            $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                            $sparkline += $sparkChars[$charIndex] 
                        }
                        
                        if ($sparkline.Length -gt $width) { 
                            $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                        } else { 
                            $sparkline = $sparkline.PadLeft($width) 
                        }
                        
                        Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Chart Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Chart HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Container Components

# FIX: REMOVED the legacy New-TuiPanel function entirely.
# All code should now use the more specific panels from layout/panels.psm1.

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart'
)


####\layout\panels.psm1
# FILE: layout/panels.psm1
# PURPOSE: Provides a suite of specialized layout panels for declarative UI construction.

function New-BasePanel {
    param([hashtable]$Props)
    
    $panel = @{
        Type = "Panel"
        Name = if ($null -ne $Props.Name) { $Props.Name } else { "Panel_$([Guid]::NewGuid().ToString('N').Substring(0,8))" }
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        IsFocusable = if ($null -ne $Props.IsFocusable) { $Props.IsFocusable } else { $false }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Children = @()
        Parent = $null
        LayoutProps = if ($null -ne $Props.LayoutProps) { $Props.LayoutProps } else { @{} }
        ShowBorder = if ($null -ne $Props.ShowBorder) { $Props.ShowBorder } else { $false }
        BorderStyle = if ($null -ne $Props.BorderStyle) { $Props.BorderStyle } else { "Single" }  # Single, Double, Rounded
        BorderColor = if ($null -ne $Props.BorderColor) { $Props.BorderColor } else { "Border" } # Theme color name
        Title = $Props.Title
        Padding = if ($null -ne $Props.Padding) { $Props.Padding } else { 0 }
        Margin = if ($null -ne $Props.Margin) { $Props.Margin } else { 0 }
        BackgroundColor = $Props.BackgroundColor
        ForegroundColor = $Props.ForegroundColor
        _isDirty = $true
        _cachedLayout = $null
        
        AddChild = { 
            param($self, $Child, [hashtable]$LayoutProps = @{})
            
            Invoke-WithErrorHandling -Component "$($self.Name).AddChild" -ScriptBlock {
                if (-not $Child) {
                    throw "Cannot add null child to panel"
                }
                
                $Child.Parent = $self
                $Child.LayoutProps = $LayoutProps
                [void]($self.Children += $Child)
                $self._isDirty = $true
                
                # Propagate visibility
                if (-not $self.Visible) {
                    $Child.Visible = $false
                }
            } -Context @{ Parent = $self.Name; ChildType = $Child.Type; ChildName = $Child.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel AddChild error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        RemoveChild = {
            param($self, $Child)
            Invoke-WithErrorHandling -Component "$($self.Name).RemoveChild" -ScriptBlock {
                $self.Children = $self.Children | Where-Object { $_ -ne $Child }
                if ($Child.Parent -eq $self) {
                    $Child.Parent = $null
                }
                $self._isDirty = $true
            } -Context @{ Parent = $self.Name; ChildType = $Child.Type; ChildName = $Child.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel RemoveChild error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        ClearChildren = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).ClearChildren" -ScriptBlock {
                foreach ($child in $self.Children) {
                    $child.Parent = $null
                }
                $self.Children = @()
                $self._isDirty = $true
            } -Context @{ Parent = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel ClearChildren error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Show = { 
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).Show" -ScriptBlock {
                $self.Visible = $true
                foreach ($child in $self.Children) { 
                    if ($child.Show) { 
                        & $child.Show -self $child
                    } else { 
                        $child.Visible = $true
                    }
                }
                
                # Request refresh if we have access to the function
                if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel Show error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Hide = { 
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).Hide" -ScriptBlock {
                $self.Visible = $false
                foreach ($child in $self.Children) { 
                    if ($child.Hide) { 
                        & $child.Hide -self $child
                    } else { 
                        $child.Visible = $false
                    }
                }
                
                # Request refresh if we have access to the function
                if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel Hide error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        HandleInput = { 
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                # Panels typically don't handle input directly
                # but can be overridden for special behavior
                return $false
            } -Context @{ Panel = $self.Name; Key = $Key } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel HandleInput error: $($Exception.Message)" -Data $Exception.Context
                return $false
            }
        }
        
        GetContentBounds = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).GetContentBounds" -ScriptBlock {
                $borderOffset = if ($self.ShowBorder) { 1 } else { 0 }
                
                return @{
                    X = $self.X + $self.Padding + $borderOffset + $self.Margin
                    Y = $self.Y + $self.Padding + $borderOffset + $self.Margin
                    Width = $self.Width - (2 * ($self.Padding + $borderOffset + $self.Margin))
                    Height = $self.Height - (2 * ($self.Padding + $borderOffset + $self.Margin))
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel GetContentBounds error: $($Exception.Message)" -Data $Exception.Context
                return @{ X = $self.X; Y = $self.Y; Width = $self.Width; Height = $self.Height } # Fallback
            }
        }
        
        InvalidateLayout = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).InvalidateLayout" -ScriptBlock {
                $self._isDirty = $true
                
                # Propagate to parent
                if ($self.Parent -and $self.Parent.InvalidateLayout) {
                    & $self.Parent.InvalidateLayout -self $self.Parent
                }
            } -Context @{ Panel = $self.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Panel InvalidateLayout error: $($Exception.Message)" -Data $Exception.Context
            }
        }
    }
    
    return $panel
}

function global:New-TuiStackPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "StackPanel"
    $panel.Layout = 'Stack'
    $panel.Orientation = if ($null -ne $Props.Orientation) { $Props.Orientation } else { 'Vertical' }
    $panel.Spacing = if ($null -ne $Props.Spacing) { $Props.Spacing } else { 1 }
    $panel.HorizontalAlignment = if ($null -ne $Props.HorizontalAlignment) { $Props.HorizontalAlignment } else { 'Stretch' }  # Left, Center, Right, Stretch
    $panel.VerticalAlignment = if ($null -ne $Props.VerticalAlignment) { $Props.VerticalAlignment } else { 'Stretch' }      # Top, Middle, Bottom, Stretch
    
    $panel.CalculateLayout = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).CalculateLayout" -ScriptBlock {
            $bounds = & $self.GetContentBounds -self $self
            $layout = @{
                Children = @()
            }
            
            $currentX = $bounds.X
            $currentY = $bounds.Y
            $totalChildWidth = 0
            $totalChildHeight = 0
            $visibleChildren = $self.Children | Where-Object { $_.Visible }
            
            # Calculate total size needed
            foreach ($child in $visibleChildren) {
                if ($self.Orientation -eq 'Vertical') {
                    $totalChildHeight += $child.Height
                    $totalChildWidth = [Math]::Max($totalChildWidth, $child.Width)
                } else {
                    $totalChildWidth += $child.Width
                    $totalChildHeight = [Math]::Max($totalChildHeight, $child.Height)
                }
            }
            
            # Add spacing
            if ($visibleChildren.Count -gt 1) {
                if ($self.Orientation -eq 'Vertical') {
                    $totalChildHeight += ($visibleChildren.Count - 1) * $self.Spacing
                } else {
                    $totalChildWidth += ($visibleChildren.Count - 1) * $self.Spacing
                }
            }
            
            # Calculate starting position based on alignment
            if ($self.Orientation -eq 'Vertical') {
                switch ($self.VerticalAlignment) {
                    'Top' { $currentY = $bounds.Y }
                    'Middle' { $currentY = $bounds.Y + [Math]::Floor(($bounds.Height - $totalChildHeight) / 2) }
                    'Bottom' { $currentY = $bounds.Y + $bounds.Height - $totalChildHeight }
                    'Stretch' { $currentY = $bounds.Y }
                }
            } else {
                switch ($self.HorizontalAlignment) {
                    'Left' { $currentX = $bounds.X }
                    'Center' { $currentX = $bounds.X + [Math]::Floor(($bounds.Width - $totalChildWidth) / 2) }
                    'Right' { $currentX = $bounds.X + $bounds.Width - $totalChildWidth }
                    'Stretch' { $currentX = $bounds.X }
                }
            }
            
            # Layout children
            foreach ($child in $visibleChildren) {
                $childLayout = @{
                    Component = $child
                    X = $currentX
                    Y = $currentY
                    Width = $child.Width
                    Height = $child.Height
                }
                
                # Apply stretch behavior
                if ($self.Orientation -eq 'Vertical' -and $self.HorizontalAlignment -eq 'Stretch') {
                    $childLayout.Width = $bounds.Width
                    # Update child's actual width for proper rendering
                    if ($child.Width -ne $bounds.Width) {
                        $child.Width = $bounds.Width
                    }
                }
                elseif ($self.Orientation -eq 'Horizontal' -and $self.VerticalAlignment -eq 'Stretch') {
                    $childLayout.Height = $bounds.Height
                    # Update child's actual height for proper rendering
                    if ($child.Height -ne $bounds.Height) {
                        $child.Height = $bounds.Height
                    }
                }
                
                # Handle horizontal alignment for vertical stacks
                if ($self.Orientation -eq 'Vertical' -and $self.HorizontalAlignment -ne 'Stretch') {
                    switch ($self.HorizontalAlignment) {
                        'Center' { $childLayout.X = $bounds.X + [Math]::Floor(($bounds.Width - $child.Width) / 2) }
                        'Right' { $childLayout.X = $bounds.X + $bounds.Width - $child.Width }
                    }
                }
                
                # Handle vertical alignment for horizontal stacks
                if ($self.Orientation -eq 'Horizontal' -and $self.VerticalAlignment -ne 'Stretch') {
                    switch ($self.VerticalAlignment) {
                        'Middle' { $childLayout.Y = $bounds.Y + [Math]::Floor(($bounds.Height - $child.Height) / 2) }
                        'Bottom' { $childLayout.Y = $bounds.Y + $bounds.Height - $child.Height }
                    }
                }
                
                # FIX: CRITICAL - Apply calculated positions and sizes back to the child component
                $child.X = $childLayout.X
                $child.Y = $childLayout.Y
                if ($childLayout.Width -ne $child.Width -and $child.PSObject.Properties['Width'].IsSettable) {
                    $child.Width = $childLayout.Width
                }
                if ($childLayout.Height -ne $child.Height -and $child.PSObject.Properties['Height'].IsSettable) {
                    $child.Height = $childLayout.Height
                }
                
                $layout.Children += $childLayout
                
                # Move to next position
                if ($self.Orientation -eq 'Vertical') {
                    $currentY += $childLayout.Height + $self.Spacing
                } else {
                    $currentX += $childLayout.Width + $self.Spacing
                }
            }
            
            $self._cachedLayout = $layout
            $self._isDirty = $false
            return $layout
        } -Context @{ Panel = $self.Name; Orientation = $self.Orientation } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "StackPanel CalculateLayout error: $($Exception.Message)" -Data $Exception.Context
            return @{ Children = @() } # Return empty layout on error
        }
    }
    
    $panel.Render = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
            if (-not $self.Visible) { return }
            
            # Clear panel area first to prevent bleed-through
            $bgColor = if ($self.BackgroundColor) { 
                $self.BackgroundColor 
            } else { 
                Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
            }
            
            # FIX: Fill the entire panel area with background color
            for ($y = $self.Y; $y -lt ($self.Y + $self.Height); $y++) {
                Write-BufferString -X $self.X -Y $y -Text (' ' * $self.Width) -BackgroundColor $bgColor
            }
            
            if ($self.ShowBorder) {
                # FIX: Use proper theme colors for borders
                $borderColor = if ($self.BorderColor) {
                    Get-ThemeColor $self.BorderColor -Default ([ConsoleColor]::Gray)
                } elseif ($self.ForegroundColor) { 
                    $self.ForegroundColor 
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::Gray)
                }
                
                # FIX: Use BorderStyle from panel properties
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor `
                    -BorderStyle $self.BorderStyle -Title $self.Title
            }
            # FIX: Ensure layout is calculated before Z-Index renderer processes children.
            & $self.CalculateLayout -self $self
        } -Context @{ Panel = $self.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "StackPanel Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    return $panel
}

function global:New-TuiGridPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "GridPanel"
    $panel.Layout = 'Grid'
    $panel.RowDefinitions = if ($null -ne $Props.RowDefinitions) { $Props.RowDefinitions } else { @("1*") }
    $panel.ColumnDefinitions = if ($null -ne $Props.ColumnDefinitions) { $Props.ColumnDefinitions } else { @("1*") }
    $panel.ShowGridLines = if ($null -ne $Props.ShowGridLines) { $Props.ShowGridLines } else { $false }
    $panel.GridLineColor = if ($null -ne $Props.GridLineColor) { $Props.GridLineColor } else { Get-ThemeColor "BorderDim" -Default DarkGray }
    
    $panel._CalculateGridSizes = {
        param($self, $definitions, $totalSize)
        Invoke-WithErrorHandling -Component "$($self.Name)._CalculateGridSizes" -ScriptBlock {
            $parsedDefs = @()
            $totalFixed = 0
            $totalStars = 0.0
            
            foreach ($def in $definitions) {
                if ($def -match '^(\d+)$') {
                    $parsedDefs += @{ Type = 'Fixed'; Value = [int]$Matches[1] }
                    $totalFixed += [int]$Matches[1]
                } elseif ($def -match '^(\d*\.?\d*)\*$') {
                    $stars = if ($Matches[1]) { [double]$Matches[1] } else { 1.0 }
                    $parsedDefs += @{ Type = 'Star'; Value = $stars }
                    $totalStars += $stars
                } elseif ($def -eq 'Auto') {
                    $parsedDefs += @{ Type = 'Star'; Value = 1.0 }
                    $totalStars += 1.0
                } else {
                    throw "Invalid grid definition: $def"
                }
            }
            
            $remainingSize = [Math]::Max(0, $totalSize - $totalFixed)
            $sizes = @()
            
            foreach ($def in $parsedDefs) {
                if ($def.Type -eq 'Fixed') {
                    $sizes += $def.Value
                } else {
                    $size = if ($totalStars -gt 0) { [Math]::Floor($remainingSize * ($def.Value / $totalStars)) } else { 0 }
                    $sizes += $size
                }
            }
            
            # FIX: Distribute rounding errors to the last star-sized cell to ensure total size is met.
            $totalAllocated = ($sizes | Measure-Object -Sum).Sum
            if ($totalAllocated -ne $totalSize -and $totalStars -gt 0) {
                $lastStarIndex = -1
                for($i = $parsedDefs.Count - 1; $i -ge 0; $i--) {
                    if ($parsedDefs[$i].Type -eq 'Star') {
                        $lastStarIndex = $i; break
                    }
                }
                if ($lastStarIndex -ne -1) {
                    $sizes[$lastStarIndex] += ($totalSize - $totalAllocated)
                }
            }
            
            return $sizes
        } -Context @{ Panel = $self.Name; Definitions = $definitions; TotalSize = $totalSize } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel _CalculateGridSizes error: $($Exception.Message)" -Data $Exception.Context
            return @() # Return empty array on error
        }
    }
    
    $panel.CalculateLayout = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).CalculateLayout" -ScriptBlock {
            $bounds = & $self.GetContentBounds -self $self
            
            $rowHeights = & $self._CalculateGridSizes -self $self -definitions $self.RowDefinitions -totalSize $bounds.Height
            $colWidths = & $self._CalculateGridSizes -self $self -definitions $self.ColumnDefinitions -totalSize $bounds.Width
            
            $rowOffsets = @(0); for ($i = 0; $i -lt $rowHeights.Count - 1; $i++) { $rowOffsets += ($rowOffsets[-1] + $rowHeights[$i]) }
            $colOffsets = @(0); for ($i = 0; $i -lt $colWidths.Count - 1; $i++) { $colOffsets += ($colOffsets[-1] + $colWidths[$i]) }
            
            $layout = @{ Children = @(); Rows = $rowHeights; Columns = $colWidths; RowOffsets = $rowOffsets; ColumnOffsets = $colOffsets }
            
            foreach ($child in $self.Children) {
                if (-not $child.Visible) { continue }
                
                $gridRow = if ($null -ne $child.LayoutProps."Grid.Row") { [int]$child.LayoutProps."Grid.Row" } else { 0 }
                $gridCol = if ($null -ne $child.LayoutProps."Grid.Column") { [int]$child.LayoutProps."Grid.Column" } else { 0 }
                $gridRowSpan = if ($null -ne $child.LayoutProps."Grid.RowSpan") { [int]$child.LayoutProps."Grid.RowSpan" } else { 1 }
                $gridColSpan = if ($null -ne $child.LayoutProps."Grid.ColumnSpan") { [int]$child.LayoutProps."Grid.ColumnSpan" } else { 1 }
                
                $row = [Math]::Max(0, [Math]::Min($rowHeights.Count - 1, $gridRow))
                $col = [Math]::Max(0, [Math]::Min($colWidths.Count - 1, $gridCol))
                $rowSpan = [Math]::Max(1, [Math]::Min($rowHeights.Count - $row, $gridRowSpan))
                $colSpan = [Math]::Max(1, [Math]::Min($colWidths.Count - $col, $gridColSpan))
                
                $cellX = $bounds.X + $colOffsets[$col]; $cellY = $bounds.Y + $rowOffsets[$row]
                $cellWidth = 0; for ($i = 0; $i -lt $colSpan; $i++) { if (($col + $i) -lt $colWidths.Count) { $cellWidth += $colWidths[$col + $i] } }
                $cellHeight = 0; for ($i = 0; $i -lt $rowSpan; $i++) { if (($row + $i) -lt $rowHeights.Count) { $cellHeight += $rowHeights[$row + $i] } }
                
                $childX = $cellX; $childY = $cellY
                $childWidth = $child.Width; $childHeight = $child.Height
                
                $hAlign = if ($null -ne $child.LayoutProps."Grid.HorizontalAlignment") { $child.LayoutProps."Grid.HorizontalAlignment" } else { "Stretch" }
                switch ($hAlign) {
                    "Center" { $childX = $cellX + [Math]::Floor(($cellWidth - $childWidth) / 2) }
                    "Right" { $childX = $cellX + $cellWidth - $childWidth }
                    "Stretch" { $childWidth = $cellWidth }
                }
                
                $vAlign = if ($null -ne $child.LayoutProps."Grid.VerticalAlignment") { $child.LayoutProps."Grid.VerticalAlignment" } else { "Stretch" }
                switch ($vAlign) {
                    "Middle" { $childY = $cellY + [Math]::Floor(($cellHeight - $childHeight) / 2) }
                    "Bottom" { $childY = $cellY + $cellHeight - $childHeight }
                    "Stretch" { $childHeight = $cellHeight }
                }
                
                # FIX: CRITICAL - Apply calculated positions and sizes back to the child component
                $child.X = $childX
                $child.Y = $childY
                if ($child.PSObject.Properties['Width'] -and $child.Width -ne $childWidth) { $child.Width = $childWidth }
                if ($child.PSObject.Properties['Height'] -and $child.Height -ne $childHeight) { $child.Height = $childHeight }
                
                $layout.Children += @{ Component = $child; X = $childX; Y = $childY; Width = $childWidth; Height = $childHeight }
            }
            
            $self._cachedLayout = $layout
            $self._isDirty = $false
            return $layout
        } -Context @{ Panel = $self.Name; RowDefs = $self.RowDefinitions; ColDefs = $self.ColumnDefinitions } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel CalculateLayout error: $($Exception.Message)" -Data $Exception.Context
            return @{ Children = @() } # Return empty layout on error
        }
    }
    
    $panel.Render = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
            if (-not $self.Visible) { return }
            
            # Clear panel area first to prevent bleed-through
            $bgColor = if ($self.BackgroundColor) { 
                $self.BackgroundColor 
            } else { 
                Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
            }
            
            # FIX: Fill the entire panel area with background color
            for ($y = $self.Y; $y -lt ($self.Y + $self.Height); $y++) {
                Write-BufferString -X $self.X -Y $y -Text (' ' * $self.Width) -BackgroundColor $bgColor
            }
            
            if ($self.ShowBorder) {
                # FIX: Use proper theme colors for borders
                $borderColor = if ($self.BorderColor) {
                    Get-ThemeColor $self.BorderColor -Default ([ConsoleColor]::Gray)
                } elseif ($self.ForegroundColor) { 
                    $self.ForegroundColor 
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::Gray)
                }
                
                # FIX: Use BorderStyle from panel properties
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor `
                    -BorderStyle $self.BorderStyle -Title $self.Title
            }
            
            # FIX: Calculate layout to set child positions. TUI engine will render the children.
            $layout = & $self.CalculateLayout -self $self
            
            if ($self.ShowGridLines) {
                $bounds = & $self.GetContentBounds -self $self
                foreach ($offset in $layout.ColumnOffsets[1..($layout.ColumnOffsets.Count - 1)]) {
                    $x = $bounds.X + $offset; for ($y = $bounds.Y; $y -lt ($bounds.Y + $bounds.Height); $y++) { Write-BufferString -X $x -Y $y -Text "│" -ForegroundColor $self.GridLineColor }
                }
                foreach ($offset in $layout.RowOffsets[1..($layout.RowOffsets.Count - 1)]) {
                    $y = $bounds.Y + $offset; Write-BufferString -X $bounds.X -Y $y -Text ("─" * $bounds.Width) -ForegroundColor $self.GridLineColor
                }
            }
        } -Context @{ Panel = $self.Name } -ErrorHandler {
            param($Exception)
            Write-Log -Level Error -Message "GridPanel Render error: $($Exception.Message)" -Data $Exception.Context
        }
    }
    
    return $panel
}

function global:New-TuiDockPanel { param([hashtable]$Props = @{}) ; return New-TuiStackPanel -Props ($Props.Clone() | Add-Member -MemberType NoteProperty -Name Orientation -Value 'Vertical' -PassThru) }
function global:New-TuiWrapPanel { param([hashtable]$Props = @{}) ; return New-TuiStackPanel -Props $Props }

Export-ModuleMember -Function "New-BasePanel", "New-TuiStackPanel", "New-TuiGridPanel", "New-TuiDockPanel", "New-TuiWrapPanel"


####\modules\data-manager.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration
# AI: Refactored from dispatch-based actions to direct function calls
# AI: Now uses strongly-typed PmcTask and PmcProject classes from models module

using module .\models.psm1
using module .\exceptions.psm1
using module .\event-system.psm1
using module .\logger.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Module-level state variables
$script:Data = @{
    Projects = [System.Collections.Generic.List[PmcProject]]::new()
    Tasks = [System.Collections.Generic.List[PmcTask]]::new()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    # AI: Maintaining compatibility with legacy underscore format
    time_entries = @()    # underscore format for action compatibility
    timers = @()          # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system
    
    .DESCRIPTION
    Sets up the data directory, loads existing data, and configures event handlers
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.Initialize" -ScriptBlock {
        # Ensure data directory exists
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        # Ensure backup directory exists
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        # Load existing data
        Load-UnifiedData
        
        # Initialize event handlers
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        
        # AI: Return service object with methods for direct invocation
        return [PSCustomObject]@{
            AddTask = Get-Command Add-PmcTask
            UpdateTask = Get-Command Update-PmcTask
            RemoveTask = Get-Command Remove-PmcTask
            GetTasks = Get-Command Get-PmcTasks
            GetProjects = Get-Command Get-PmcProjects
            SaveData = Get-Command Save-UnifiedData
            LoadData = Get-Command Load-UnifiedData
        }
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk
    
    .DESCRIPTION
    Loads the unified data file and populates the global data structure with strongly-typed objects
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $content = Get-Content -Path $script:DataPath -Raw
                $loadedData = $content | ConvertFrom-Json -AsHashtable
                
                # AI: Defensive validation of loaded data structure
                if ($loadedData -and $loadedData -is [hashtable]) {
                    # AI: Re-hydrate Tasks as PmcTask objects
                    if ($loadedData.ContainsKey('Tasks') -and $loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) {
                                # AI: Use static method to create from legacy format
                                $task = [PmcTask]::FromLegacyFormat($taskData)
                                $script:Data.Tasks.Add($task)
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    # AI: Re-hydrate Projects as PmcProject objects
                    if ($loadedData.ContainsKey('Projects') -and $loadedData.Projects) {
                        $script:Data.Projects.Clear()
                        # AI: Projects were stored as hashtable, need to convert each value
                        if ($loadedData.Projects -is [hashtable]) {
                            foreach ($projectKey in $loadedData.Projects.Keys) {
                                $projectData = $loadedData.Projects[$projectKey]
                                if ($projectData -is [hashtable]) {
                                    $project = [PmcProject]::FromLegacyFormat($projectData)
                                    $script:Data.Projects.Add($project)
                                }
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    # AI: Load other data structures as-is for now
                    foreach ($key in @('TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers')) {
                        if ($loadedData.ContainsKey($key)) {
                            $script:Data[$key] = $loadedData[$key]
                        }
                    }
                    
                    # Update global data reference
                    $global:Data = $script:Data
                    
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                Write-Log -Level Info -Message "Using default data structure"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk
    
    .DESCRIPTION
    Persists the current data state to disk with automatic backup rotation
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -ScriptBlock {
        # Create backup if file exists
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            $backupFilePath = Join-Path $script:BackupPath $backupName
            Copy-Item -Path $script:DataPath -Destination $backupFilePath -Force
            
            # Rotate backups
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | 
                       Sort-Object LastWriteTime -Descending
            
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        # AI: Convert strongly-typed objects to legacy format for JSON serialization
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}  # AI: Convert back to hashtable format for compatibility
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        # AI: Rebuild Projects hashtable keyed by project key
        foreach ($project in $script:Data.Projects) {
            $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat()
        }
        
        # Save current data
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date
        $script:DataModified = $false
        
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    <#
    .SYNOPSIS
    Creates a new task
    
    .DESCRIPTION
    Adds a new task to the data store and publishes a Tasks.Changed event
    
    .PARAMETER Title
    The title of the task (required)
    
    .PARAMETER Description
    The task description
    
    .PARAMETER Priority
    Task priority: low, medium, or high
    
    .PARAMETER Category
    Task category/project name
    
    .PARAMETER DueDate
    Task due date
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Title,
        
        [string]$Description = "",
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority = "medium",
        
        [string]$Category = "General",
        
        [string]$DueDate = ""
    )
    
    Invoke-WithErrorHandling -Component "DataManager.AddTask" -ScriptBlock {
        # AI: Input validation
        if ([string]::IsNullOrWhiteSpace($Title)) {
            throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title })
        }
        
        # AI: Convert string priority to enum
        $taskPriority = switch ($Priority.ToLower()) {
            "low" { [TaskPriority]::Low }
            "medium" { [TaskPriority]::Medium }
            "high" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # AI: Create new task using class constructor
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        # AI: Set due date if provided
        if ($DueDate -and $DueDate -ne "N/A") {
            try {
                $newTask.DueDate = [datetime]::Parse($DueDate)
            } catch {
                Write-Log -Level Warning -Message "Invalid due date format: $DueDate"
                $newTask.DueDate = $null
            }
        }
        
        # AI: Add to strongly-typed task list
        $script:Data.Tasks.Add($newTask)
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Created"
            TaskId = $newTask.Id
            Task = $newTask
        }
        
        return $newTask
    }
}

function Update-PmcTask {
    <#
    .SYNOPSIS
    Updates an existing task
    
    .DESCRIPTION
    Modifies task properties and publishes a Tasks.Changed event
    
    .PARAMETER Task
    The PmcTask object to update (required)
    
    .PARAMETER Title
    New task title
    
    .PARAMETER Description
    New task description
    
    .PARAMETER Priority
    New task priority
    
    .PARAMETER Category
    New task category
    
    .PARAMETER DueDate
    New due date
    
    .PARAMETER Completed
    Task completion status
    
    .PARAMETER Progress
    Task progress percentage (0-100)
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcTask]$Task,
        
        [string]$Title,
        
        [string]$Description,
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority,
        
        [string]$Category,
        
        [string]$DueDate,
        
        [bool]$Completed,
        
        [ValidateRange(0, 100)]
        [int]$Progress
    )
    
    Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -ScriptBlock {
        # AI: Find task in list to ensure we're updating the managed instance
        $managedTask = $script:Data.Tasks | Where-Object { $_.Id -eq $Task.Id } | Select-Object -First 1
        
        if (-not $managedTask) {
            throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id })
        }
        
        $updatedFields = @()
        
        # AI: Update task properties using proper object properties
        if ($PSBoundParameters.ContainsKey('Title') -and $Title) { 
            $managedTask.Title = $Title.Trim()
            $updatedFields += "Title"
        }
        if ($PSBoundParameters.ContainsKey('Description')) { 
            $managedTask.Description = $Description
            $updatedFields += "Description"
        }
        if ($PSBoundParameters.ContainsKey('Priority')) {
            $managedTask.Priority = switch ($Priority.ToLower()) {
                "low" { [TaskPriority]::Low }
                "medium" { [TaskPriority]::Medium }
                "high" { [TaskPriority]::High }
                default { [TaskPriority]::Medium }
            }
            $updatedFields += "Priority"
        }
        if ($PSBoundParameters.ContainsKey('Category')) { 
            $managedTask.ProjectKey = $Category
            $managedTask.Category = $Category  # AI: Maintain backward compatibility
            $updatedFields += "Category"
        }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            if ($DueDate -and $DueDate -ne "N/A") {
                try {
                    $managedTask.DueDate = [datetime]::Parse($DueDate)
                } catch {
                    Write-Log -Level Warning -Message "Invalid due date format: $DueDate"
                    $managedTask.DueDate = $null
                }
            } else {
                $managedTask.DueDate = $null
            }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) {
            # AI: Use class method which handles status updates
            $managedTask.UpdateProgress($Progress)
            $updatedFields += "Progress"
        }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) {
                $managedTask.Complete()
            } else {
                $managedTask.Status = [TaskStatus]::Pending
                $managedTask.Completed = $false
                $managedTask.Progress = 0
            }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Updated"
            TaskId = $managedTask.Id
            Task = $managedTask
            UpdatedFields = $updatedFields
        }
        
        return $managedTask
    }
}

function Remove-PmcTask {
    <#
    .SYNOPSIS
    Removes a task from the data store
    
    .DESCRIPTION
    Deletes a task and publishes a Tasks.Changed event
    
    .PARAMETER Task
    The PmcTask object to remove
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcTask]$Task
    )
    
    Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -ScriptBlock {
        # AI: Find and remove task from strongly-typed list
        $taskToRemove = $script:Data.Tasks | Where-Object { $_.Id -eq $Task.Id } | Select-Object -First 1
        
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null
            $script:DataModified = $true
            
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            
            # Auto-save if enabled
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            # AI: Publish event for UI refresh
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Deleted"
                TaskId = $Task.Id
                Task = $Task
            }
            
            return $true
        } else {
            Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"
            return $false
        }
    }
}

function Get-PmcTasks {
    <#
    .SYNOPSIS
    Retrieves tasks from the data store
    
    .DESCRIPTION
    Returns all tasks or filtered tasks based on criteria
    
    .PARAMETER Completed
    Filter by completion status
    
    .PARAMETER Priority
    Filter by priority level
    
    .PARAMETER Category
    Filter by category/project
    #>
    [CmdletBinding()]
    param(
        [bool]$Completed,
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority,
        
        [string]$Category
    )
    
    Invoke-WithErrorHandling -Component "DataManager.GetTasks" -ScriptBlock {
        # AI: Start with all tasks from strongly-typed list
        $tasks = $script:Data.Tasks
        
        # Apply filters if specified
        if ($PSBoundParameters.ContainsKey('Completed')) {
            $tasks = $tasks | Where-Object { $_.Completed -eq $Completed }
        }
        
        if ($Priority) {
            # AI: Convert string to enum for comparison
            $priorityEnum = switch ($Priority.ToLower()) {
                "low" { [TaskPriority]::Low }
                "medium" { [TaskPriority]::Medium }
                "high" { [TaskPriority]::High }
            }
            $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum }
        }
        
        if ($Category) {
            $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category }
        }
        
        # AI: Return as array to maintain compatibility
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects {
    <#
    .SYNOPSIS
    Retrieves all projects from the data store
    
    .DESCRIPTION
    Returns all PmcProject objects as an array
    #>
    [CmdletBinding()]
    param()
    
    # AI: Return projects from strongly-typed list as array
    return @($script:Data.Projects)
}

function Get-PmcProject {
    <#
    .SYNOPSIS
    Retrieves a specific project by key
    
    .PARAMETER Key
    The project key
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Key
    )
    
    # AI: Find project in list by key
    return $script:Data.Projects | Where-Object { $_.Key -eq $Key } | Select-Object -First 1
}

function Add-PmcProject {
    <#
    .SYNOPSIS
    Adds a new project to the data store
    
    .PARAMETER Project
    The PmcProject object to add
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcProject]$Project
    )
    
    Invoke-WithErrorHandling -Component "DataManager.AddProject" -ScriptBlock {
        # AI: Check if project with same key already exists
        $existing = $script:Data.Projects | Where-Object { $_.Key -eq $Project.Key } | Select-Object -First 1
        
        if ($existing) {
            throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key })
        }
        
        # AI: Add to strongly-typed project list
        $script:Data.Projects.Add($Project)
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Projects.Changed" -Data @{
            Action = "Created"
            ProjectKey = $Project.Key
            Project = $Project
        }
        
        return $Project
    }
}

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    <#
    .SYNOPSIS
    Sets up event handlers for data operations
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -ScriptBlock {
        # AI: Subscribe to refresh request events for backward compatibility
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            param($EventData)
            
            # Simply publish the current task data
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Refreshed"
                Tasks = @($script:Data.Tasks)
            }
        }
        
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion

# Export public functions
Export-ModuleMember -Function @(
    'Initialize-DataManager',
    'Add-PmcTask',
    'Update-PmcTask', 
    'Remove-PmcTask',
    'Get-PmcTasks',
    'Get-PmcProjects',
    'Get-PmcProject',
    'Add-PmcProject',
    'Save-UnifiedData',
    'Load-UnifiedData'
)


####\modules\dialog-system.psm1
# Dialog System Module - FIXED VERSION
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function global:Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    Invoke-WithErrorHandling -Component "DialogSystem.ShowDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
        }
        $script:DialogState.CurrentDialog = $DialogComponent
        Request-TuiRefresh
    } -Context @{ DialogType = $DialogComponent.Type; DialogTitle = $DialogComponent.Title } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show dialog '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    Invoke-WithErrorHandling -Component "DialogSystem.CloseDialog" -ScriptBlock {
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        } else {
            $script:DialogState.CurrentDialog = $null
        }
        Request-TuiRefresh
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to close dialog: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowConfirmDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("Yes", "No")
            Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
            Height        = 10
            OnButtonClick = {
                param($Button, $Index)
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog
                    if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
                } -Context @{ Button = $Button; Index = $Index; DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Confirm Dialog button click error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog; & $OnCancel 
                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Confirm Dialog cancel error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context @{ Title = $Title; Message = $Message } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show confirm dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowAlertDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("OK")
            Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
            Height        = 10
            OnButtonClick = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog 
                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Alert Dialog button click error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog 
                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Alert Dialog cancel error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context @{ Title = $Title; Message = $Message } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show alert dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowInputDialog" -ScriptBlock {
        # Create a screen that contains the input components
        $inputScreen = @{
            Name = "InputDialog"
            State = @{
                InputValue = $DefaultValue
                FocusedIndex = 0  # Start with textbox focused
            }
            _focusableNames = @("InputTextBox", "OKButton", "CancelButton")
            _focusedIndex = 0
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
                    # Calculate dialog dimensions
                    $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
                    $dialogHeight = 10
                    $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
                    $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight `
                        -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    $promptX = $dialogX + 2
                    $promptY = $dialogY + 2
                    Write-BufferString -X $promptX -Y $promptY -Text $Prompt
                    
                    # Draw text input
                    $inputY = $promptY + 2
                    $inputWidth = $dialogWidth - 4
                    $isFocused = ($self._focusedIndex -eq 0)
                    $borderColor = if ($isFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 `
                        -BorderColor $borderColor
                    
                    # Draw input value
                    $displayText = $self.State.InputValue
                    if ($displayText.Length > ($inputWidth - 3)) {
                        $displayText = $displayText.Substring(0, $inputWidth - 3) # Ensure it fits
                    }
                    Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
                    
                    # Draw cursor if textbox is focused
                    if ($isFocused) {
                        $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                        Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) `
                            -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
                    }
                    
                    # Draw buttons
                    $buttonY = $dialogY + $dialogHeight - 2
                    $buttonSpacing = 15
                    $buttonsWidth = $buttonSpacing * 2
                    $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
                    
                    # OK button
                    $okFocused = ($self._focusedIndex -eq 1)
                    $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
                    $okColor = if ($okFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
                    
                    # Cancel button
                    $cancelFocused = ($self._focusedIndex -eq 2)
                    $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
                    $cancelColor = if ($cancelFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
                } -Context @{ DialogName = $self.Name; Prompt = $Prompt; CurrentValue = $self.State.InputValue } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Input Dialog Render error for '$($Exception.Context.DialogName)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                    # Handle Tab navigation
                    if ($Key.Key -eq [ConsoleKey]::Tab) {
                        $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                        $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                        Request-TuiRefresh
                        return $true
                    }
                    
                    # Handle Escape
                    if ($Key.Key -eq [ConsoleKey]::Escape) {
                        Close-TuiDialog
                        Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                            & $OnCancel
                        } -Context @{ DialogTitle = $Title } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Input Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                    
                    # Handle based on focused element
                    switch ($self._focusedIndex) {
                        0 {  # TextBox
                            switch ($Key.Key) {
                                ([ConsoleKey]::Enter) {
                                    Close-TuiDialog
                                    Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                        & $OnSubmit -Value $self.State.InputValue
                                    } -Context @{ DialogTitle = $Title; InputValue = $self.State.InputValue } -ErrorHandler {
                                        param($Exception)
                                        Write-Log -Level Error -Message "Input Dialog OnSubmit error: $($Exception.Message)" -Data $Exception.Context
                                    }
                                    return $true
                                }
                                ([ConsoleKey]::Backspace) {
                                    if ($self.State.InputValue.Length -gt 0) {
                                        $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1)
                                        Request-TuiRefresh
                                    }
                                    return $true
                                }
                                default {
                                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                        $self.State.InputValue += $Key.KeyChar
                                        Request-TuiRefresh
                                        return $true
                                    }
                                }
                            }
                        }
                        1 {  # OK Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                    & $OnSubmit -Value $self.State.InputValue
                                } -Context @{ DialogTitle = $Title; InputValue = $self.State.InputValue } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "Input Dialog OnSubmit error: $($Exception.Message)" -Data $Exception.Context
                                }
                                return $true
                            }
                        }
                        2 {  # Cancel Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                                    & $OnCancel
                                } -Context @{ DialogTitle = $Title } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "Input Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                                }
                                return $true
                            }
                        }
                    }
                    
                    return $false
                } -Context @{ DialogName = $self.Name; Key = $Key; FocusedIndex = $self._focusedIndex } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Input Dialog HandleInput error for '$($Exception.Context.DialogName)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
        }
        
        $script:DialogState.CurrentDialog = $inputScreen
        Request-TuiRefresh
    } -Context @{ Title = $Title; Prompt = $Prompt; DefaultValue = $DefaultValue } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show input dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

#endregion

#region --- Engine Integration & Initialization ---

function global:Initialize-DialogSystem {
    <# .SYNOPSIS Subscribes to high-level application events to show dialogs. #>
    Invoke-WithErrorHandling -Component "DialogSystem.Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.ConfirmEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-ConfirmDialog @dialogParams
            } -Context @{ EventData = $EventData } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Confirm.Request event handler error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.AlertEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-AlertDialog @dialogParams
            } -Context @{ EventData = $EventData } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Alert.Show event handler error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.InputEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-InputDialog @dialogParams
            } -Context @{ EventData = $EventData } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Input.Request event handler error: $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        Write-Verbose "Dialog System initialized and event handlers registered."
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Dialog System: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Render-Dialogs {
    <# .SYNOPSIS Engine Hook: Renders the current dialog over the screen. #>
    Invoke-WithErrorHandling -Component "DialogSystem.RenderDialogs" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            # If it's a component with its own render method
            if ($script:DialogState.CurrentDialog.Render) {
                & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
            }
        }
    } -Context @{ CurrentDialog = $script:DialogState.CurrentDialog.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error rendering dialog '$($Exception.Context.CurrentDialog)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Handle-DialogInput {
    <# .SYNOPSIS Engine Hook: Intercepts input if a dialog is active. #>
    param($Key)
    Invoke-WithErrorHandling -Component "DialogSystem.HandleDialogInput" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            if ($script:DialogState.CurrentDialog.HandleInput) {
                return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
            }
        }
        return $false
    } -Context @{ CurrentDialog = $script:DialogState.CurrentDialog.Name; Key = $Key } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error handling dialog input for '$($Exception.Context.CurrentDialog)': $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

function global:Update-DialogSystem {
    <# .SYNOPSIS Engine Hook: Updates dialog system state. #>
    Invoke-WithErrorHandling -Component "DialogSystem.UpdateDialogSystem" -ScriptBlock {
        # Placeholder for any periodic updates needed
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Error updating dialog system: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:New-TuiDialog {
    <# .SYNOPSIS Creates a simple dialog component. #>
    param([hashtable]$Props = @{})
    
    $dialog = @{
        Type = "Dialog"
        Title = if ($Props.Title) { $Props.Title } else { "Dialog" }
        Message = if ($Props.Message) { $Props.Message } else { "" }
        Buttons = if ($Props.Buttons) { $Props.Buttons } else { @("OK") }
        SelectedButton = 0
        Width = if ($Props.Width) { $Props.Width } else { 50 }
        Height = if ($Props.Height) { $Props.Height } else { 10 }
        X = 0
        Y = 0
        OnButtonClick = if ($Props.OnButtonClick) { $Props.OnButtonClick } else { {} }
        OnCancel = if ($Props.OnCancel) { $Props.OnCancel } else { {} }
        
        Render = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                # Center the dialog
                $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                
                # Draw dialog box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
                
                # Use engine's word wrap helper
                $messageY = $self.Y + 2
                $messageX = $self.X + 2
                $maxWidth = $self.Width - 4
                
                $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
                
                foreach ($line in $wrappedLines) {
                    if ($messageY -ge ($self.Y + $self.Height - 3)) { break }  # Don't overwrite buttons
                    Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                    $messageY++
                }
                
                # Buttons
                $buttonY = $self.Y + $self.Height - 3
                $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
                $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
                
                for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                    $isSelected = ($i -eq $self.SelectedButton)
                    $buttonText = if ($isSelected) { "[ $($self.Buttons[$i]) ]" } else { "  $($self.Buttons[$i])  " }
                    $color = if ($isSelected) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                    $buttonX += 14
                }
            } -Context @{ DialogTitle = $self.Title; DialogMessage = $self.Message } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Dialog Render error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
            }
        }
        
        HandleInput = {
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Tab) {
                        $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count
                        Request-TuiRefresh
                        return $true
                    }
                    
                    ([ConsoleKey]::Enter) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Dialog OnButtonClick error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Dialog OnButtonClick error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                    ([ConsoleKey]::Escape) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnCancel" -ScriptBlock {
                            & $self.OnCancel
                        } -Context @{ DialogTitle = $self.Title } -ErrorHandler {
                            param($Exception)
                            Write-Log -Level Error -Message "Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                        }
                        return $true
                    }
                }
                
                return $false
            } -Context @{ DialogTitle = $self.Title; Key = $Key; SelectedButton = $self.SelectedButton } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Dialog HandleInput error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                return $false
            }
        }
    }
    
    return $dialog
}

function global:Show-ProgressDialog {
    <# .SYNOPSIS Shows a progress dialog with updating percentage. #>
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowProgressDialog" -ScriptBlock {
        $dialog = @{
            Type = "ProgressDialog"
            Title = $Title
            Message = $Message
            PercentComplete = $PercentComplete
            Width = 60
            Height = 8
            ShowCancel = $ShowCancel
            IsCancelled = $false
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    # Center the dialog
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw message
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
                    
                    # Draw progress bar
                    $barY = $y + 4
                    $barWidth = $self.Width - 4
                    $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
                    
                    # Progress bar background
                    Write-BufferString -X ($x + 2) -Y $barY `
                        -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
                    
                    # Progress bar fill
                    if ($filledWidth -gt 0) {
                        Write-BufferString -X ($x + 2) -Y $barY `
                            -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success")
                    }
                    
                    # Percentage text
                    $percentText = "$($self.PercentComplete)%"
                    $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $percentX -Y $barY -Text $percentText
                    
                    # Cancel button if requested
                    if ($self.ShowCancel) {
                        $buttonY = $y + $self.Height - 2
                        $buttonText = if ($self.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
                        $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText `
                            -ForegroundColor (Get-ThemeColor "Warning")
                    }
                } -Context @{ DialogTitle = $self.Title; Percent = $self.PercentComplete } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Progress Dialog Render error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    if ($self.ShowCancel -and -not $self.IsCancelled) {
                        if ($Key.Key -eq [ConsoleKey]::Escape -or 
                            $Key.Key -eq [ConsoleKey]::Enter -or 
                            $Key.Key -eq [ConsoleKey]::Spacebar) {
                            $self.IsCancelled = $true
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    
                    return $false
                } -Context @{ DialogTitle = $self.Title; Key = $Key } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Progress Dialog HandleInput error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            UpdateProgress = {
                param($self, [int]$PercentComplete, [string]$Message = $null)
                Invoke-WithErrorHandling -Component "$($self.Type).UpdateProgress" -ScriptBlock {
                    $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
                    if ($Message) { $self.Message = $Message }
                    Request-TuiRefresh
                } -Context @{ DialogTitle = $self.Title; NewPercent = $PercentComplete; NewMessage = $Message } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Progress Dialog UpdateProgress error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
        return $dialog
    } -Context @{ Title = $Title; Message = $Message; Percent = $PercentComplete } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show progress dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:Show-ListDialog {
    <# .SYNOPSIS Shows a dialog with a selectable list of items. #>
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowListDialog" -ScriptBlock {
        $dialog = @{
            Type = "ListDialog"
            Title = $Title
            Prompt = $Prompt
            Items = $Items
            SelectedIndex = 0
            SelectedItems = @()
            Width = 60
            Height = [Math]::Min(20, $Items.Count + 8)
            AllowMultiple = $AllowMultiple
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
                    
                    # Calculate list area
                    $listY = $y + 4
                    $listHeight = $self.Height - 7
                    $listWidth = $self.Width - 4
                    
                    # Draw scrollable list
                    $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
                    $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
                    
                    for ($i = $startIndex; $i -le $endIndex; $i++) {
                        $itemY = $listY + ($i - $startIndex)
                        $item = $self.Items[$i]
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $isChecked = $self.SelectedItems -contains $i
                        
                        # Selection indicator
                        $prefix = ""
                        if ($self.AllowMultiple) {
                            $prefix = if ($isChecked) { "[X] " } else { "[ ] " }
                        }
                        
                        $itemText = "$prefix$item"
                        if ($itemText.Length -gt $listWidth - 2) {
                            $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
                        }
                        
                        $bgColor = if ($isSelected) { Get-ThemeColor "Selection" } else { $null }
                        $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        
                        Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText `
                            -ForegroundColor $fgColor -BackgroundColor $bgColor
                    }
                    
                    # Draw scrollbar if needed
                    if ($self.Items.Count -gt $listHeight) {
                        $scrollbarX = $x + $self.Width - 2
                        $scrollbarHeight = $listHeight
                        $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                        $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                        
                        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                            Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char `
                                -ForegroundColor (Get-ThemeColor "Border")
                        }
                    }
                    
                    # Draw buttons
                    $buttonY = $y + $self.Height - 2
                    if ($self.AllowMultiple) {
                        $okText = "[ OK ]"
                        $cancelText = "[ Cancel ]"
                        $buttonSpacing = 15
                        $totalWidth = 30
                        $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                        
                        Write-BufferString -X $startX -Y $buttonY -Text $okText `
                            -ForegroundColor (Get-ThemeColor "Success")
                        Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText `
                            -ForegroundColor (Get-ThemeColor "Primary")
                    }
                } -Context @{ DialogTitle = $self.Title; Prompt = $self.Prompt; SelectedIndex = $self.SelectedIndex } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "List Dialog Render error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) {
                            $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::DownArrow) {
                            $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Spacebar) {
                            if ($self.AllowMultiple) {
                                if ($self.SelectedItems -contains $self.SelectedIndex) {
                                    $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex }
                                } else {
                                    $self.SelectedItems += $self.SelectedIndex
                                }
                                Request-TuiRefresh
                                return $true
                            }
                        }
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            if ($self.AllowMultiple) {
                                $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $selectedValues
                                } -Context @{ DialogTitle = $self.Title; SelectedValues = $selectedValues } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "List Dialog OnSelect error: $($Exception.Message)" -Data $Exception.Context
                                }
                            } else {
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $self.Items[$self.SelectedIndex]
                                } -Context @{ DialogTitle = $self.Title; SelectedValue = $self.Items[$self.SelectedIndex] } -ErrorHandler {
                                    param($Exception)
                                    Write-Log -Level Error -Message "List Dialog OnSelect error: $($Exception.Message)" -Data $Exception.Context
                                }
                            }
                            return $true
                        }
                        ([ConsoleKey]::Escape) {
                            Close-TuiDialog
                            Invoke-WithErrorHandling -Component "ListDialog.OnCancel" -ScriptBlock {
                                & $OnCancel
                            } -Context @{ DialogTitle = $self.Title } -ErrorHandler {
                                param($Exception)
                                Write-Log -Level Error -Message "List Dialog OnCancel error: $($Exception.Message)" -Data $Exception.Context
                            }
                            return $true
                        }
                    }
                    
                    return $false
                } -Context @{ DialogTitle = $self.Title; Key = $Key; SelectedIndex = $self.SelectedIndex } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "List Dialog HandleInput error for '$($Exception.Context.DialogTitle)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
    } -Context @{ Title = $Title; Prompt = $Prompt; ItemsCount = $Items.Count } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to show list dialog '$($Exception.Context.Title)': $($Exception.Message)" -Data $Exception.Context
    }
}

#endregion

# Export all public functions
Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-TuiDialog',
    'Close-TuiDialog',
    'Show-ConfirmDialog',
    'Show-AlertDialog',
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Render-Dialogs',
    'Handle-DialogInput',
    'Update-DialogSystem',
    'New-TuiDialog'
)


####\modules\event-system.psm1
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = @()
$script:MaxEventHistory = 100

function global:Initialize-EventSystem {
    <#
    .SYNOPSIS
    Initializes the event system for the application
    #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = @()
        Write-Verbose "Event system initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Event System: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Publish-Event {
    <#
    .SYNOPSIS
    Publishes an event to all registered handlers
    
    .PARAMETER EventName
    The name of the event to publish
    
    .PARAMETER Data
    Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -ScriptBlock {
        # Record event in history
        $eventRecord = @{
            EventName = $EventName
            Data = $Data
            Timestamp = Get-Date
        }
        
        $script:EventHistory += $eventRecord
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) {
            $script:EventHistory = $script:EventHistory[-$script:MaxEventHistory..-1]
        }
        
        # Execute handlers
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try { # Internal try/catch for handler execution
                    $eventData = @{
                        EventName = $EventName
                        Data = $Data
                        Timestamp = $eventRecord.Timestamp
                    }
                    
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (Handler ID: $($handler.HandlerId)): $_" -Data @{ EventName = $EventName; HandlerId = $handler.HandlerId; Exception = $_ }
                }
            }
        }
        
        Write-Verbose "Published event: $EventName"
    } -Context @{ EventName = $EventName; EventData = $Data } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to publish event '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Subscribe-Event {
    <#
    .SYNOPSIS
    Subscribes to an event with a handler
    
    .PARAMETER EventName
    The name of the event to subscribe to
    
    .PARAMETER Handler
    The script block to execute when the event is published
    
    .PARAMETER HandlerId
    Optional unique identifier for the handler
    
    .PARAMETER Source
    Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Handler,
        
        [Parameter()]
        [string]$HandlerId = [Guid]::NewGuid().ToString(),
        
        [Parameter()]
        [string]$Source = $null
    )
    Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers[$EventName] = @()
        }
        
        $handlerInfo = @{
            HandlerId = $HandlerId
            ScriptBlock = $Handler
            SubscribedAt = Get-Date
            Source = $Source
        }
        
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        
        # Only return handler ID, don't print it
        return $HandlerId
    } -Context @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to subscribe to event '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
        return $null # Return null on error
    }
}

function global:Unsubscribe-Event {
    <#
    .SYNOPSIS
    Unsubscribes from an event
    
    .PARAMETER EventName
    The name of the event to unsubscribe from (optional if HandlerId is provided)
    
    .PARAMETER HandlerId
    The unique identifier of the handler to remove
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -ScriptBlock {
        if ($EventName) {
            # Fast path when event name is known
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($script:EventHandlers[$EventName].Count -eq 0) {
                    $script:EventHandlers.Remove($EventName)
                }
                
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            # Search all events for the handler ID
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    if ($newHandlers.Count -eq 0) {
                        $script:EventHandlers.Remove($eventKey)
                    } else {
                        $script:EventHandlers[$eventKey] = $newHandlers
                    }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"
                    break
                }
            }
            
            if (-not $found) {
                Write-Warning "Handler ID not found: $HandlerId"
            }
        }
    } -Context @{ EventName = $EventName; HandlerId = $HandlerId } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to unsubscribe from event '$($Exception.Context.EventName)' with ID '$($Exception.Context.HandlerId)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-EventHandlers {
    <#
    .SYNOPSIS
    Gets all registered event handlers
    
    .PARAMETER EventName
    Optional event name to filter by
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                return $script:EventHandlers[$EventName]
            } else {
                return @()
            }
        } else {
            return $script:EventHandlers
        }
    } -Context @{ EventName = $EventName } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get event handlers for '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
        return @{} # Return empty on error
    }
}

function global:Clear-EventHandlers {
    <#
    .SYNOPSIS
    Clears all event handlers for a specific event or all events
    
    .PARAMETER EventName
    Optional event name to clear handlers for
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers.Remove($EventName)
                Write-Verbose "Cleared handlers for event: $EventName"
            }
        } else {
            $script:EventHandlers = @{}
            Write-Verbose "Cleared all event handlers"
        }
    } -Context @{ EventName = $EventName } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to clear event handlers for '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-EventHistory {
    <#
    .SYNOPSIS
    Gets the event history
    
    .PARAMETER EventName
    Optional event name to filter by
    
    .PARAMETER Last
    Number of recent events to return
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter()]
        [int]$Last = 0
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -ScriptBlock {
        $history = $script:EventHistory
        
        if ($EventName) {
            $history = $history | Where-Object { $_.EventName -eq $EventName }
        }
        
        if ($Last -gt 0) {
            $history = $history | Select-Object -Last $Last
        }
        
        return $history
    } -Context @{ EventName = $EventName; LastCount = $Last } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get event history for '$($Exception.Context.EventName)': $($Exception.Message)" -Data $Exception.Context
        return @() # Return empty array on error
    }
}

function global:Remove-ComponentEventHandlers {
    <#
    .SYNOPSIS
    Removes all event handlers associated with a specific component
    
    .PARAMETER ComponentId
    The ID of the component whose handlers should be removed
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ComponentId
    )
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -ScriptBlock {
        $removedCount = 0
        
        # Iterate through all events and remove handlers with matching component ID
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $handlers = $script:EventHandlers[$eventName]
            $newHandlers = @()
            
            foreach ($handler in $handlers) {
                # Check if handler has Source property matching ComponentId
                if ($handler.Source -ne $ComponentId) {
                    $newHandlers += $handler
                } else {
                    $removedCount++
                }
            }
            
            if ($newHandlers.Count -eq 0) {
                $script:EventHandlers.Remove($eventName)
            } else {
                $script:EventHandlers[$eventName] = $newHandlers
            }
        }
        
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    } -Context @{ ComponentId = $ComponentId } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to remove event handlers for component '$($Exception.Context.ComponentId)': $($Exception.Message)" -Data $Exception.Context
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-EventSystem',
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Get-EventHandlers',
    'Clear-EventHandlers',
    'Get-EventHistory',
    'Remove-ComponentEventHandlers'
)


####\modules\exceptions.psm1
#
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
# for the PMC Terminal application. This ensures all errors are consistently logged
# with rich contextual information.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# A running history of the most recent errors encountered in the application.
$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100 # Keep a reasonable number of recent errors.

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

# Define custom exception types using C# via Add-Type. This provides strongly-typed
# exceptions that can be caught specifically throughout the application.
try {
    # Only add the type if it doesn't already exist to prevent errors on module re-import.
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            // Base exception for all custom application errors. Inherits from RuntimeException for better PowerShell integration.
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException)
                {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            // Specific exception types for better categorization and targeted catch blocks.
            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
        # This log message will only appear if the logger is already imported and the log level is appropriate.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Custom Helios exception types compiled successfully."
        }
    }
} catch {
    # If Add-Type fails, this is a critical environment issue. Log it prominently.
    # The application will fall back to using standard RuntimeExceptions.
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}


# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Identifies the component/module where an error originated based on the call stack.
function _Identify-HeliosComponent {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName
        if (-not $scriptName) {
            # Walk the call stack to find the first script file.
            $callStack = Get-PSCallStack
            foreach ($frame in $callStack) {
                if ($frame.ScriptName) {
                    $scriptName = $frame.ScriptName
                    break
                }
            }
        }

        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        # Map filenames to logical application components according to the new file structure.
        $componentMap = @{
            'tui-engine'        = 'TUI Engine'
            'navigation'        = 'Navigation Service'
            'keybindings'       = 'Keybinding Service'
            'task-service'      = 'Task Service'
            'helios-components' = 'Helios UI Components'
            'helios-panels'     = 'Helios UI Panels'
            'dashboard-screen'  = 'Dashboard Screen'
            'task-screen'       = 'Task Screen'
            'exceptions'        = 'Exception Module'
            'logger'            = 'Logger Module'
            'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") {
                return $componentMap[$pattern]
            }
        }

        return "Unknown ($fileName)"

    } catch {
        return "Component Identification Failed"
    }
}

# Gathers extensive details about an error for logging and debugging.
function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp         = Get-Date -Format "o"
            Summary           = $ErrorRecord.Exception.Message
            Type              = $ErrorRecord.Exception.GetType().FullName
            Category          = $ErrorRecord.CategoryInfo.Category.ToString()
            TargetObject      = $ErrorRecord.TargetObject
            ScriptName        = $ErrorRecord.InvocationInfo.ScriptName
            LineNumber        = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line              = $ErrorRecord.InvocationInfo.Line
            PositionMessage   = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace        = $ErrorRecord.Exception.StackTrace
            InnerExceptions   = @()
            AdditionalContext = $AdditionalContext
            SystemContext     = @{
                ProcessId         = $PID
                ThreadId          = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                OS                = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{
                Message    = $innerEx.Message
                Type       = $innerEx.GetType().FullName
                StackTrace = $innerEx.StackTrace
            }
            $innerEx = $innerEx.InnerException
        }

        return $errorInfo

    } catch {
        # Fallback if the error analysis itself fails.
        return [PSCustomObject]@{
            Timestamp     = Get-Date -Format "o"
            Summary       = "CRITICAL: Error analysis failed."
            OriginalError = $ErrorRecord.Exception.Message
            AnalysisError = $_.Exception.Message
            Type          = "ErrorAnalysisFailure"
        }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        [Parameter(Mandatory)]
        [string]$Component,
        [Parameter(Mandatory)]
        [string]$Context, # A simple string describing the operation, e.g., "Loading tasks from disk".
        [hashtable]$AdditionalData = @{}
    )

    # Defensive checks
    if ($null -eq $ScriptBlock) {
        # This is a programming error, so we throw directly.
        throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null."
    }
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown Component"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown Operation"
    }

    try {
        # Execute the provided scriptblock.
        return (& $ScriptBlock)
    }
    catch {
        # This block catches any terminating error from the ScriptBlock.
        $originalErrorRecord = $_

        # 1. Identify the component where the error occurred.
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = if ($Component -ne "Unknown Component") { $Component } else { $identifiedComponent }

        # 2. Gather all possible details about the error.
        $errorContext = @{
            Operation = $Context
        }
        # Merge additional data provided by the caller.
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        # 3. Log the error using the logger module.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        # 4. Add the detailed error to the in-memory history for debugging.
        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) {
            $script:ErrorHistory.RemoveAt(0)
        }

        # 5. Create a new, rich, strongly-typed exception and throw it.
        # This allows upstream code to catch '[Helios.HeliosException]' specifically.
        $heliosException = New-Object Helios.HeliosException(
            $originalErrorRecord.Exception.Message,
            $finalComponent,
            $detailedError,
            $originalErrorRecord.Exception
        )
        
        # Re-throw the rich exception to allow for top-level handling.
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param(
        [int]$Count = 25
    )
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) {
        return $script:ErrorHistory
    }

    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}


Export-ModuleMember -Function @(
    'Invoke-WithErrorHandling',
    'Get-ErrorHistory'
)

# NOTE: Custom types defined with Add-Type are automatically available to the session
# after the module is imported. They do not need to be explicitly exported.



####\modules\logger.psm1
#
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# NOTE: The use of '$script:' scope is intentional and correct for managing state
# internal to this module. It does not violate the project's scope purity rules,
# which are designed to prevent state sharing *between* modules.

$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new() # Use a generic list for better performance over @()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Internal helper to safely serialize objects for logging, preventing circular references or errors.
function ConvertTo-SerializableObject {
    param([object]$Object)

    if ($null -eq $Object) { return $null }

    # Use a set to track visited objects to prevent infinite recursion
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'

    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)

        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        
        # For non-collection reference types, add to visited set
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) {
            [void]$visited.Add($InputObject)
        }

        switch ($InputObject.GetType().Name) {
            'Hashtable' {
                $result = @{}
                foreach ($key in $InputObject.Keys) {
                    try {
                        $result[$key] = Convert-Internal -InputObject $InputObject[$key] -Depth ($Depth + 1)
                    } catch {
                        $result[$key] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'PSCustomObject' {
                $result = @{}
                foreach ($prop in $InputObject.PSObject.Properties) {
                    try {
                        # Avoid serializing script methods
                        if ($prop.MemberType -ne 'ScriptMethod') {
                           $result[$prop.Name] = Convert-Internal -InputObject $prop.Value -Depth ($Depth + 1)
                        }
                    } catch {
                        $result[$prop.Name] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'Object[]' {
                $result = @()
                # Limit array size for performance
                for ($i = 0; $i -lt [Math]::Min($InputObject.Count, 10); $i++) {
                    try {
                        $result += Convert-Internal -InputObject $InputObject[$i] -Depth ($Depth + 1)
                    } catch {
                        $result += "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                if ($InputObject.Count -gt 10) {
                    $result += "<... $($InputObject.Count - 10) more items>"
                }
                return $result
            }
            default {
                try {
                    # For simple types, return as-is or convert to string
                    if ($InputObject -is [string] -or $InputObject -is [int] -or $InputObject -is [bool] -or $InputObject -is [double] -or $InputObject -is [datetime] -or $InputObject -is [decimal]) {
                        return $InputObject
                    } else {
                        return $InputObject.ToString()
                    }
                } catch {
                    return "<ToString failed: $($_.Exception.Message)>"
                }
            }
        }
    }

    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level = "Debug"
    )

    # Defensive checks
    if ([string]::IsNullOrWhiteSpace($LogDirectory)) {
        Write-Warning "Initialize-Logger: LogDirectory parameter cannot be null or empty."
        return
    }
    if ([string]::IsNullOrWhiteSpace($LogFileName)) {
        Write-Warning "Initialize-Logger: LogFileName parameter cannot be null or empty."
        return
    }

    try {
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null
        }

        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true

        Write-Log -Level Info -Message "Logger initialized" -Data @{
            LogPath           = $script:LogPath
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            OS                = $PSVersionTable.OS
            ProcessId         = $PID
            InitializedAt     = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        } -Force # Force this initial message to be written

    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data,
        [switch]$Force # Force logging even if level is below threshold
    )

    if (-not $script:LogInitialized -and -not $Force) { return }

    $levelPriority = @{
        Debug   = 0
        Trace   = 0
        Verbose = 1
        Info    = 2
        Warning = 3
        Error   = 4
    }

    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }

    try {
        $callStack = Get-PSCallStack
        $caller = if ($callStack.Count -gt 1) { $callStack[1] } else { $callStack[0] }

        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId

        $logContext = @{
            Timestamp     = $timestamp
            Level         = $Level
            ThreadId      = $threadId
            CallDepth     = $script:CallDepth
            Message       = $Message
            Caller        = @{
                Command      = $caller.Command
                Location     = $caller.Location
                ScriptName   = $caller.ScriptName
                LineNumber   = $caller.ScriptLineNumber
            }
        }

        if ($PSBoundParameters.ContainsKey('Data')) {
            $logContext.UserData = if ($Data -is [Exception]) {
                @{
                    Type           = "Exception"
                    Message        = $Data.Message
                    StackTrace     = $Data.StackTrace
                    InnerException = if ($Data.InnerException) { $Data.InnerException.Message } else { $null }
                }
            } else {
                ConvertTo-SerializableObject -Object $Data
            }
        }

        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) {
            "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)"
        } else {
            $caller.Command
        }

        $logEntry = "$timestamp [$($Level.PadRight(7))] $indent [$callerInfo] $Message"

        if ($PSBoundParameters.ContainsKey('Data')) {
            $dataStr = if ($Data -is [Exception]) {
                "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)"
            } else {
                try {
                    $json = ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue
                    "`n${indent}  Data: $json"
                } catch {
                    "`n${indent}  Data: $($Data.ToString())"
                }
            }
            $logEntry += $dataStr
        }

        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) {
            $script:LogQueue.RemoveRange(0, $script:LogQueue.Count - 2000)
        }

        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                    $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                    Move-Item $script:LogPath $archivePath -Force
                }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch {
                Write-Host "LOG WRITE FAILED: $logEntry" -ForegroundColor Yellow
                Write-Host "Error: $_" -ForegroundColor Red
            }
        }

        if ($Level -in @('Error', 'Warning')) {
            $color = if ($Level -eq 'Error') { 'Red' } else { 'Yellow' }
            Write-Host $logEntry -ForegroundColor $color
        }

    } catch {
        try {
            $errorEntry = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff') [LOGGER ERROR] Failed to log message '$Message': $_"
            if ($script:LogPath) {
                Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8
            }
            Write-Host $errorEntry -ForegroundColor Red
        } catch {
            Write-Host "CRITICAL: Logger completely failed: $_" -ForegroundColor Red
        }
    }
}

function Trace-FunctionEntry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$Parameters
    )
    if (-not $script:TraceAllCalls) { return }
    $script:CallDepth++
    Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{
        Parameters = $Parameters
        Action     = "FunctionEntry"
    }
}

function Trace-FunctionExit {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$ReturnValue,
        [switch]$WithError
    )
    if (-not $script:TraceAllCalls) { return }
    Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{
        ReturnValue = $ReturnValue
        Action      = if ($WithError) { "FunctionExitWithError" } else { "FunctionExit" }
        HasError    = $WithError.IsPresent
    }
    $script:CallDepth--
    if ($script:CallDepth -lt 0) { $script:CallDepth = 0 }
}

function Trace-Step {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StepName,
        [object]$StepData,
        [string]$Module
    )
    $caller = (Get-PSCallStack)[1]
    $moduleInfo = if ($Module) { $Module } elseif ($caller.ScriptName) { [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) } else { "Unknown" }

    Write-Log -Level Debug -Message "STEP: $StepName" -Data @{
        StepData = $StepData
        Module   = $moduleInfo
        Action   = "Step"
    }
}

function Trace-StateChange {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StateType,
        [object]$OldValue,
        [object]$NewValue,
        [string]$PropertyPath
    )
    Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{
        StateType    = $StateType
        PropertyPath = $PropertyPath
        OldValue     = $OldValue
        NewValue     = $NewValue
        Action       = "StateChange"
    }
}

function Trace-ComponentLifecycle {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ComponentType,
        [Parameter(Mandatory)]
        [string]$ComponentId,
        [Parameter(Mandatory)]
        [ValidateSet('Create', 'Initialize', 'Render', 'Update', 'Destroy')]
        [string]$Phase,
        [object]$ComponentData
    )
    Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{
        ComponentType = $ComponentType
        ComponentId   = $ComponentId
        Phase         = $Phase
        ComponentData = $ComponentData
        Action        = "ComponentLifecycle"
    }
}

function Trace-ServiceCall {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ServiceName,
        [Parameter(Mandatory)]
        [string]$MethodName,
        [object]$Parameters,
        [object]$Result,
        [switch]$IsError
    )
    $action = if ($IsError) { "ServiceCallError" } else { "ServiceCall" }
    Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{
        ServiceName = $ServiceName
        MethodName  = $MethodName
        Parameters  = $Parameters
        Result      = $Result
        Action      = $action
        IsError     = $IsError.IsPresent
    }
}

function Get-LogEntries {
    [CmdletBinding()]
    param(
        [int]$Count = 100,
        [string]$Level,
        [string]$Module,
        [string]$Action
    )
    try {
        $entries = $script:LogQueue.ToArray() # Work on a copy

        if ($Level) {
            $entries = $entries | Where-Object { $_.Level -eq $Level }
        }
        if ($Module) {
            $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") }
        }
        if ($Action) {
            $entries = $entries | Where-Object { $_.UserData.Action -eq $Action }
        }

        return $entries | Select-Object -Last $Count
    } catch {
        Write-Warning "Error getting log entries: $_"
        return @()
    }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)

    try {
        $callStack = Get-PSCallStack
        $trace = @()

        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { # Skip self
            $call = $callStack[$i]
            $trace += @{
                Level      = $i - 1
                Command    = $call.Command
                Location   = $call.Location
                ScriptName = $call.ScriptName
                LineNumber = $call.ScriptLineNumber
            }
        }
        return $trace
    } catch {
        Write-Warning "Error getting call trace: $_"
        return @()
    }
}

function Clear-LogQueue {
    [CmdletBinding()]
    try {
        $script:LogQueue.Clear()
        Write-Log -Level Info -Message "In-memory log queue cleared"
    } catch {
        Write-Warning "Error clearing log queue: $_"
    }
}

function Set-LogLevel {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Trace")]
        [string]$Level
    )
    try {
        $oldLevel = $script:LogLevel
        $script:LogLevel = $Level
        Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force
    } catch {
        Write-Warning "Error setting log level to '$Level': $_"
    }
}

function Enable-CallTracing {
    [CmdletBinding()]
    $script:TraceAllCalls = $true
    Write-Log -Level Info -Message "Call tracing enabled" -Force
}

function Disable-CallTracing {
    [CmdletBinding()]
    $script:TraceAllCalls = $false
    Write-Log -Level Info -Message "Call tracing disabled" -Force
}

function Get-LogPath {
    [CmdletBinding()]
    return $script:LogPath
}

function Get-LogStatistics {
    [CmdletBinding()]
    # AI: Removed incorrect parameter block that was copied from Get-LogEntries.
    # This function takes no parameters.
    try {
        $stats = [PSCustomObject]@{
            TotalEntries       = $script:LogQueue.Count
            LogPath            = $script:LogPath
            LogLevel           = $script:LogLevel
            CallTracingEnabled = $script:TraceAllCalls
            LogFileSize        = if ($script:LogPath -and (Test-Path $script:LogPath)) { (Get-Item $script:LogPath).Length } else { 0 }
            EntriesByLevel     = @{}
            EntriesByModule    = @{}
            EntriesByAction    = @{}
        }

        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level
            if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level] = 0 }
            $stats.EntriesByLevel[$level]++

            if ($entry.Caller.ScriptName) {
                $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName)
                if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module] = 0 }
                $stats.EntriesByModule[$module]++
            }

            if ($entry.UserData -and $entry.UserData.Action) {
                $action = $entry.UserData.Action
                if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action] = 0 }
                $stats.EntriesByAction[$action]++
            }
        }

        return $stats
    } catch {
        Write-Warning "Error getting log statistics: $_"
        return [PSCustomObject]@{}
    }
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Trace-FunctionEntry',
    'Trace-FunctionExit',
    'Trace-Step',
    'Trace-StateChange',
    'Trace-ComponentLifecycle',
    'Trace-ServiceCall',
    'Get-LogEntries',
    'Get-CallTrace',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Enable-CallTracing',
    'Disable-CallTracing',
    'Get-LogPath',
    'Get-LogStatistics'
)



####\modules\models.psm1
#Requires -Version 5.1
<#
.SYNOPSIS
    Data model definitions for the PMC application
    
.DESCRIPTION
    This module defines all core data classes and enums used throughout the application.
    It is self-contained with no dependencies on other modules.
    
.NOTES
    AI: This module replaces the previous implicit data structures with strongly-typed classes
#>

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Enums

# AI: Using Add-Type to define enums for PowerShell 5.1 compatibility
Add-Type -TypeDefinition @"
    public enum TaskStatus {
        Pending,
        InProgress,
        Completed,
        Cancelled
    }
    
    public enum TaskPriority {
        Low,
        Medium,
        High
    }
    
    public enum BillingType {
        Billable,
        NonBillable
    }
"@ -ErrorAction SilentlyContinue

#endregion

#region Classes

class PmcTask {
    # Core properties
    [string]$Id
    [string]$Title
    [string]$Description
    [TaskStatus]$Status
    [TaskPriority]$Priority
    [string]$ProjectKey
    [string]$Category  # AI: Maintained for backward compatibility
    [datetime]$CreatedAt
    [datetime]$UpdatedAt
    
    # Optional properties
    [Nullable[datetime]]$DueDate
    [string[]]$Tags
    [int]$Progress  # AI: Progress percentage (0-100)
    
    # Legacy support
    [bool]$Completed  # AI: Computed property for backward compatibility
    
    # Default constructor
    PmcTask() {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = ""
        $this.Description = ""
        $this.Status = [TaskStatus]::Pending
        $this.Priority = [TaskPriority]::Medium
        $this.ProjectKey = "General"
        $this.Category = "General"
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.DueDate = $null
        $this.Tags = @()
        $this.Progress = 0
        $this.Completed = $false
    }
    
    # Constructor with title
    PmcTask([string]$title) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = $title
        $this.Description = ""
        $this.Status = [TaskStatus]::Pending
        $this.Priority = [TaskPriority]::Medium
        $this.ProjectKey = "General"
        $this.Category = "General"
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.DueDate = $null
        $this.Tags = @()
        $this.Progress = 0
        $this.Completed = $false
    }
    
    # Full constructor
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = $title
        $this.Description = $description
        $this.Status = [TaskStatus]::Pending
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey  # AI: Set for backward compatibility
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.DueDate = $null
        $this.Tags = @()
        $this.Progress = 0
        $this.Completed = $false
    }
    
    # Methods
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Completed = $true
        $this.Progress = 100
        $this.UpdatedAt = [datetime]::Now
    }
    
    [void] UpdateProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) {
            throw "Progress must be between 0 and 100"
        }
        
        $this.Progress = $progress
        
        # AI: Auto-update status based on progress
        if ($progress -eq 0) {
            $this.Status = [TaskStatus]::Pending
            $this.Completed = $false
        }
        elseif ($progress -gt 0 -and $progress -lt 100) {
            $this.Status = [TaskStatus]::InProgress
            $this.Completed = $false
        }
        elseif ($progress -eq 100) {
            $this.Status = [TaskStatus]::Completed
            $this.Completed = $true
        }
        
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() {
        if ($null -eq $this.DueDate) {
            return "N/A"
        }
        return $this.DueDate.ToString("yyyy-MM-dd")
    }
    
    # AI: Helper method for legacy data format conversion
    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id
            title = $this.Title
            description = $this.Description
            completed = $this.Completed
            priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey
            due_date = if ($null -ne $this.DueDate) { $this.GetDueDateString() } else { $null }
            created_at = $this.CreatedAt.ToString("o")
            updated_at = $this.UpdatedAt.ToString("o")
        }
    }
    
    # AI: Static method to create from legacy format
    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        
        if ($legacyData.id) { $task.Id = $legacyData.id }
        if ($legacyData.title) { $task.Title = $legacyData.title }
        if ($legacyData.description) { $task.Description = $legacyData.description }
        
        # Handle priority conversion
        if ($legacyData.priority) {
            switch ($legacyData.priority.ToLower()) {
                "low" { $task.Priority = [TaskPriority]::Low }
                "medium" { $task.Priority = [TaskPriority]::Medium }
                "high" { $task.Priority = [TaskPriority]::High }
                default { $task.Priority = [TaskPriority]::Medium }
            }
        }
        
        # Handle project/category
        if ($legacyData.project) { 
            $task.ProjectKey = $legacyData.project
            $task.Category = $legacyData.project
        }
        elseif ($legacyData.Category) {
            $task.ProjectKey = $legacyData.Category
            $task.Category = $legacyData.Category
        }
        
        # Handle dates
        if ($legacyData.created_at) {
            try {
                $task.CreatedAt = [datetime]::Parse($legacyData.created_at)
            }
            catch {
                $task.CreatedAt = [datetime]::Now
            }
        }
        
        if ($legacyData.updated_at) {
            try {
                $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at)
            }
            catch {
                $task.UpdatedAt = [datetime]::Now
            }
        }
        
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") {
            try {
                $task.DueDate = [datetime]::Parse($legacyData.due_date)
            }
            catch {
                $task.DueDate = $null
            }
        }
        
        # Handle completion status
        if ($legacyData.completed -eq $true) {
            $task.Status = [TaskStatus]::Completed
            $task.Completed = $true
            $task.Progress = 100
        }
        
        return $task
    }
}

class PmcProject {
    # Core properties
    [string]$Key
    [string]$Name
    [string]$Client
    [BillingType]$BillingType
    [double]$Rate
    [double]$Budget
    [bool]$Active
    [datetime]$CreatedAt
    [datetime]$UpdatedAt
    
    # Additional identifiers
    [string]$Id1  # AI: External system ID 1
    [string]$Id2  # AI: External system ID 2
    
    # Computed properties
    [double]$SpentBudget
    [double]$RemainingBudget
    
    # Default constructor
    PmcProject() {
        $this.Key = ""
        $this.Name = ""
        $this.Client = ""
        $this.BillingType = [BillingType]::NonBillable
        $this.Rate = 0.0
        $this.Budget = 0.0
        $this.Active = $true
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.Id1 = ""
        $this.Id2 = ""
        $this.SpentBudget = 0.0
        $this.RemainingBudget = 0.0
    }
    
    # Constructor with key and name
    PmcProject([string]$key, [string]$name) {
        $this.Key = $key
        $this.Name = $name
        $this.Client = ""
        $this.BillingType = [BillingType]::NonBillable
        $this.Rate = 0.0
        $this.Budget = 0.0
        $this.Active = $true
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.Id1 = ""
        $this.Id2 = ""
        $this.SpentBudget = 0.0
        $this.RemainingBudget = 0.0
    }
    
    # Full constructor
    PmcProject([string]$key, [string]$name, [string]$client, [BillingType]$billingType, [double]$rate) {
        $this.Key = $key
        $this.Name = $name
        $this.Client = $client
        $this.BillingType = $billingType
        $this.Rate = $rate
        $this.Budget = 0.0
        $this.Active = $true
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.Id1 = ""
        $this.Id2 = ""
        $this.SpentBudget = 0.0
        $this.RemainingBudget = 0.0
    }
    
    # Methods
    [void] UpdateBudgetSpent([double]$amount) {
        if ($amount -lt 0) {
            throw "Spent amount cannot be negative"
        }
        
        $this.SpentBudget = $amount
        $this.RemainingBudget = $this.Budget - $amount
        $this.UpdatedAt = [datetime]::Now
    }
    
    [void] Deactivate() {
        $this.Active = $false
        $this.UpdatedAt = [datetime]::Now
    }
    
    [void] Activate() {
        $this.Active = $true
        $this.UpdatedAt = [datetime]::Now
    }
    
    [bool] IsBillable() {
        return $this.BillingType -eq [BillingType]::Billable
    }
    
    [bool] IsOverBudget() {
        return ($this.Budget -gt 0) -and ($this.SpentBudget -gt $this.Budget)
    }
    
    # AI: Helper method for legacy data format conversion
    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key
            Name = $this.Name
            Client = $this.Client
            BillingType = $this.BillingType.ToString()
            Rate = $this.Rate
            Budget = $this.Budget
            Active = $this.Active
            CreatedAt = $this.CreatedAt.ToString("o")
            Id1 = $this.Id1
            Id2 = $this.Id2
        }
    }
    
    # AI: Static method to create from legacy format
    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        
        if ($legacyData.Key) { $project.Key = $legacyData.Key }
        if ($legacyData.Name) { $project.Name = $legacyData.Name }
        if ($legacyData.Client) { $project.Client = $legacyData.Client }
        
        # Handle billing type conversion
        if ($legacyData.BillingType) {
            switch ($legacyData.BillingType) {
                "Billable" { $project.BillingType = [BillingType]::Billable }
                "NonBillable" { $project.BillingType = [BillingType]::NonBillable }
                default { $project.BillingType = [BillingType]::NonBillable }
            }
        }
        
        if ($null -ne $legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($null -ne $legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($null -ne $legacyData.Active) { $project.Active = [bool]$legacyData.Active }
        
        if ($legacyData.CreatedAt) {
            try {
                $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt)
            }
            catch {
                $project.CreatedAt = [datetime]::Now
            }
        }
        
        if ($legacyData.Id1) { $project.Id1 = $legacyData.Id1 }
        if ($legacyData.Id2) { $project.Id2 = $legacyData.Id2 }
        
        # Set UpdatedAt to CreatedAt if not migrating
        $project.UpdatedAt = $project.CreatedAt
        
        return $project
    }
}

#endregion

# Export all public types
Export-ModuleMember -Function * -Variable *


####\modules\state-manager.psm1
# State Manager Module
# Simple, practical reactive state management for PowerShell TUI

function global:New-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state object for managing application or screen state
    
    .DESCRIPTION
    This creates a PowerShell object that tracks state changes and notifies
    subscribers when values change. It's designed to be simple and practical.
    
    .PARAMETER InitialState
    Hashtable of initial state values
    
    .PARAMETER Actions
    Hashtable of named actions (methods) that can mutate the state
    
    .EXAMPLE
    $state = New-TuiState -InitialState @{ count = 0; name = "Test" } -Actions @{
        Increment = { $this.count++ }
        SetName = { param($name) $this.name = $name }
    }
    $state.Subscribe('count', { param($new, $old) Write-Host "Count changed from $old to $new" })
    $state.Increment()
    #>
    param(
        [hashtable]$InitialState = @{},
        [hashtable]$Actions = @{}
    )
    
    # Create the state object
    $stateObject = [PSCustomObject]@{
        # Private properties
        _data = $InitialState.Clone()
        _subscribers = @{}
        _suspendNotifications = $false
    }
    
    # Add dynamic properties for each state key
    foreach ($key in $InitialState.Keys) {
        $stateObject | Add-Member -MemberType ScriptProperty -Name $key -Value {
            # Getter
            $this._data[$key]
        }.GetNewClosure() -SecondValue {
            # Setter
            param($value)
            $this.SetValue($key, $value)
        }.GetNewClosure()
    }
    
    # Core methods
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'SetValue' -Value {
        param([string]$key, $value)
        
        $oldValue = $this._data[$key]
        
        # Skip if value hasn't changed
        if ($oldValue -eq $value) { return }
        
        # Update the value
        $this._data[$key] = $value
        
        # Notify subscribers unless suspended
        if (-not $this._suspendNotifications) {
            $this._NotifySubscribers($key, $value, $oldValue)
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetValue' -Value {
        param([string]$key)
        return $this._data[$key]
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Subscribe' -Value {
        param(
            [string]$key,
            [scriptblock]$handler
        )
        
        if (-not $this._subscribers.ContainsKey($key)) {
            $this._subscribers[$key] = @()
        }
        
        # Generate unique ID for this subscription
        $subscriptionId = [Guid]::NewGuid().ToString()
        
        $this._subscribers[$key] += @{
            Id = $subscriptionId
            Handler = $handler
        }
        
        # Call handler immediately with current value
        try {
            & $handler $this._data[$key] $null
        } catch {
            Write-Warning "State subscription handler error: $_"
        }
        
        # Return subscription ID for unsubscribing
        return $subscriptionId
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Unsubscribe' -Value {
        param([string]$subscriptionId)
        
        foreach ($key in $this._subscribers.Keys) {
            $this._subscribers[$key] = @($this._subscribers[$key] | Where-Object { $_.Id -ne $subscriptionId })
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Update' -Value {
        param([hashtable]$updates)
        
        # Suspend notifications during bulk update
        $this._suspendNotifications = $true
        
        try {
            foreach ($key in $updates.Keys) {
                $this.SetValue($key, $updates[$key])
            }
        } finally {
            $this._suspendNotifications = $false
        }
        
        # Notify all affected keys
        foreach ($key in $updates.Keys) {
            if ($this._data[$key] -ne $this._data[$key]) { # Check if changed
                $this._NotifySubscribers($key, $this._data[$key], $null)
            }
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetState' -Value {
        # Return a copy of the current state
        return $this._data.Clone()
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name '_NotifySubscribers' -Value {
        param($key, $newValue, $oldValue)
        
        # Notify specific key subscribers
        if ($this._subscribers.ContainsKey($key)) {
            foreach ($subscription in $this._subscribers[$key]) {
                try {
                    & $subscription.Handler $newValue $oldValue
                } catch {
                    Write-Warning "State notification error for key '$key': $_"
                }
            }
        }
        
        # Notify wildcard subscribers
        if ($this._subscribers.ContainsKey('*')) {
            foreach ($subscription in $this._subscribers['*']) {
                try {
                    & $subscription.Handler @{
                        Key = $key
                        NewValue = $newValue
                        OldValue = $oldValue
                    }
                } catch {
                    Write-Warning "Wildcard state notification error: $_"
                }
            }
        }
    }
    
    # Add user-defined actions as methods
    foreach ($actionName in $Actions.Keys) {
        $stateObject | Add-Member -MemberType ScriptMethod -Name $actionName -Value $Actions[$actionName]
    }
    
    return $stateObject
}

function global:New-ComputedState {
    <#
    .SYNOPSIS
    Creates a computed/derived state value that updates automatically
    
    .PARAMETER Source
    The source state object to derive from
    
    .PARAMETER Keys
    Array of state keys to watch for changes
    
    .PARAMETER Compute
    Scriptblock that computes the derived value
    
    .EXAMPLE
    $filtered = New-ComputedState -Source $state -Keys @('tasks', 'filter') -Compute {
        param($state)
        $state.tasks | Where-Object { $_.Status -eq $state.filter }
    }
    #>
    param(
        [PSCustomObject]$Source,
        [string[]]$Keys,
        [scriptblock]$Compute
    )
    
    $computed = [PSCustomObject]@{
        _source = $Source
        _value = $null
        _compute = $Compute
        _subscriptions = @()
    }
    
    # Add Value property
    $computed | Add-Member -MemberType ScriptProperty -Name 'Value' -Value {
        $this._value
    }
    
    # Recompute method
    $computed | Add-Member -MemberType ScriptMethod -Name '_Recompute' -Value {
        try {
            $this._value = & $this._compute $this._source
        } catch {
            Write-Warning "Computed state error: $_"
        }
    }
    
    # Initial computation
    $computed._Recompute()
    
    # Subscribe to changes
    foreach ($key in $Keys) {
        $subId = $Source.Subscribe($key, {
            $computed._Recompute()
        })
        $computed._subscriptions += $subId
    }
    
    # Cleanup method
    $computed | Add-Member -MemberType ScriptMethod -Name 'Dispose' -Value {
        foreach ($subId in $this._subscriptions) {
            $this._source.Unsubscribe($subId)
        }
    }
    
    return $computed
}

# Export functions
Export-ModuleMember -Function @('New-TuiState', 'New-ComputedState')



####\modules\text-resources.psm1
# Text Resources Module
# Simple text management without external dependencies

$script:TextResources = @{
    # Common UI strings
    Common = @{
        OK = "OK"
        Cancel = "Cancel"
        Save = "Save"
        Delete = "Delete"
        Edit = "Edit"
        Add = "Add"
        Remove = "Remove"
        Back = "Back"
        Next = "Next"
        Previous = "Previous"
        Close = "Close"
        Error = "Error"
        Warning = "Warning"
        Info = "Information"
        Success = "Success"
        Loading = "Loading..."
        PleaseWait = "Please wait..."
    }
    
    # Dashboard specific
    Dashboard = @{
        Title = "PMC Terminal Dashboard"
        QuickActions = "Quick Actions"
        ActiveTimers = "Active Timers"
        TodaysTasks = "Today's Tasks"
        Stats = "Statistics"
        NoTimersActive = "No active timers"
        NoTasksToday = "No tasks for today"
    }
    
    # Task screen specific
    Tasks = @{
        Title = "Task Management"
        AddTask = "Add Task"
        EditTask = "Edit Task"
        DeleteConfirm = "Are you sure you want to delete this task?"
        FilterAll = "All"
        FilterActive = "Active"
        FilterCompleted = "Completed"
        SortByPriority = "Priority"
        SortByDueDate = "Due Date"
        SortByCreated = "Created"
    }
    
    # Form labels
    Forms = @{
        Title = "Title"
        Description = "Description"
        Category = "Category"
        Priority = "Priority"
        DueDate = "Due Date"
        Status = "Status"
        Project = "Project"
        Hours = "Hours"
        Date = "Date"
    }
    
    # Validation messages
    Validation = @{
        Required = "{0} is required"
        MinLength = "{0} must be at least {1} characters"
        MaxLength = "{0} cannot exceed {1} characters"
        InvalidDate = "Invalid date format"
        InvalidNumber = "Must be a valid number"
    }
    
    # Status messages
    Status = @{
        Saved = "Changes saved successfully"
        Deleted = "Item deleted successfully"
        Updated = "Item updated successfully"
        Created = "Item created successfully"
        Error = "An error occurred: {0}"
    }
}

function global:Get-Text {
    <#
    .SYNOPSIS
    Retrieves a text resource by key path
    
    .PARAMETER Key
    Dot-separated path to the text resource (e.g., "Common.OK")
    
    .PARAMETER Format
    Optional format arguments for string interpolation
    
    .EXAMPLE
    Get-Text "Common.OK"
    Get-Text "Validation.Required" -Format "Username"
    Get-Text "Status.Error" -Format $_.Exception.Message
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(ValueFromRemainingArguments=$true)]
        [object[]]$Format
    )
    Invoke-WithErrorHandling -Component "TextResources.GetText" -ScriptBlock {
        # Navigate the nested hashtable
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                Write-Warning "Text resource not found: '$Key'"
                return $Key  # Return the key as fallback
            }
        }
        
        # Format the string if arguments provided
        if ($Format -and $Format.Count -gt 0) {
            try {
                return $current -f $Format
            } catch {
                Write-Warning "Failed to format text resource '$Key': $_"
                return $current
            }
        }
        
        return $current
    } -Context @{ Key = $Key; FormatArgs = $Format } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to retrieve text resource for key '$($Exception.Context.Key)': $($Exception.Message)" -Data $Exception.Context
        return $Key # Return key as fallback on error
    }
}

function global:Set-TextResource {
    <#
    .SYNOPSIS
    Sets or updates a text resource
    
    .PARAMETER Key
    Dot-separated path to the text resource
    
    .PARAMETER Value
    The text value to set
    
    .EXAMPLE
    Set-TextResource "Custom.WelcomeMessage" "Welcome to my app!"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(Mandatory=$true)]
        [string]$Value
    )
    Invoke-WithErrorHandling -Component "TextResources.SetTextResource" -ScriptBlock {
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        # Navigate to the parent
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            }
            $current = $current[$part]
        }
        
        # Set the value
        $current[$parts[-1]] = $Value
    } -Context @{ Key = $Key; Value = $Value } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to set text resource for key '$($Exception.Context.Key)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-TextResources {
    <#
    .SYNOPSIS
    Gets all text resources (useful for export/import)
    #>
    Invoke-WithErrorHandling -Component "TextResources.GetTextResources" -ScriptBlock {
        return $script:TextResources.Clone()
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get all text resources: $($Exception.Message)" -Data $Exception.Context
        return @{} # Return empty hashtable on error
    }
}

function global:Import-TextResources {
    <#
    .SYNOPSIS
    Imports text resources from a file
    
    .PARAMETER Path
    Path to JSON file containing text resources
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ImportTextResources" -ScriptBlock {
        if (Test-Path $Path) {
            try {
                $imported = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
                $script:TextResources = $imported
                Write-Host "Text resources imported successfully"
            } catch {
                Write-Log -Level Error -Message "Failed to import text resources from '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
            }
        } else {
            Write-Log -Level Error -Message "File not found: $Path" -Data @{ FilePath = $Path }
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to import text resources from '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Export-TextResources {
    <#
    .SYNOPSIS
    Exports text resources to a file
    
    .PARAMETER Path
    Path to save the JSON file
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ExportTextResources" -ScriptBlock {
        try {
            $script:TextResources | ConvertTo-Json -Depth 10 | Set-Content $Path
            Write-Host "Text resources exported successfully"
        } catch {
            Write-Log -Level Error -Message "Failed to export text resources to '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to export text resources to '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Get-Text',
    'Set-TextResource',
    'Get-TextResources',
    'Import-TextResources',
    'Export-TextResources'
)


####\modules\theme-manager.psm1
#
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
# AI: This module has been refactored to wrap all public functions in Invoke-WithErrorHandling
#     for consistent, robust error logging and handling, adhering to the project's core principles.
#

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::White
            Primary = [ConsoleColor]::White; Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue; Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan; Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::Blue; String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta; Comment = [ConsoleColor]::DarkGray
        }
    }
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray; Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan; Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow; Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue; Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan; Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue; String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta; Comment = [ConsoleColor]::DarkGray
        }
    }
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White; Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black; Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue; Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray; Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow; Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue; String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta; Comment = [ConsoleColor]::Gray
        }
    }
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green; Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan; Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White; Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow; String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White; Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing the theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme for the application.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName
    )
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            
            # Defensively check if RawUI exists. In some environments (like the VS Code
            # Integrated Console), it can be $null and cause a crash.
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            
            # Publish theme change event if the event system is available.
            if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
            }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    } -Context @{ ThemeName = $ThemeName } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to set TUI Theme to '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    # AI: This function is called frequently during render. The wrapper adds negligible overhead
    # but ensures any unexpected state corruption is handled gracefully.
    Invoke-WithErrorHandling -Component "ThemeManager.GetColor" -Context "Retrieving a theme color" -ScriptBlock {
        if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
            return $script:CurrentTheme.Colors[$ColorName]
        }
        return $Default
    } -Context @{ ColorName = $ColorName } -ErrorHandler {
        param($Exception)
        # Log the error but return the default to prevent a visual crash.
        Write-Log -Level Error -Message "Failed to get theme color '$($Exception.Context.ColorName)': $($Exception.Message)" -Data $Exception.Context
        return $Default
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme object.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving the current theme object" -ScriptBlock {
        return $script:CurrentTheme
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get current TUI Theme: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets a list of all available theme names.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving all available theme names" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get available themes: $($Exception.Message)" -Data $Exception.Context
        return @()
    }
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme in memory.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [string]$BaseTheme = "Modern",
        [hashtable]$Colors = @{}
    )
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating a new theme" -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        
        if ($script:Themes.ContainsKey($BaseTheme)) {
            $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone()
        }
        
        foreach ($colorKey in $Colors.Keys) {
            $newTheme.Colors[$colorKey] = $Colors[$colorKey]
        }
        
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    } -Context @{ ThemeName = $Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to create new TUI Theme '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to a JSON file.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting a theme to JSON" -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            
            foreach ($colorKey in $theme.Colors.Keys) {
                $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
            }
            
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    } -Context @{ ThemeName = $ThemeName; FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to export TUI Theme '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from a JSON file.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing a theme from JSON" -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to import TUI Theme from '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)


####\modules\tui-engine-v2.psm1
# Rock-Solid TUI Engine v4.0 - Performance & Reliability Edition
# Implements all critical fixes from code review



#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = New-Object System.Collections.Stack
    CurrentScreen   = $null
    IsDirty         = $true
    LastActivity    = [DateTime]::Now
    LastRenderTime  = [DateTime]::MinValue
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TotalTime = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    DebugOverlayEnabled = $false
    FocusedComponent = $null
    
    # Thread-safe input queue and runspace management
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    
    # The correct, thread-safe object for signalling shutdown.
    CancellationTokenSource = $null
    
    # Event cleanup tracking
    EventHandlers = @{}
}

# Debug messages removed to prevent screen bleed-through
# Note: Width and Height params are only available inside Initialize-TuiEngine function



# Cell pool to avoid thousands of hashtable allocations
$script:CellPool = @{
    Pool = New-Object System.Collections.Queue
    MaxSize = 1000
}
#endregion

#region Cell Management & Object Pooling

function Get-PooledCell {
    param(
        [char]$Char = ' ',
        [ConsoleColor]$FG = [ConsoleColor]::White,
        [ConsoleColor]$BG = [ConsoleColor]::Black
    )
    
    if ($script:CellPool.Pool.Count -gt 0) {
        $cell = $script:CellPool.Pool.Dequeue()
        $cell.Char = $Char
        $cell.FG = $FG
        $cell.BG = $BG
        return $cell
    }
    
    # Create new cell if pool is empty
    return @{
        Char = $Char
        FG = $FG
        BG = $BG
    }
}

function Return-CellToPool {
    param($Cell)
    if ($script:CellPool.Pool.Count -lt $script:CellPool.MaxSize) {
        $script:CellPool.Pool.Enqueue($Cell)
    }
}

#endregion

#region Engine Lifecycle & Main Loop

function global:Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    # Patch: Always set defaults if not passed in
    if (-not $Width) { $Width = [Console]::WindowWidth }
    if (-not $Height) { $Height = [Console]::WindowHeight - 1 }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    }

   

    
    
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        
        # Create 2D arrays for buffers
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        # Initialize buffers with empty cells
        $emptyCell = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear() # Clear console to remove initialization messages
        
        # Initialize subsystems with error handling
        try { 
            Initialize-LayoutEngines 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Layout engines initialized"
            }
        } catch { 
            Write-Warning "Layout engines init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Layout engines init failed" -Data $_
            }
        }
        try { 
            Initialize-ComponentSystem 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Component system initialized"
            }
        } catch { 
            Write-Warning "Component system init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Component system init failed" -Data $_
            }
        }
        
        # Track event handlers for cleanup (event system should already be initialized)
        $script:TuiState.EventHandlers = @{}
        
        # --- THE FIX: HOOK CTRL+C *BEFORE* STARTING THE INPUT THREAD ---
        # Temporarily disabled due to compatibility issues
        # TODO: Re-enable with proper PowerShell event handling
        try {
            [Console]::TreatControlCAsInput = $false
            # Ctrl+C handler temporarily disabled - will terminate process normally
        } catch {
            Write-Warning "Could not set console input mode: $_"
        }
        
        # Now it is safe to start the input thread.
        Initialize-InputThread
        
        # Publish initialization event
        Safe-PublishEvent -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        
        # Export TuiState for global access
        $global:TuiState = $script:TuiState
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "TUI Engine initialized successfully"
        }
    }
    catch {
        # --- ENHANCED DIAGNOSTIC BLOCK ---
        # This will now clearly print the root cause of any initialization failure.
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        Write-Host "IMMEDIATE, ORIGINAL ERROR DETECTED DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "THE *REAL* PROBLEM IS LIKELY THIS:" -ForegroundColor Yellow
        
        if ($_) {
            Write-Host "MESSAGE: $($_.Exception.Message)" -ForegroundColor White
            
            Write-Host "FULL ERROR:" -ForegroundColor Yellow
            if ($_.Exception) {
                $_.Exception | Format-List * -Force
            } else {
                Write-Host "Error details: $_" -ForegroundColor White
            }
        } else {
            Write-Host "Unknown error occurred" -ForegroundColor White
        }
        
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        
        # Re-throw the exception so the main script's finally block is triggered for cleanup.
        throw "FATAL: TUI Engine initialization failed. See original error details above."
    }
}

function Initialize-InputThread {
    try {
        # Create thread-safe input handling
        $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
        $script:TuiState.InputQueue = New-Object $queueType
    } catch {
        Write-Warning "Failed to create ConcurrentQueue, falling back to ArrayList"
        $script:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
    }
    
    # Create the cancellation token source for thread-safe shutdown.
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    # Create runspace for input handling (fully-qualified .NET types)
    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    # Create a PowerShell instance in that runspace
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    # This script block will run in the background.
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    $keyInfo = [Console]::ReadKey($true)
                    
                    # Handle different queue types
                    if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Enqueue($keyInfo)
                        }
                    } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Add($keyInfo) | Out-Null
                        }
                    }
                }
                else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] {
            return
        }
        catch {
            Write-Warning "Input thread error: $_"
        }
    }) | Out-Null
    
    # Store for cleanup
    $script:TuiState.InputRunspace   = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    # Process all queued input events
    $processedAny = $false
    # Check if the queue exists before trying to use it.
    if (-not $script:TuiState.InputQueue) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Verbose -Message "Processing input queue"
    }

    $keyInfo = $null
    
    # Handle different queue types
    if ($script:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
        $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
        while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
            $processedAny = $true
            $script:TuiState.LastActivity = [DateTime]::Now
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -ScriptBlock {
                Process-SingleKeyInput -keyInfo $keyInfo
            } -Context @{ KeyInfo = $keyInfo } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Error processing single key input: $($Exception.Message)" -Data $Exception.Context
                Request-TuiRefresh
            }
        }
    } elseif ($script:TuiState.InputQueue -is [System.Collections.ArrayList]) {
        while ($script:TuiState.InputQueue.Count -gt 0) {
            try {
                $keyInfo = $script:TuiState.InputQueue[0]
                $script:TuiState.InputQueue.RemoveAt(0)
                $processedAny = $true
                $script:TuiState.LastActivity = [DateTime]::Now
                Invoke-WithErrorHandling -Component "Engine.ProcessInput" -ScriptBlock {
                    Process-SingleKeyInput -keyInfo $keyInfo
                } -Context @{ KeyInfo = $keyInfo } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "Error processing single key input: $($Exception.Message)" -Data $Exception.Context
                    Request-TuiRefresh
                }
            } catch {
                break
            }
        }
    }
    
    return $processedAny
}

###```focus adddition 
function global:Set-ComponentFocus {
    param(
        [hashtable]$Component
    )
    
    $oldFocusedComponent = $script:TuiState.FocusedComponent
    
    if ($null -ne $oldFocusedComponent -and $oldFocusedComponent -ne $Component) {
        $oldFocusedComponent.IsFocused = $false
        if ($oldFocusedComponent.OnBlur) {
            try { & $oldFocusedComponent.OnBlur -self $oldFocusedComponent }
            catch { Write-Log -Level Warning -Message "OnBlur error: $_" }
        }
    }

    if ($null -eq $Component) {
        $script:TuiState.FocusedComponent = $null
        Request-TuiRefresh
        return
    }

    if ($Component.IsFocusable -ne $true -or $Component.Visible -ne $true) {
        return
    }

    $script:TuiState.FocusedComponent = $Component
    $Component.IsFocused = $true
    
    if ($Component.OnFocus) {
        try { & $Component.OnFocus -self $Component }
        catch { Write-Log -Level Warning -Message "OnFocus error: $_" }
    }
    
    Request-TuiRefresh
}

function global:Handle-TabNavigation {
    param(
        [bool]$Reverse = $false
    )
    
    $currentScreen = $script:TuiState.CurrentScreen
    if (-not $currentScreen) { return }

    $focusable = @()
    $FindFocusableIn = {
        param($component)
        if ($component -and $component.IsFocusable -eq $true -and $component.Visible -eq $true) {
            $script:focusable += $component
        }
        if ($component -and $component.Children) {
            foreach ($child in $component.Children) {
                & $script:FindFocusableIn -component $child
            }
        }
    }
    
    foreach ($compName in $currentScreen.Components.Keys) {
        & $FindFocusableIn -component $currentScreen.Components[$compName]
    }

    if ($focusable.Count -eq 0) { return }

    $sortedFocusable = $focusable | Sort-Object { $_.Y }, { $_.X }

    $currentIndex = [array]::IndexOf($sortedFocusable, $script:TuiState.FocusedComponent)
    
    $nextIndex = 0
    if ($currentIndex -ne -1) {
        $direction = if ($Reverse) { -1 } else { 1 }
        $nextIndex = ($currentIndex + $direction + $sortedFocusable.Count) % $sortedFocusable.Count
    }

    Set-ComponentFocus -Component $sortedFocusable[$nextIndex]
}

function global:Clear-ComponentFocus {
    Set-ComponentFocus -Component $null
}
###```

function Process-SingleKeyInput {
    param($keyInfo)
    
    try {
        # Tab navigation handled by focus manager if available
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            if (Get-Command -Name "Move-Focus" -ErrorAction SilentlyContinue) {
                Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            } else {
                # Fallback to old tab navigation
                Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            }
            return
        }
        
        # Dialog system gets first chance at input
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and (Handle-DialogInput -Key $keyInfo)) {
            return
        }
        
        # Get focused component from focus manager if available
        $focusedComponent = if (Get-Command -Name "Get-FocusedComponent" -ErrorAction SilentlyContinue) {
            Get-FocusedComponent
        } else {
            $script:TuiState.FocusedComponent
        }
        
        # Focused component gets the next chance
        if ($focusedComponent -and $focusedComponent.HandleInput) {
            try {
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) {
                    return
                }
            } catch {
                Write-Warning "Component input handler error: $_"
            }
        }
        
        # Finally, the screen itself gets the key
        $currentScreen = $script:TuiState.CurrentScreen
        if ($currentScreen -and $currentScreen.HandleInput) {
            try {
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { 
                        $script:TuiState.Running = $false
                        if ($script:TuiState.CancellationTokenSource) {
                            $script:TuiState.CancellationTokenSource.Cancel()
                        }
                    }
                }
            } catch {
                Write-Warning "Screen input handler error: $_"
            }
        }
    } catch {
        Write-Warning "Input processing error: $_"
    }
}

function global:Start-TuiLoop {
    param([hashtable]$InitialScreen = $null)

    try {
        # Only initialize if not already initialized
        if (-not $script:TuiState.BufferWidth -or $script:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }
        
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        
        # If no screen is active and no initial screen provided, we can't start
        if (-not $script:TuiState.CurrentScreen -and $script:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display. Push a screen before calling Start-TuiLoop or provide an InitialScreen parameter."
        }

        $script:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            # ==========================================================
            # === BEGIN CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
            try {
                $frameTime.Restart()

                # Process input
                $hadInput = Process-TuiInput
                
                # Update dialog system
                if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) { 
                    try { Update-DialogSystem } catch { Write-Log -Level Warning -Message "Dialog update error: $_" }
                }

                # Render if dirty or had input
                if ($script:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $script:TuiState.IsDirty = $false
                }
                
                # Adaptive frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }
            }
            catch [HeliosException] {
                # --- This block handles our custom, "recoverable" errors ---
                $exception = $_.Exception
                
                # 1. Log the rich, detailed error for developers
                Write-Log -Level Error -Message "A TUI Exception occurred: $($exception.Message)" -Data $exception.Context
                
                # 2. Show a simple, clean dialog to the user
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($exception.Message)"
                
                # 3. Force a full re-render to clean up any UI artifacts from the failed operation
                $script:TuiState.IsDirty = $true
            }
            catch {
                # --- This block handles unexpected, potentially fatal errors ---
                $exception = $_.Exception
                
                # 1. Log the catastrophic failure
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($exception.Message)" -Data $_
                
                # 2. Inform the user and prepare for shutdown
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                
                # 3. Stop the main loop to exit gracefully
                $script:TuiState.Running = $false
            }
            # ==========================================================
            # === END CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
        }
    }
    finally {
        Cleanup-TuiEngine
    }
}

# ==============================================================================
# === CRITICAL FIX: NEW RENDER-FRAME IMPLEMENTATION ============================
# ==============================================================================
function Render-Frame {
    try {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Verbose -Message "Starting Z-Index frame render"
        }
        
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }
        
        # Always clear the back buffer completely
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # 1. RENDER SCREEN CHROME (Header, Footer, etc.)
        # This is for elements NOT in the component tree. The screen's Render method
        # should ONLY draw these non-component elements.
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Render) {
            Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).Render" -ScriptBlock {
                & $script:TuiState.CurrentScreen.Render -self $script:TuiState.CurrentScreen
            } -Context @{ ScreenName = $script:TuiState.CurrentScreen.Name } -ErrorHandler {
                param($Exception)
                Write-Log -Level Error -Message "Screen-level render error: $($Exception.Message)" -Data $Exception.Context
            }
        }

        # 2. COLLECT all visible components from the screen's Children and any active dialogs.
        $renderQueue = [System.Collections.Generic.List[hashtable]]::new()
        
        # Debug: Log screen state
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Render-Frame: CurrentScreen=$($script:TuiState.CurrentScreen.Name), Children count=$($script:TuiState.CurrentScreen.Children.Count)"
        }
        
        # Define collectComponents as a scriptblock variable that can reference itself
        $script:collectComponents = {
            param($component)
            if (-not $component -or $component.Visible -eq $false) { return }
            
            # Add the component itself to the queue
            $renderQueue.Add($component)
            
            # Debug logging
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Collected component: Type=$($component.Type), Name=$($component.Name), Pos=($($component.X),$($component.Y)), ZIndex=$($component.ZIndex), Children=$($component.Children.Count)"
            }
            
            # Process children if any
            if ($component.Children -and $component.Children.Count -gt 0) {
                # A panel must calculate its children's layout before they are collected
                if ($component.CalculateLayout) {
    		  try { 
        		[void](& $component.CalculateLayout -self $component) # FIX: Suppress output
   		  }
    		  catch { 
        		Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" -Data $_ 
    		  }
	    }
                
                # Recursively collect each child
                foreach ($child in $component.Children) {
                    & $script:collectComponents $child
                }
            }
        }

        # Start collection from the screen's children
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Children) {
            foreach ($child in $script:TuiState.CurrentScreen.Children) {
                & $script:collectComponents -component $child
            }
        }

        # Collect from the current dialog (which is a self-contained component tree)
        if ((Get-Command -Name "Get-CurrentDialog" -ErrorAction SilentlyContinue)) {
            $currentDialog = Get-CurrentDialog
            if ($currentDialog) {
                & $script:collectComponents -component $currentDialog
            }
        }
        
        # 3. SORT the render queue by ZIndex
        $sortedQueue = $renderQueue | Sort-Object -Property ZIndex
        
        # 4. DRAW the sorted components
        foreach ($componentToRender in $sortedQueue) {
            if ($componentToRender.Render) {
                Invoke-WithErrorHandling -Component "$($componentToRender.Name ?? $componentToRender.Type).Render" -ScriptBlock {
                    & $componentToRender.Render -self $componentToRender
                } -Context @{ ComponentType = $componentToRender.Type; ComponentName = $componentToRender.Name; ComponentProps = $componentToRender.Props } -ErrorHandler {
                    param($Exception)
                    throw [ComponentRenderException]::new(
                        "Failed to render component '$($Exception.Context.ComponentName ?? $Exception.Context.ComponentType)'",
                        @{
                            FailingComponent = $Exception.Context.Component
                            OriginalException = $Exception.OriginalError # Preserve the original error object
                        }
                    )
                }
            }
        }
        
        # 5. FINALIZE the frame
        Render-BufferOptimized
        
        # Force cursor to bottom-right to avoid interference
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
        
    } catch {
        Write-Warning "Fatal Frame render error: $_"
    }
}

function global:Request-TuiRefresh {
    $script:TuiState.IsDirty = $true
}

function Cleanup-TuiEngine {
    try {
        # --- ROBUST CLEANUP ROUTINE ---
        # This sequence is defensive and will not fail even if initialization was partial.
        if ($script:TuiState.CancellationTokenSource) {
            try {
                if (-not $script:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $script:TuiState.CancellationTokenSource.Cancel()
                }
            } catch { 
                # Ignore errors if CancellationTokenSource is in an invalid state
            }
        }

        if ($script:TuiState.InputPowerShell) {
            if ($script:TuiState.InputAsyncResult) {
                try { $script:TuiState.InputPowerShell.EndInvoke($script:TuiState.InputAsyncResult) } catch { }
            }
            try { $script:TuiState.InputPowerShell.Dispose() } catch { }
        }
        
        if ($script:TuiState.InputRunspace) {
            try { $script:TuiState.InputRunspace.Dispose() } catch { }
        }
        
        if ($script:TuiState.CancellationTokenSource) {
            try { $script:TuiState.CancellationTokenSource.Dispose() } catch { }
        }

        # Clean up background jobs
        if (Get-Command -Name "Stop-AllTuiAsyncJobs" -ErrorAction SilentlyContinue) {
            try { Stop-AllTuiAsyncJobs } catch { }
        }

        Cleanup-EventHandlers
        
        # Only try to reset the console if we are in an interactive session
        if (-not $env:CI -and -not $PSScriptRoot) {
            try {
                if ([System.Environment]::UserInteractive) {
                    [Console]::Write("$([char]27)[0m")
                    [Console]::CursorVisible = $true
                    [Console]::Clear()
                    [Console]::ResetColor()
                }
            } catch {
                # This can fail in non-interactive environments, ignore the error.
            }
        }
    } catch {
        Write-Warning "A secondary error occurred during TUI cleanup: $_"
    }
}

function Cleanup-EventHandlers {
    if (-not (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) { return }
    if (-not $script:TuiState.EventHandlers) { return }

    foreach ($handlerId in $script:TuiState.EventHandlers.Values) {
        try { Unsubscribe-Event -HandlerId $handlerId } catch { }
    }
    $script:TuiState.EventHandlers.Clear()
    
    # Clean up any orphaned Ctrl+C event handler if it exists
    try {
        Get-EventSubscriber -SourceIdentifier "TuiCtrlC" -ErrorAction SilentlyContinue | Unregister-Event
    } catch { }
}

function Safe-PublishEvent {
    param($EventName, $Data)
    if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
        try { Publish-Event -EventName $EventName -Data $Data } catch { }
    }
}

#endregion

#region Screen Management

function global:Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                # This is less critical, so a log is acceptable, but we can be more specific.
                Write-Log -Level Warning -Message "Error in OnBlur for component '$($script:TuiState.FocusedComponent.Name)'" -Data $_
            }
        }
        
        if ($script:TuiState.CurrentScreen) {
            if ($script:TuiState.CurrentScreen.OnExit) { 
                Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnExit" -ScriptBlock {
                    & $script:TuiState.CurrentScreen.OnExit -self $script:TuiState.CurrentScreen
                } -Context @{ ScreenName = $script:TuiState.CurrentScreen.Name } -ErrorHandler {
                    param($Exception)
                    Write-Warning "Screen exit error: $($Exception.Message)"
                }
            }
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        if ($Screen.Init) { 
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -ScriptBlock {
                # Pass services if available on the screen object
                if ($Screen._services) {
                    & $Screen.Init -self $Screen -services $Screen._services
                } else {
                    & $Screen.Init -self $Screen
                }
            } -Context @{ ScreenName = $Screen.Name } -ErrorHandler {
                param($Exception)
                throw [ServiceInitializationException]::new(
                    "Failed to initialize screen '$($Exception.Context.ScreenName)'",
                    @{
                        FailingScreen = $Screen
                        OriginalException = $Exception.OriginalError
                    }
                )
            }
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
        
    } catch {
        Write-Warning "Push screen error: $_"
    }
}

function global:Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Popping screen"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        # Store the screen to exit before changing CurrentScreen
        $screenToExit = $script:TuiState.CurrentScreen
        
        # Pop the new screen from the stack
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        # Call lifecycle hooks in correct order
        if ($screenToExit -and $screenToExit.OnExit) { 
            Invoke-WithErrorHandling -Component "$($screenToExit.Name).OnExit" -ScriptBlock {
                & $screenToExit.OnExit -self $screenToExit
            } -Context @{ ScreenName = $screenToExit.Name } -ErrorHandler {
                param($Exception)
                Write-Warning "Screen exit error: $($Exception.Message)"
            }
        }
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.OnResume) { 
            Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnResume" -ScriptBlock {
                & $script:TuiState.CurrentScreen.OnResume -self $script:TuiState.CurrentScreen
            } -Context @{ ScreenName = $script:TuiState.CurrentScreen.Name } -ErrorHandler {
                param($Exception)
                Write-Warning "Screen resume error: $($Exception.Message)"
            }
        }
        
        # Restore focus if the screen tracks it
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        
        return $true
        
    } catch {
        Write-Warning "Pop screen error: $_"
        return $false
    }
}

#endregion

#region Buffer and Rendering

# GetBufferIndex no longer needed - using 2D arrays directly

function global:Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Create a new cell for each position to ensure proper clearing
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function global:Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $script:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Pragmatic check for CJK/wide characters. A full implementation is library-dependent.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            # Also fill the next cell with a space for wide characters to prevent overlap
            if ($currentX -lt $script:TuiState.BufferWidth -and $currentX -gt 0) {
                $script:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function global:Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Top border
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title
    if ($Title) {
        $titleText = " $Title "
        if ($titleText.Length -gt ($Width - 2)) {
            # FIX: Ensure the length for Substring is never negative.
            $maxLength = [Math]::Max(0, $Width - 5)
            $titleText = " $($Title.Substring(0, $maxLength))... "
        }
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
       Write-BufferString -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and Fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function global:Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    # Force full render on first frame or if requested
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    
    try {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            # Position cursor at start of line
            $outputBuilder.Append("$([char]27)[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]
                $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                
                # Skip if cell hasn't changed (unless forcing full render)
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("$([char]27)[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("$([char]27)[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                # Append character
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $script:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting at the end
        $outputBuilder.Append("$([char]27)[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Warning "Render error: $_"
    }
    
    # Update stats
    $stopwatch.Stop()
    $script:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $script:TuiState.RenderStats.FrameCount++
    $script:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Component System

function Initialize-ComponentSystem {
    $script:TuiState.Components = @()
    $script:TuiState.FocusedComponent = $null
}

function global:Register-Component {
    param([hashtable]$Component)
    
    # Add to component registry
    $script:TuiState.Components += $Component
    
    # Initialize component with error handling
    if ($Component.Init) {
        Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).Init" -ScriptBlock {
            & $Component.Init -self $Component
        } -Context @{ ComponentType = $Component.Type; ComponentName = $Component.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component init error: $($Exception.Message)"
        }
    }
    
    return $Component
}

function global:Set-ComponentFocus {
    param([hashtable]$Component)
    
    # Don't focus disabled components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) {
        return
    }
    
    # Blur previous component with error handling
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -ScriptBlock {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } -Context @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component blur error: $($Exception.Message)"
        }
    }
    
    # Track focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $Component
    }
    
    # Focus new component with error handling
    $script:TuiState.FocusedComponent = $Component
    if ($Component -and $Component.OnFocus) {
        Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).OnFocus" -ScriptBlock {
            & $Component.OnFocus -self $Component
        } -Context @{ ComponentType = $Component.Type; ComponentName = $Component.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component focus error: $($Exception.Message)"
        }
    }
    
    Request-TuiRefresh
}

function global:Clear-ComponentFocus {
    <#
    .SYNOPSIS
    Clears focus from the current component
    #>
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -ScriptBlock {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } -Context @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name } -ErrorHandler {
            param($Exception)
            Write-Warning "Component blur error: $($Exception.Message)"
        }
    }
    
    $script:TuiState.FocusedComponent = $null
    
    # Clear tracked focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $null
    }
    
    Request-TuiRefresh
}

function global:Get-NextFocusableComponent {
    <#
    .SYNOPSIS
    Gets the next focusable component in tab order
    #>
    param(
        [hashtable]$CurrentComponent,
        [bool]$Reverse = $false
    )
    
    if (-not $script:TuiState.CurrentScreen) { return $null }
    
    # Get all focusable components
    $focusableComponents = @()
    
    # Recursive function to find focusable components
    function Find-FocusableComponents {
        param($Component)
        
        # Check using the correct properties that our components actually have
        if ($Component.IsFocusable -eq $true -and 
            $Component.Visible -ne $false) {
            $focusableComponents += $Component
        }
        
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                Find-FocusableComponents -Component $child
            }
        }
    }
    
    # Start from screen components
    if ($script:TuiState.CurrentScreen.Components) {
        if ($script:TuiState.CurrentScreen.Components -is [hashtable]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components.Values) {
                Find-FocusableComponents -Component $comp
            }
        } elseif ($script:TuiState.CurrentScreen.Components -is [array]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components) {
                Find-FocusableComponents -Component $comp
            }
        }
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by TabIndex or position
    $sorted = $focusableComponents | Sort-Object {
        if ($null -ne $_.TabIndex) { $_.TabIndex }
        else { $_.Y * 1000 + $_.X }
    }
    
    if ($Reverse) {
        [Array]::Reverse($sorted)
    }
    
    # Find current index
    $currentIndex = -1
    for ($i = 0; $i -lt $sorted.Count; $i++) {
        if ($sorted[$i] -eq $CurrentComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Get next component
    if ($currentIndex -ge 0) {
        $nextIndex = ($currentIndex + 1) % $sorted.Count
        return $sorted[$nextIndex]
    } else {
        return $sorted[0]
    }
}

function global:Handle-TabNavigation {
    <#
    .SYNOPSIS
    Handles Tab key navigation between components  
    #>
    param([bool]$Reverse = $false)
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Handle-TabNavigation called, Reverse=$Reverse"
    }
    
    $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Setting focus to component: Type=$($next.Type), Name=$($next.Name)"
        }
        Set-ComponentFocus -Component $next
    }
}

function global:New-Component {
    param(
        [string]$Type = "Base",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 1,
        [hashtable]$Props = @{}
    )
    
    $component = @{
        Type = $Type
        X = $X
        Y = $Y
        Width = $Width
        Height = $Height
        Visible = $true
        Focused = $false
        Parent = $null
        Children = @()
        Props = $Props
        State = @{}
        
        # Lifecycle methods
        Init = { param($self) }
        Render = { param($self) }
        HandleInput = { param($self, $Key) return $false }
        OnFocus = { param($self) $self.Focused = $true }
        OnBlur = { param($self) $self.Focused = $false }
        Dispose = { param($self) }
    }
    
    # Merge with type-specific properties
    switch ($Type) {
        "TextInput" { $component = Merge-Hashtables $component (Get-TextInputComponent) }
        "Button" { $component = Merge-Hashtables $component (Get-ButtonComponent) }
        "List" { $component = Merge-Hashtables $component (Get-ListComponent) }
        "Table" { $component = Merge-Hashtables $component (Get-TableComponent) }
    }
    
    return $component
}

function Merge-Hashtables {
    param($Base, $Override)
    $result = $Base.Clone()
    foreach ($key in $Override.Keys) {
        $result[$key] = $Override[$key]
    }
    return $result
}

#endregion

#region Layout Management

function Initialize-LayoutEngines {
    $script:TuiState.Layouts = @{
        Grid = Get-GridLayout
        Stack = Get-StackLayout
        Dock = Get-DockLayout
    }
}

function global:Apply-Layout {
    param(
        [string]$LayoutType,
        [hashtable[]]$Components,
        [hashtable]$Options = @{}
    )
    
    if ($script:TuiState.Layouts.ContainsKey($LayoutType)) {
        $layout = $script:TuiState.Layouts[$LayoutType]
        Invoke-WithErrorHandling -Component "Layout.$LayoutType" -ScriptBlock {
            & $layout.Apply -Components $Components -Options $Options
        } -Context @{ LayoutType = $LayoutType; Options = $Options } -ErrorHandler {
            param($Exception)
            Write-Warning "Layout error: $($Exception.Message)"
        }
    }
}

function Get-GridLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $cols = if ($Options.Columns) { $Options.Columns } else { 2 }
            $rows = [Math]::Ceiling($Components.Count / $cols)
            $cellWidth = [Math]::Floor($script:TuiState.BufferWidth / $cols)
            $cellHeight = [Math]::Floor($script:TuiState.BufferHeight / $rows)
            
            for ($i = 0; $i -lt $Components.Count; $i++) {
                $col = $i % $cols
                $row = [Math]::Floor($i / $cols)
                $Components[$i].X = $col * $cellWidth
                $Components[$i].Y = $row * $cellHeight
                $Components[$i].Width = $cellWidth - 1
                $Components[$i].Height = $cellHeight - 1
            }
        }
    }
}

function Get-StackLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $orientation = if ($Options.Orientation) { $Options.Orientation } else { "Vertical" }
            $spacing = if ($null -ne $Options.Spacing) { $Options.Spacing } else { 1 }
            $x = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $y = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            
            foreach ($component in $Components) {
                $component.X = $x
                $component.Y = $y
                
                if ($orientation -eq "Vertical") {
                    $y += $component.Height + $spacing
                } else {
                    $x += $component.Width + $spacing
                }
            }
        }
    }
}

function Get-DockLayout {
    return @{
        Apply = {
            param($Components, $Options)
            
            # Container bounds
            $containerX = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $containerY = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            $containerWidth = if ($Options.Width) { $Options.Width } else { $script:TuiState.BufferWidth }
            $containerHeight = if ($Options.Height) { $Options.Height } else { $script:TuiState.BufferHeight }
            
            # Current available area
            $availableX = $containerX
            $availableY = $containerY
            $availableWidth = $containerWidth
            $availableHeight = $containerHeight
            
            # Process components by dock position
            $topComponents = $Components | Where-Object { $_.Props.Dock -eq "Top" }
            $bottomComponents = $Components | Where-Object { $_.Props.Dock -eq "Bottom" }
            $leftComponents = $Components | Where-Object { $_.Props.Dock -eq "Left" }
            $rightComponents = $Components | Where-Object { $_.Props.Dock -eq "Right" }
            $fillComponents = $Components | Where-Object { $_.Props.Dock -eq "Fill" -or -not $_.Props.Dock }
            
            # Dock top components
            foreach ($comp in $topComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $availableY += $comp.Height
                $availableHeight -= $comp.Height
            }
            
            # Dock bottom components
            foreach ($comp in $bottomComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY + $availableHeight - $comp.Height
                $comp.Width = $availableWidth
                $availableHeight -= $comp.Height
            }
            
            # Dock left components
            foreach ($comp in $leftComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableX += $comp.Width
                $availableWidth -= $comp.Width
            }
            
            # Dock right components
            foreach ($comp in $rightComponents) {
                $comp.X = $availableX + $availableWidth - $comp.Width
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableWidth -= $comp.Width
            }
            
            # Fill remaining space
            foreach ($comp in $fillComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $comp.Height = $availableHeight
            }
        }
    }
}

#endregion

#region Utility Functions

function global:Get-BorderChars { 
    param([string]$Style) 
    $styles = @{ 
        Single = @{ 
            TopLeft='┌'; TopRight='┐'; BottomLeft='└'; BottomRight='┘'
            Horizontal='─'; Vertical='│' 
        }
        Double = @{ 
            TopLeft='╔'; TopRight='╗'; BottomLeft='╚'; BottomRight='╝'
            Horizontal='═'; Vertical='║' 
        }
        Rounded = @{ 
            TopLeft='╭'; TopRight='╮'; BottomLeft='╰'; BottomRight='╯'
            Horizontal='─'; Vertical='│' 
        } 
    }
    if ($styles.ContainsKey($Style)) { 
        return $styles[$Style] 
    } else { 
        return $styles.Single 
    }
}

function Get-AnsiColorCode { 
    param([ConsoleColor]$Color, [bool]$IsBackground) 
    $map = @{ 
        Black=30; DarkBlue=34; DarkGreen=32; DarkCyan=36
        DarkRed=31; DarkMagenta=35; DarkYellow=33; Gray=37
        DarkGray=90; Blue=94; Green=92; Cyan=96
        Red=91; Magenta=95; Yellow=93; White=97 
    }
    $code = $map[$Color.ToString()]
    if ($IsBackground) { 
        return $code + 10 
    } else { 
        return $code 
    } 
}

function Get-ThemeColorFallback {
    param($ColorName, $Default = [ConsoleColor]::White)
    # This is a fallback function for when theme manager isn't available
    # The theme manager will override this with its own global Get-ThemeColor
    return $Default
}

# Only define global Get-ThemeColor if it doesn't already exist
if (-not (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue)) {
    function global:Get-ThemeColor {
        param($ColorName, $Default = [ConsoleColor]::White)
        return Get-ThemeColorFallback -ColorName $ColorName -Default $Default
    }
}

function global:Write-StatusLine { 
    param(
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = 'White', 
        [ConsoleColor]$BackgroundColor = 'DarkBlue'
    ) 
    try { 
        $y = $script:TuiState.BufferHeight
        [Console]::SetCursorPosition(0, $y)
        [Console]::ForegroundColor = $ForegroundColor
        [Console]::BackgroundColor = $BackgroundColor
        [Console]::Write($Text.PadRight([Console]::WindowWidth))
        [Console]::ResetColor() 
    } catch {
        Write-Warning "Status line error: $_"
    } 
}

function global:Subscribe-TuiEvent {
    param($EventName, $Handler)
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        $handlerId = Subscribe-Event -EventName $EventName -Handler $Handler
        # Track for cleanup
        $script:TuiState.EventHandlers[$EventName] = $handlerId
        return $handlerId
    }
}

#endregion

#region Component Definitions

function Get-TextInputComponent {
    return @{
        # State
        Value = ""
        CursorPosition = 0
        MaxLength = 50
        
        # Methods
        Render = {
            param($self)
            try {
                $borderColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Draw input box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    Write-BufferString -X ($self.X - 1) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    # Right bracket
                    Write-BufferString -X ($self.X + $self.Width) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                }
                
                # Draw text
                $displayText = $self.Value
                if ($displayText.Length > ($self.Width - 3)) {
                    $displayText = $displayText.Substring($displayText.Length - ($self.Width - 3))
                }
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text $displayText
                
                # Draw cursor if focused
                if ($self.Focused -and $self.CursorPosition -lt ($self.Width - 3)) {
                    Write-BufferString -X ($self.X + 1 + $self.CursorPosition) -Y ($self.Y + 1) `
                        -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
                }
            } catch {
                Write-Warning "TextInput render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) {
                        if ($self.Value.Length -gt 0 -and $self.CursorPosition -gt 0) {
                            $self.Value = $self.Value.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.Value = $self.Value.Remove($self.CursorPosition, 1)
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.CursorPosition++
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.Value.Length
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and 
                            $self.Value.Length -lt $self.MaxLength) {
                            $self.Value = $self.Value.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            return $true
                        }
                    }
                }
            } catch {
                Write-Warning "TextInput input error: $_"
            }
            return $false
        }
    }
}

function Get-ButtonComponent {
    return @{
        # State
        Text = "Button"
        
        # Methods
        Render = {
            param($self)
            try {
                $bgColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::DarkCyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::DarkGray)
                }
                
                $text = " $($self.Text) "
                if ($text.Length > $self.Width) {
                    $text = $text.Substring(0, $self.Width)
                }
                
                $x = $self.X + [Math]::Floor(($self.Width - $text.Length) / 2)
                Write-BufferString -X $x -Y $self.Y -Text $text `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor $bgColor
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    if ($x -gt 0) {
                        Write-BufferString -X ($x - 1) -Y $self.Y `
                            -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                    # Right bracket
                    if (($x + $text.Length) -lt $script:TuiState.BufferWidth) {
                        Write-BufferString -X ($x + $text.Length) -Y $self.Y `
                            -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                }
            } catch {
                Write-Warning "Button render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                    if ($self.OnClick) {
                        & $self.OnClick -self $self
                    }
                    return $true
                }
            } catch {
                Write-Warning "Button input error: $_"
            }
            return $false
        }
    }
}

function Get-TableComponent {
    return @{
        # State
        Data = @()
        Columns = @()
        SelectedRow = 0
        ScrollOffset = 0
        
        # Methods
        Render = {
            param($self)
            try {
                # Simplified table rendering
                $y = $self.Y
                
                # Header
                $headerText = ""
                foreach ($col in $self.Columns) {
                    $headerText += $col.Name.PadRight($col.Width)
                }
                Write-BufferString -X $self.X -Y $y -Text $headerText `
                    -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                $y++
                
                # Data rows
                $visibleRows = $self.Data | Select-Object -Skip $self.ScrollOffset -First ($self.Height - 1)
                $rowIndex = $self.ScrollOffset
                foreach ($row in $visibleRows) {
                    $rowText = ""
                    foreach ($col in $self.Columns) {
                        $value = if ($row.($col.Property)) { $row.($col.Property) } else { "" }
                        $rowText += $value.ToString().PadRight($col.Width)
                    }
                    
                    $fg = if ($rowIndex -eq $self.SelectedRow) {
                        Get-ThemeColor "Selection" -Default ([ConsoleColor]::Yellow)
                    } else {
                        Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                    }
                    
                    Write-BufferString -X $self.X -Y $y -Text $rowText -ForegroundColor $fg
                    $y++
                    $rowIndex++
                }
            } catch {
                Write-Warning "Table render error: $_"
            }
        }
    }
}

#endregion

#region Word Wrap Helper
function global:Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    $words = $Text -split '\s+'
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}
#endregion

# Build export list dynamically
$exportFunctions = @(
    'Start-TuiLoop', 'Request-TuiRefresh', 'Push-Screen', 'Pop-Screen',
    'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer',
    'Write-StatusLine', 'Get-BorderChars',
    'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 
    'Get-NextFocusableComponent', 'Handle-TabNavigation', 
    'New-Component', 'Apply-Layout',
    'Get-WordWrappedLines', 'Subscribe-TuiEvent',
    'Render-Frame', 'Initialize-TuiEngine'
)

# Only export Get-ThemeColor if we defined it
if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue | Where-Object { $_.Source -eq "tui-engine-v2" }) {
    $exportFunctions += 'Get-ThemeColor'
}

Export-ModuleMember -Function $exportFunctions -Variable @('TuiState')


####\modules\tui-framework.psm1
# TUI Framework Integration Module - COMPLIANT VERSION
# Contains compliant utility functions. Deprecated functions have been removed.

$script:TuiAsyncJobs = @()

function global:Invoke-TuiMethod {
    <#
    .SYNOPSIS
    Safely invokes a method on a TUI component.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Component,

        [Parameter(Mandatory = $true)]
        [string]$MethodName,

        [Parameter()]
        [hashtable]$Arguments = @{}
    )

    # AI: Defensive check for null component to prevent errors.
    if ($null -eq $Component) { return }
    
    # AI: Check if the method key exists and is a scriptblock before attempting invocation.
    # This prevents "The term '...' is not recognized" errors for optional methods.
    if (-not $Component.ContainsKey($MethodName)) { return }
    $method = $Component[$MethodName]
    if ($null -eq $method -or $method -isnot [scriptblock]) {
        return
    }

    # Add the component itself as the 'self' parameter for convenience within the method.
    $Arguments['self'] = $Component

    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock {
        # Use splatting with the @ operator for robust parameter passing.
        & $method @Arguments
    } -Context @{ Component = $Component.Name; Method = $MethodName } -ErrorHandler {
        param($Exception)
        # Log the error but do not re-throw, allowing the UI to remain responsive.
        Write-Log -Level Error -Message "Error invoking method '$($Exception.Context.Method)' on component '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        Request-TuiRefresh
    }
}

function global:Initialize-TuiFramework {
    <#
    .SYNOPSIS
    Initializes the TUI framework.
    #>
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        # Ensure engine is initialized before the framework.
        if (-not $global:TuiState) {
            throw "TUI Engine must be initialized before the TUI Framework."
        }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function global:Invoke-TuiAsync {
    <#
    .SYNOPSIS
    Executes a script block asynchronously with proper job management.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        [Parameter()]
        [scriptblock]$OnComplete = {},
        [Parameter()]
        [scriptblock]$OnError = {},
        [Parameter()]
        [array]$ArgumentList = @()
    )
    
    Invoke-WithErrorHandling -Component "TuiFramework.InvokeAsync" -Context "Starting async job" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList
        $script:TuiAsyncJobs += $job
        
        $timer = New-Object System.Timers.Timer
        $timer.Interval = 100
        $timer.AutoReset = $true
        
        $timerEvent = Register-ObjectEvent -InputObject $timer -EventName Elapsed -Action {
            param($Event)
            $jobData = $Event.MessageData
            $job = $jobData.Job
            
            if ($job.State -in 'Completed', 'Failed') {
                $jobData.Timer.Stop()
                $jobData.Timer.Dispose()
                Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                
                $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id })

                if ($job.State -eq 'Completed') {
                    $result = Receive-Job -Job $job
                    if ($jobData.OnComplete) { & $jobData.OnComplete -Data $result }
                } else {
                    $error = $job.ChildJobs[0].JobStateInfo.Reason
                    if ($jobData.OnError) { & $jobData.OnError -Error $error }
                }
                Remove-Job -Job $job -Force
                Request-TuiRefresh
            }
        } -MessageData @{
            Job = $job
            OnComplete = $OnComplete
            OnError = $OnError
            Timer = $timer
        }
        
        $timer.Start()
        return @{ Job = $job; Timer = $timer; EventSubscription = $timerEvent }
    }
}

function global:Stop-AllTuiAsyncJobs {
    <#
    .SYNOPSIS
    Stops and cleans up all tracked async jobs.
    #>
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsyncJobs" -Context "Cleaning up async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                if ($job.State -eq 'Running') { Stop-Job -Job $job -ErrorAction SilentlyContinue }
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
            } catch {
                Write-Log -Level Warning -Message "Failed to stop or remove job $($job.Id)" -Data $_
            }
        }
        $script:TuiAsyncJobs = @()
        
        Get-EventSubscriber | Where-Object { $_.SourceObject -is [System.Timers.Timer] } | ForEach-Object {
            try {
                Unregister-Event -SourceIdentifier $_.SourceIdentifier -ErrorAction SilentlyContinue
                if ($_.SourceObject) {
                    $_.SourceObject.Stop()
                    $_.SourceObject.Dispose()
                }
            } catch { }
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-TuiFramework',
    'Invoke-TuiMethod',
    'Invoke-TuiAsync',
    'Stop-AllTuiAsyncJobs'
)


####\screens\dashboard-screen-helios.psm1
# Dashboard Screen - Refactored for Service-Oriented Architecture
# Displays dynamic data and uses direct service calls and eventing.

using module '.\models.psm1'

function Get-DashboardScreen {
    param([hashtable]$Services)
    
    $screen = @{
        Name = "DashboardScreen"
        Components = @{}
        Children = @()
        _subscriptions = @()
        _focusIndex = 0
        _services = $null
        Visible = $true
        ZIndex = 0
        
        Init = {
            param($self, $services)
            
            Invoke-WithErrorHandling -Component "Dashboard.Init" -OperationName "Initialize" -ScriptBlock {
                # Defensive service validation
                if (-not $services) {
                    if ($self._services) {
                        $services = $self._services
                        Write-Log -Level Warning -Message "Dashboard Init: Using stored services"
                    }
                    else {
                        throw "No services available for dashboard initialization"
                    }
                }
                
                # Store services on screen instance
                $self._services = $services
                
                # Validate critical services exist
                if (-not $services.Navigation) {
                    throw "Navigation service is missing for dashboard"
                }
                
                Write-Log -Level Info -Message "Dashboard Init: Services validated successfully"
                
                # Create simple root panel
                $rootPanel = New-TuiStackPanel -Props @{
                    X = 2
                    Y = 2
                    Width = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                    Height = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                    ShowBorder = $true
                    Title = " PMC Terminal v5 - Main Menu "
                    Orientation = "Vertical"
                    Spacing = 1
                    Padding = 2
                }
                
                # Store reference and add to children
                $self.Components.rootPanel = $rootPanel
                $self.Children = @($rootPanel)
                
                # Add instruction label
                $instructionLabel = New-TuiTextBlock -Props @{
                    Text = "Use Arrow Keys or Number Keys to Navigate"
                    Height = 1
                    Width = "100%"
                }
                & $rootPanel.AddChild -self $rootPanel -Child $instructionLabel | Out-Null
                
                # Create menu data
                $menuItems = @(
                    @{ Index = "1"; Action = "View Tasks"; Path = "/task" }
                    @{ Index = "2"; Action = "View Projects"; Path = "/project" }
                    @{ Index = "3"; Action = "Reports"; Path = "/reports" }
                    @{ Index = "4"; Action = "Settings"; Path = "/settings" }
                    @{ Index = "0"; Action = "Exit"; Path = "/exit" }
                )
                
                # Capture services for component callbacks
                $capturedServices = $services
                
                $navigationMenu = New-TuiDataTable -Props @{
                    Name = "navigationMenu"
                    IsFocusable = $true
                    ShowBorder = $true
                    BorderStyle = "Double"
                    Title = " Main Menu "
                    Height = [Math]::Min(15, $menuItems.Count + 4)
                    Width = 50
                    Columns = @(
                        @{ Name = "Index"; Width = 5; Align = "Center" }
                        @{ Name = "Action"; Width = 40; Align = "Left" }
                    )
                    Data = $menuItems
                    OnRowSelect = {
                        param($SelectedData, $SelectedIndex)
                        
                        if (-not $SelectedData) {
                            Write-Log -Level Warning -Message "Dashboard: OnRowSelect called with null data"
                            return
                        }
                        
                        $path = $SelectedData.Path
                        if ([string]::IsNullOrWhiteSpace($path)) {
                            Write-Log -Level Warning -Message "Dashboard: No path in selected data"
                            return
                        }
                        
                        Write-Log -Level Info -Message "Dashboard: Navigating to $path"
                        
                        if ($path -eq "/exit") {
                            Stop-TuiEngine
                            return
                        }
                        
                        & $capturedServices.Navigation.GoTo -self $capturedServices.Navigation -Path $path -Services $capturedServices
                    }
                }
                
                & $navigationMenu.ProcessData -self $navigationMenu
                & $rootPanel.AddChild -self $rootPanel -Child $navigationMenu | Out-Null
                $self.Components.navigationMenu = $navigationMenu
                $self._navigationMenu = $navigationMenu
                
                # Add dynamic stats label
                $statsLabel = New-TuiTextBlock -Props @{
                    Name = "statsLabel"
                    Text = "Loading stats..."
                    Margin = @{ Top = 1 }
                    Width = "100%"
                    HorizontalAlignment = "Center"
                }
                & $rootPanel.AddChild -self $rootPanel -Child $statsLabel | Out-Null
                $self.Components.statsLabel = $statsLabel
                
                # Add status label at bottom
                $footerLabel = New-TuiTextBlock -Props @{
                    Text = "Press ESC to return to this menu from any screen"
                    Height = 1
                    Width = "100%"
                    Margin = @{ Top = 1 }
                }
                & $rootPanel.AddChild -self $rootPanel -Child $footerLabel | Out-Null
                
                # Helper function to refresh dynamic data on the dashboard
                $self.RefreshDashboardStats = {
                    param($self)
                    Invoke-WithErrorHandling -Component "Dashboard.RefreshStats" -OperationName "RefreshStats" -ScriptBlock {
                        $openTasks = 0
                        if ($global:Data -and $global:Data.Tasks) {
                            # Access the .Completed property of each [PmcTask] object
                            $openTasks = ($global:Data.Tasks.Where({ -not $_.Completed })).Count
                        }
                        $self.Components.statsLabel.Text = "Open Tasks: $openTasks"
                        Request-TuiRefresh
                    }
                }
                
                # Subscribe to data changes to keep the dashboard live
                $subscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler {
                    Write-Log -Level Debug -Message "Dashboard received Tasks.Changed event"
                    & $self.RefreshDashboardStats -self $self
                } -Source "DashboardScreen"
                $self._subscriptions += $subscriptionId
                
                # Initial data load
                & $self.RefreshDashboardStats -self $self
                
                # Set initial focus
                & $navigationMenu.Focus -self $navigationMenu
                
                Write-Log -Level Info -Message "Dashboard Init: Completed successfully"
            }
        }
        
        HandleInput = {
            param($self, $key)
            
            if (-not $key) { return $false }
            
            Invoke-WithErrorHandling -Component "Dashboard.HandleInput" -OperationName "HandleInput" -ScriptBlock {
                if (-not $self._navigationMenu) {
                    Write-Log -Level Warning -Message "Dashboard HandleInput: Navigation menu not available"
                    return $false
                }
                
                # Handle number key shortcuts
                if ($key.KeyChar -match '[0-4]') {
                    $index = [int]$key.KeyChar
                    
                    $menuData = @($self._navigationMenu.Data)
                    
                    if ($index -eq 0) {
                        Write-Log -Level Info -Message "Dashboard: Exit via hotkey"
                        Stop-TuiEngine
                        return $true
                    }
                    
                    $selectedItem = $menuData | Where-Object { $_.Index -eq $index.ToString() }
                    if ($selectedItem -and $self._services -and $self._services.Navigation) {
                        & $self._services.Navigation.GoTo -self $self._services.Navigation -Path $selectedItem.Path -Services $self._services
                        return $true
                    }
                }
                
                # Pass other keys to the menu
                if ($self._navigationMenu.HandleInput) {
                    return & $self._navigationMenu.HandleInput -self $self._navigationMenu -key $key
                }
                
                return $false
            }
        }
        
        OnEnter = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnEnter"
            
            # Ensure focus on menu and refresh stats in case data changed while away
            if ($self._navigationMenu -and $self._navigationMenu.Focus) {
                & $self._navigationMenu.Focus -self $self._navigationMenu
            }
            if ($self.RefreshDashboardStats) {
                & $self.RefreshDashboardStats -self $self
            }
            Request-TuiRefresh
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnExit: Cleaning up"
            
            Invoke-WithErrorHandling -Component "Dashboard.OnExit" -OperationName "Cleanup" -ScriptBlock {
                # Unsubscribe from all events to prevent memory leaks
                if ($self._subscriptions -and @($self._subscriptions).Count -gt 0) {
                    foreach ($subId in $self._subscriptions) {
                        if ($subId) {
                            try {
                                Unsubscribe-Event -HandlerId $subId
                                Write-Log -Level Debug -Message "Dashboard unsubscribed from event: $subId"
                            }
                            catch {
                                Write-Log -Level Warning -Message "Dashboard failed to unsubscribe from event $subId : $_"
                            }
                        }
                    }
                    $self._subscriptions = @()
                }
            }
        }
        
        Render = {
            param($self)
            # The panel and components handle their own rendering
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen


####\screens\task-screen.psm1
#
# FILE: screens/task-screen.psm1
# PURPOSE: Task Screen Module - Refactored for Service-Oriented Architecture
# AI: This file has been corrected to use the proper DataTable component and its corresponding methods.
#

using module '.\models.psm1'
using module '.\components\advanced-data-components.psm1' # AI: Added required module for New-TuiDataTable

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Get-TaskManagementScreen {
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Services
    )
    
    Invoke-WithErrorHandling -Component "TaskScreen.Factory" -Context "Creating Task Management Screen" -ScriptBlock {
        # Validate services parameter
        if (-not $Services) {
            throw "Services parameter is required for task management screen"
        }
        
        if (-not $Services.DataManager) {
            throw "DataManager service is required but not found in services"
        }
        
        $screen = @{
            Name = "TaskManagementScreen"
            Components = @{}
            Children = @()
            _subscriptions = @()
            _services = $Services
            _formMode = $null  # null = list view, "create" = new task, "edit" = edit task
            _selectedTask = $null
            _focusIndex = 0
            _formFocusableComponents = @()
            Visible = $true
            ZIndex = 0
            
            Init = {
                param($self)
                
                Invoke-WithErrorHandling -Component "TaskScreen.Init" -Context "Initializing Task Screen" -ScriptBlock {
                    $services = $self._services
                    Write-Log -Level Info -Message "Task Screen Init: Starting initialization"
                    
                    # Create root panel
                    $rootPanel = New-TuiStackPanel -Props @{
                        Name = "TaskScreenRoot"
                        Orientation = "Vertical"
                        Width = $global:TuiState.BufferWidth
                        Height = $global:TuiState.BufferHeight
                    }
                    
                    # Create list view panel
                    $listPanel = New-TuiStackPanel -Props @{
                        Name = "TaskListView"
                        Orientation = "Vertical"
                        Width = "100%"
                        Height = "100%"
                        Visible = $true
                    }
                    
                    # Create header for list view
                    $headerPanel = New-TuiStackPanel -Props @{
                        Orientation = "Horizontal"
                        Width = "100%"
                        Height = 3
                        Padding = 1
                    }
                    
                    $titleLabel = New-TuiLabel -Props @{
                        Text = " Task Management "
                    }
                    
                    $actionsLabel = New-TuiLabel -Props @{
                        Text = "[N]ew  [E]dit  [D]elete  [Space]Toggle  [Esc]Back"
                    }
                    
                    & $headerPanel.AddChild -self $headerPanel -Child $titleLabel
                    & $headerPanel.AddChild -self $headerPanel -Child $actionsLabel
                    & $listPanel.AddChild -self $listPanel -Child $headerPanel
                    
                    # AI: Corrected to use New-TuiDataTable and fixed column definitions
                    $taskTable = New-TuiDataTable -Props @{
                        Name = "TaskTable"
                        Width = "100%"
                        Height = $global:TuiState.BufferHeight - 5
                        Columns = @(
                            @{ Header = "✓"; Name = "Status"; Width = 3; Align = "Center"; Format = { param($value, $row) if ($row.Completed) { "✓" } else { "○" } } }
                            @{ Header = "Title"; Name = "Title"; Width = 40 }
                            @{ Header = "Priority"; Name = "Priority"; Width = 10 }
                            @{ Header = "Category"; Name = "Category"; Width = 20 }
                            @{ Header = "Due Date"; Name = "DueDate"; Width = 12; Format = { param($value) if ($value) { $value.ToString("yyyy-MM-dd") } else { "N/A" } } }
                        )
                        Data = @()
                        ShowHeader = $true
                        IsFocusable = $true
                    }
                    
                    & $listPanel.AddChild -self $listPanel -Child $taskTable
                    & $rootPanel.AddChild -self $rootPanel -Child $listPanel
                    
                    # Create form view panel (initially hidden)
                    $formPanel = New-TuiStackPanel -Props @{
                        Name = "TaskFormView"
                        Orientation = "Vertical"
                        Width = "100%"
                        Height = "100%"
                        Visible = $false
                        Padding = 2
                        ShowBorder = $true
                    }
                    
                    # Form title is set dynamically
                    
                    # Create form fields
                    $titleInput = New-TuiTextBox -Props @{ Name = "TitleInput"; Width = 50; IsFocusable = $true }
                    $descInput = New-TuiTextArea -Props @{ Name = "DescInput"; Width = 50; Height = 5; IsFocusable = $true }
                    $priorityDropdown = New-TuiDropdown -Props @{ Name = "PriorityDropdown"; Width = 20; Options = @(@{Display="Low";Value="low"},@{Display="Medium";Value="medium"},@{Display="High";Value="high"}); Value = "medium"; IsFocusable = $true }
                    $categoryInput = New-TuiTextBox -Props @{ Name = "CategoryInput"; Width = 50; Text = "General"; IsFocusable = $true }
                    $dueDateInput = New-TuiTextBox -Props @{ Name = "DueDateInput"; Width = 20; Placeholder = "yyyy-MM-dd"; IsFocusable = $true }
                    
                    # Form buttons
                    $buttonPanel = New-TuiStackPanel -Props @{ Orientation = "Horizontal"; Width = "100%"; Height = 3; Spacing = 2; Margin = 1 }
                    
                    $capturedSelf = $self
                    
                    $saveButton = New-TuiButton -Props @{ Text = "[S]ave"; IsFocusable = $true; OnClick = { & $capturedSelf.SaveTask -self $capturedSelf } }
                    $cancelButton = New-TuiButton -Props @{ Text = "[C]ancel"; IsFocusable = $true; OnClick = { & $capturedSelf.ShowListView -self $capturedSelf } }
                    
                    & $buttonPanel.AddChild -self $buttonPanel -Child $saveButton
                    & $buttonPanel.AddChild -self $buttonPanel -Child $cancelButton
                    
                    # Add all form fields to form panel
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Title:" })
                    & $formPanel.AddChild -self $formPanel -Child $titleInput
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Description:" })
                    & $formPanel.AddChild -self $formPanel -Child $descInput
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Priority:" })
                    & $formPanel.AddChild -self $formPanel -Child $priorityDropdown
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Category:" })
                    & $formPanel.AddChild -self $formPanel -Child $categoryInput
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Due Date:" })
                    & $formPanel.AddChild -self $formPanel -Child $dueDateInput
                    & $formPanel.AddChild -self $formPanel -Child $buttonPanel
                    
                    & $rootPanel.AddChild -self $rootPanel -Child $formPanel
                    
                    # Store component references
                    $self.Components.rootPanel = $rootPanel
                    $self.Components.listPanel = $listPanel
                    $self.Components.formPanel = $formPanel
                    $self.Components.taskTable = $taskTable
                    $self.Components.titleInput = $titleInput
                    $self.Components.descInput = $descInput
                    $self.Components.priorityDropdown = $priorityDropdown
                    $self.Components.categoryInput = $categoryInput
                    $self.Components.dueDateInput = $dueDateInput
                    $self.Components.saveButton = $saveButton
                    $self.Components.cancelButton = $cancelButton
                    
                    $self._formFocusableComponents = @($titleInput, $descInput, $priorityDropdown, $categoryInput, $dueDateInput, $saveButton, $cancelButton)
                    
                    # Helper functions
                    $self.ShowListView = {
                        param($self)
                        $self._formMode = $null
                        $self._selectedTask = $null
                        $self._focusIndex = 0
                        $self.Components.listPanel.Visible = $true
                        $self.Components.formPanel.Visible = $false
                        Request-Focus -Component $self.Components.taskTable
                        Request-TuiRefresh
                    }
                    
                    $self.ShowFormView = {
                        param($self, $mode, $task)
                        $self._formMode = $mode
                        $self._selectedTask = $task
                        $self._focusIndex = 0
                        
                        $self.Components.formPanel.Title = if ($mode -eq "create") { " New Task " } else { " Edit Task " }
                        
                        if ($mode -eq "create") {
                            $self.Components.titleInput.Text = ""
                            $self.Components.descInput.Text = ""
                            $self.Components.priorityDropdown.Value = "medium"
                            $self.Components.categoryInput.Text = "General"
                            $self.Components.dueDateInput.Text = ""
                        } elseif ($task) {
                            $self.Components.titleInput.Text = $task.Title
                            $self.Components.descInput.Text = $task.Description
                            $self.Components.priorityDropdown.Value = $task.Priority.ToString().ToLower()
                            $self.Components.categoryInput.Text = $task.Category
                            $self.Components.dueDateInput.Text = if ($task.DueDate) { $task.DueDate.ToString('yyyy-MM-dd') } else { '' }
                        }
                        
                        $self.Components.listPanel.Visible = $false
                        $self.Components.formPanel.Visible = $true
                        Request-Focus -Component $self.Components.titleInput
                        Request-TuiRefresh
                    }
                    
                    $self.SaveTask = {
                        param($self)
                        Invoke-WithErrorHandling -Component "TaskScreen.SaveTask" -Context "Saving task data" -ScriptBlock {
                            $title = $self.Components.titleInput.Text
                            if ([string]::IsNullOrWhiteSpace($title)) {
                                Show-AlertDialog -Title "Validation Error" -Message "Title is required"
                                return
                            }
                            
                            $taskData = @{
                                Title = $title.Trim()
                                Description = $self.Components.descInput.Text
                                Priority = $self.Components.priorityDropdown.Value
                                Category = $self.Components.categoryInput.Text
                                DueDate = $self.Components.dueDateInput.Text
                            }
                            
                            if ($self._formMode -eq "create") {
                                & $self._services.DataManager.AddTask @taskData
                            } elseif ($self._formMode -eq "edit" -and $self._selectedTask) {
                                & $self._services.DataManager.UpdateTask -Task $self._selectedTask @taskData
                            }
                            
                            & $self.ShowListView -self $self
                        }
                    }
                    
                    $self.RefreshTaskList = {
                        param($self)
                        Invoke-WithErrorHandling -Component "TaskScreen.RefreshTaskList" -Context "Refreshing task list from global data" -ScriptBlock {
                            $tasks = if ($global:Data -and $global:Data.Tasks) { $global:Data.Tasks } else { @() }
                            $self.Components.taskTable.Data = $tasks
                            & $self.Components.taskTable.ProcessData -self $self.Components.taskTable
                            Request-TuiRefresh
                        }
                    }
                    
                    $subscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler { & $self.RefreshTaskList -self $self } -Source "TaskManagementScreen"
                    $self._subscriptions += $subscriptionId
                    
                    & $self.RefreshTaskList -self $self
                    $self.Children = @($rootPanel)
                    Request-Focus -Component $taskTable
                }
            }
            
            HandleInput = {
                param($self, $key)
                
                if (-not $key) { return $false }
                
                Invoke-WithErrorHandling -Component "TaskScreen.HandleInput" -Context "Handling user input" -ScriptBlock {
                    if ($self._formMode) {
                        # AI: Form input handling
                        if ($key.Key -eq "Tab") {
                            $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                            $self._focusIndex = ($self._focusIndex + $direction + $self._formFocusableComponents.Count) % $self._formFocusableComponents.Count
                            Request-Focus -Component $self._formFocusableComponents[$self._focusIndex]
                            return $true
                        }
                        
                        $focusedComponent = $self._formFocusableComponents[$self._focusIndex]
                        if ($focusedComponent.HandleInput) {
                            return & $focusedComponent.HandleInput -self $focusedComponent -key $key
                        }
                    }
                    else {
                        # AI: List view input handling, simplified with a switch
                        switch -CaseSensitive ($key.KeyChar) {
                            'n' { & $self.ShowFormView -self $self -mode "create"; return $true }
                            'e' {
                                # AI: Corrected way to get selected data
                                $table = $self.Components.taskTable
                                $selectedTask = if ($table.ProcessedData.Count -gt 0) { $table.ProcessedData[$table.SelectedRow] } else { $null }
                                if ($selectedTask) { & $self.ShowFormView -self $self -mode "edit" -task $selectedTask }
                                return $true
                            }
                            'd' {
                                $table = $self.Components.taskTable
                                $selectedTask = if ($table.ProcessedData.Count -gt 0) { $table.ProcessedData[$table.SelectedRow] } else { $null }
                                if ($selectedTask) { & $self._services.DataManager.RemoveTask -Task $selectedTask }
                                return $true
                            }
                        }

                        if ($key.Key -eq "Spacebar") {
                            $table = $self.Components.taskTable
                            $selectedTask = if ($table.ProcessedData.Count -gt 0) { $table.ProcessedData[$table.SelectedRow] } else { $null }
                            if ($selectedTask) {
                                & $self._services.DataManager.UpdateTask -Task $selectedTask -Completed (-not $selectedTask.Completed)
                            }
                            return $true
                        }
                        
                        if ($key.Key -eq "Escape") {
                            & $self._services.Navigation.GoTo -self $self._services.Navigation -Path "/dashboard" -Services $self._services
                            return $true
                        }
                        
                        # Pass other keys to the task table
                        if ($self.Components.taskTable.HandleInput) {
                            return & $self.Components.taskTable.HandleInput -self $self.Components.taskTable -key $key
                        }
                    }
                    
                    return $false
                }
            }
            
            OnExit = {
                param($self)
                Invoke-WithErrorHandling -Component "TaskScreen.OnExit" -Context "Cleaning up Task Screen" -ScriptBlock {
                    foreach ($subId in $self._subscriptions) {
                        if ($subId) { Unsubscribe-Event -HandlerId $subId }
                    }
                    $self._subscriptions = @()
                    $self.Components = @{}
                    $self._formFocusableComponents = @()
                    Write-Log -Level Info -Message "Task Screen cleanup completed"
                }
            }
        }
        
        return $screen
    }
}

# Alias for backward compatibility if needed
function Get-TaskScreen {
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Services
    )
    return Get-TaskManagementScreen -Services $Services
}

Export-ModuleMember -Function @('Get-TaskManagementScreen', 'Get-TaskScreen')


####\services\app-store.psm1
# FILE: services/app-store.psm1
# PURPOSE: Provides a single, reactive source of truth for all shared application state using a Redux-like pattern.

function Initialize-AppStore {
    param(
        [hashtable]$InitialData = @{},
        [bool]$EnableDebugLogging = $false
    )
    
    # Initialize state structure properly
    $stateData = if ($InitialData) { $InitialData.Clone() } else { @{} }
    
    $store = @{
        _state = @{
            _data = $stateData
            _subscribers = @{}
            _changeQueue = @()
        }
        _actions = @{}
        _middleware = @()
        _history = @()  # For time-travel debugging
        _enableDebugLogging = $EnableDebugLogging
        
        GetState = { 
            param($self, [string]$path = $null) 
            if ([string]::IsNullOrEmpty($path)) {
                # Directly access state data
                return $self._state._data
            }
            # Navigate path manually
            $parts = $path -split '\.'
            $current = $self._state._data
            foreach ($part in $parts) {
                if ($null -eq $current) { return $null }
                $current = $current[$part]
            }
            return $current
        }
        
        Subscribe = { 
            param($self, [string]$path, [scriptblock]$handler, [bool]$DeferInitialCall = $false) 
            if (-not $handler) { throw "Handler scriptblock is required for Subscribe" }
            
            # Manually implement subscribe to avoid $this issues
            $state = $self._state
            $subId = [Guid]::NewGuid().ToString()
            
            if (-not $state._subscribers) { $state._subscribers = @{} }
            if (-not $state._subscribers.ContainsKey($path)) {
                $state._subscribers[$path] = @()
            }
            
            $state._subscribers[$path] += @{
                Id = $subId
                Handler = $handler
            }
            
            # Call handler with current value unless deferred
            if (-not $DeferInitialCall) {
                $currentValue = & $self.GetState -self $self -path $path
                try {
                    & $handler @{ NewValue = $currentValue; OldValue = $null; Path = $path }
                } catch {
                    Write-Warning "State subscriber error: $_"
                }
            }
            
            return $subId
        }
        
        Unsubscribe = { 
            param($self, $subId) 
            if ($subId -and $self._state._subscribers) {
                # Manually remove subscription
                foreach ($path in @($self._state._subscribers.Keys)) {
                    $self._state._subscribers[$path] = @($self._state._subscribers[$path] | Where-Object { $_.Id -ne $subId })
                    if ($self._state._subscribers[$path].Count -eq 0) {
                        $self._state._subscribers.Remove($path)
                    }
                }
            }
        }
        
        RegisterAction = { 
            param($self, [string]$actionName, [scriptblock]$scriptBlock) 
            if ([string]::IsNullOrWhiteSpace($actionName)) { throw "Action name cannot be empty" }
            if (-not $scriptBlock) { throw "Script block is required for action '$actionName'" }
            $self._actions[$actionName] = $scriptBlock 
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Registered action: $actionName" }
        }
        
        AddMiddleware = {
            param($self, [scriptblock]$middleware)
            $self._middleware += $middleware
        }
        
        Dispatch = {
            param($self, [string]$actionName, $payload = $null)
            
            if ([string]::IsNullOrWhiteSpace($actionName)) { return @{ Success = $false; Error = "Action name cannot be empty" } }
            
            $action = @{ Type = $actionName; Payload = $payload; Timestamp = [DateTime]::UtcNow }
            
            foreach ($mw in $self._middleware) {
                if ($null -ne $mw) {
                    $action = & $mw -Action $action -Store $self
                    if (-not $action) { return @{ Success = $false; Error = "Action cancelled by middleware" } }
                }
            }
            
            if (-not $self._actions.ContainsKey($actionName)) {
                if ($self._enableDebugLogging) { Write-Log -Level Warning -Message "Action '$actionName' not found." }
                return @{ Success = $false; Error = "Action '$actionName' not registered." }
            }
            
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Dispatching action '$actionName'" -Data $payload }
            
            try {
                $previousState = & $self.GetState -self $self
                
                # Create action context with fixed UpdateState
                $storeInstance = $self
                $actionContext = @{
                    GetState = { 
                        param($path = $null) 
                        $store = $storeInstance
                        if ($path) {
                            return & $store.GetState -self $store -path $path
                        } else {
                            return & $store.GetState -self $store
                        }
                    }.GetNewClosure()
                    
                    UpdateState = { 
                        param($updates) 
                        $store = $storeInstance
                        if (-not $updates -or $updates.Count -eq 0) { 
                            Write-Log -Level Debug -Message "UpdateState called with empty updates"
                            return 
                        }
                        
                        Write-Log -Level Debug -Message "UpdateState called with keys: $($updates.Keys -join ', ')"
                        
                        # Use direct update method that handles all the complexity
                        try {
                            & $store._directUpdateState -self $store -updates $updates
                            Write-Log -Level Debug -Message "UpdateState: Successfully updated state"
                        } catch {
                            Write-Log -Level Error -Message "UpdateState failed: $_"
                            throw
                        }
                    }.GetNewClosure()
                    
                    Dispatch = { 
                        param($name, $p = $null) 
                        $store = $storeInstance
                        return & $store.Dispatch -self $store -actionName $name -payload $p
                    }.GetNewClosure()
                }
                
                # Execute the action
                & $self._actions[$actionName] -Context $actionContext -Payload $payload
                
                # Update history
                if ($self._history.Count -gt 100) { $self._history = $self._history[-100..-1] }
                $self._history += @{ Action = $action; PreviousState = $previousState; NextState = (& $self.GetState -self $self) }
                
                return @{ Success = $true }
            } 
            catch {
                # Use PowerShell RuntimeException with attached context data to avoid type dependency issues
                $contextData = @{
                    ActionName = $actionName
                    Payload = $payload
                    OriginalException = $_.Exception.Message
                    Component = "AppStore"
                    OperationName = "Dispatch"
                    Timestamp = [DateTime]::UtcNow
                }
                
                $runtimeException = New-Object System.Management.Automation.RuntimeException("Error executing action '$actionName': $($_.Exception.Message)")
                $runtimeException.Data.Add("HeliosException", $contextData)
                
                if ($self._enableDebugLogging) { 
                    Write-Log -Level Error -Message "Action dispatch failed" -Data $contextData 
                }
                
                throw $runtimeException
            }
        }
        
        _updateState = { 
            param($self, [hashtable]$updates)
            if ($updates -and $self._state) {
                # Direct update implementation
                $state = $self._state
                foreach ($key in $updates.Keys) {
                    $oldValue = $state._data[$key]
                    $state._data[$key] = $updates[$key]
                    
                    if ($oldValue -ne $updates[$key] -and $state._subscribers -and $state._subscribers.ContainsKey($key)) {
                        foreach ($sub in $state._subscribers[$key]) {
                            try {
                                & $sub.Handler @{ NewValue = $updates[$key]; OldValue = $oldValue; Path = $key }
                            } catch {
                                Write-Warning "State notification error: $_"
                            }
                        }
                    }
                }
            }
        }
        
        _directUpdateState = {
            param($self, [hashtable]$updates)
            if (-not $updates -or $updates.Count -eq 0) { return }
            
            Write-Log -Level Debug -Message "_directUpdateState called with $($updates.Count) updates"
            
            # Ensure state structure exists
            $state = $self._state
            if (-not $state._data) { $state._data = @{} }
            
            # Helper function to set nested paths
            $setNestedValue = {
                param($obj, $path, $value)
                $parts = $path -split '\.'
                $current = $obj
                for ($i = 0; $i -lt $parts.Count - 1; $i++) {
                    if (-not $current.ContainsKey($parts[$i])) {
                        $current[$parts[$i]] = @{}
                    }
                    $current = $current[$parts[$i]]
                }
                $current[$parts[-1]] = $value
            }
            
            # Process updates
            foreach ($key in $updates.Keys) {
                $newValue = $updates[$key]
                
                if ($key.Contains('.')) {
                    # Handle nested paths like "stats.todayHours"
                    $oldValue = & $self.GetState -self $self -path $key
                    & $setNestedValue -obj $state._data -path $key -value $newValue
                } else {
                    # Handle simple keys
                    $oldValue = $state._data[$key]
                    $state._data[$key] = $newValue
                }
                
                # Notify subscribers for exact path
                if ($state._subscribers -and $state._subscribers.ContainsKey($key)) {
                    foreach ($sub in $state._subscribers[$key]) {
                        try {
                            & $sub.Handler @{ NewValue = $newValue; OldValue = $oldValue; Path = $key }
                        } catch {
                            Write-Warning "Subscriber notification error for '$key': $_"
                        }
                    }
                }
                
                # Also notify parent path subscribers for nested updates
                if ($key.Contains('.')) {
                    $parts = $key -split '\.'
                    $parentPath = $parts[0]
                    if ($state._subscribers -and $state._subscribers.ContainsKey($parentPath)) {
                        $parentValue = $state._data[$parentPath]
                        foreach ($sub in $state._subscribers[$parentPath]) {
                            try {
                                & $sub.Handler @{ NewValue = $parentValue; OldValue = $parentValue; Path = $parentPath }
                            } catch {
                                Write-Warning "Parent subscriber notification error for '$parentPath': $_"
                            }
                        }
                    }
                }
            }
        }
        
        GetHistory = { param($self) ; return $self._history }
        
        RestoreState = {
            param($self, [int]$stepsBack = 1)
            if ($stepsBack -gt $self._history.Count) { throw "Cannot go back $stepsBack steps. Only $($self._history.Count) actions in history." }
            $targetState = $self._history[-$stepsBack].PreviousState
            & $self._updateState -self $self -updates $targetState
        }
    }
    
    # Register built-in actions
    & $store.RegisterAction -self $store -actionName "RESET_STATE" -scriptBlock {
        param($Context, $Payload)
        & $Context.UpdateState $InitialData
    }
    
    & $store.RegisterAction -self $store -actionName "UPDATE_STATE" -scriptBlock {
        param($Context, $Payload)
        if ($Payload -is [hashtable]) {
            & $Context.UpdateState $Payload
        }
    }
    
    return $store
}

Export-ModuleMember -Function "Initialize-AppStore"


####\services\keybindings.psm1
@{
    # Module manifest for keybindings service
    RootModule = 'keybindings.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'c3d4e5f6-7a8b-9c0d-1e2f-3a4b5c6d7e8f'
    Author = 'PMC Terminal Team'
    CompanyName = 'PMC Terminal'
    Copyright = '(c) 2025 PMC Terminal. All rights reserved.'
    Description = 'Centralized keybinding management service with context support for PMC Terminal'
    
    # Minimum PowerShell version
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @('Initialize-KeybindingService')
    
    # Variables to export
    VariablesToExport = @()
    
    # Aliases to export
    AliasesToExport = @()
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Required modules
    RequiredModules = @()
    
    # Module dependencies that must be loaded
    NestedModules = @()
    
    # Private data
    PrivateData = @{
        PSData = @{
            Tags = @('Keybindings', 'Input', 'TUI', 'PMC')
            ProjectUri = 'https://github.com/pmc-terminal/pmc-terminal'
            ReleaseNotes = 'Initial release of keybinding service with context-aware bindings and chord support'
        }
    }
}
# FILE: services/keybindings.psm1
# PURPOSE: Centralizes keybinding logic to make them configurable and declarative.

function Initialize-KeybindingService {
    param(
        [hashtable]$CustomBindings = @{},
        [bool]$EnableChords = $false  # For future multi-key sequences
    )
    Invoke-WithErrorHandling -Component "KeybindingService.Initialize" -ScriptBlock {
        # Default keybindings - can be overridden
        $defaultKeyMap = @{
            # Application-level
            "App.Quit" = @{ Key = 'Q'; Modifiers = @() }
            "App.ForceQuit" = @{ Key = 'Q'; Modifiers = @('Ctrl') }
            "App.Back" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
            "App.Refresh" = @{ Key = 'R'; Modifiers = @() }
            "App.DebugLog" = @{ Key = [ConsoleKey]::F12; Modifiers = @() }
            "App.Help" = @{ Key = [ConsoleKey]::F1; Modifiers = @() }
            
            # List operations
            "List.New" = @{ Key = 'N'; Modifiers = @() }
            "List.Edit" = @{ Key = 'E'; Modifiers = @() }
            "List.Delete" = @{ Key = 'D'; Modifiers = @() }
            "List.Toggle" = @{ Key = [ConsoleKey]::Spacebar; Modifiers = @() }
            "List.SelectAll" = @{ Key = 'A'; Modifiers = @('Ctrl') }
            
            # Navigation
            "Nav.Up" = @{ Key = [ConsoleKey]::UpArrow; Modifiers = @() }
            "Nav.Down" = @{ Key = [ConsoleKey]::DownArrow; Modifiers = @() }
            "Nav.Left" = @{ Key = [ConsoleKey]::LeftArrow; Modifiers = @() }
            "Nav.Right" = @{ Key = [ConsoleKey]::RightArrow; Modifiers = @() }
            "Nav.PageUp" = @{ Key = [ConsoleKey]::PageUp; Modifiers = @() }
            "Nav.PageDown" = @{ Key = [ConsoleKey]::PageDown; Modifiers = @() }
            "Nav.Home" = @{ Key = [ConsoleKey]::Home; Modifiers = @() }
            "Nav.End" = @{ Key = [ConsoleKey]::End; Modifiers = @() }
            
            # Quick navigation (number keys)
            "QuickNav.1" = @{ Key = '1'; Modifiers = @() }
            "QuickNav.2" = @{ Key = '2'; Modifiers = @() }
            "QuickNav.3" = @{ Key = '3'; Modifiers = @() }
            "QuickNav.4" = @{ Key = '4'; Modifiers = @() }
            "QuickNav.5" = @{ Key = '5'; Modifiers = @() }
            "QuickNav.6" = @{ Key = '6'; Modifiers = @() }
            "QuickNav.7" = @{ Key = '7'; Modifiers = @() }
            "QuickNav.8" = @{ Key = '8'; Modifiers = @() }
            "QuickNav.9" = @{ Key = '9'; Modifiers = @() }
            
            # Form operations
            "Form.Submit" = @{ Key = [ConsoleKey]::Enter; Modifiers = @('Ctrl') }
            "Form.Cancel" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
            "Form.Clear" = @{ Key = 'C'; Modifiers = @('Ctrl', 'Shift') }
            
            # Text editing
            "Edit.Cut" = @{ Key = 'X'; Modifiers = @('Ctrl') }
            "Edit.Copy" = @{ Key = 'C'; Modifiers = @('Ctrl') }
            "Edit.Paste" = @{ Key = 'V'; Modifiers = @('Ctrl') }
            "Edit.Undo" = @{ Key = 'Z'; Modifiers = @('Ctrl') }
            "Edit.Redo" = @{ Key = 'Y'; Modifiers = @('Ctrl') }
        }
        
        # Merge custom bindings
        $keyMap = $defaultKeyMap
        foreach ($action in $CustomBindings.Keys) {
            $keyMap[$action] = $CustomBindings[$action]
        }
        
        $service = @{
            _keyMap = $keyMap
            _enableChords = $EnableChords
            _chordBuffer = @()
            _chordTimeout = 1000  # milliseconds
            _lastKeyTime = [DateTime]::MinValue
            _contextStack = @()  # For context-specific bindings
            _globalHandlers = @{}  # Action name -> handler scriptblock
            
            IsAction = {
                param(
                    $self,
                    [string]$ActionName, 
                    [System.ConsoleKeyInfo]$KeyInfo,
                    [string]$Context = $null
                )
                Invoke-WithErrorHandling -Component "KeybindingService.IsAction" -ScriptBlock {
                    if ([string]::IsNullOrWhiteSpace($ActionName)) { return $false }
                    
                    # Check context-specific binding first
                    $contextKey = if ($Context) { "$Context.$ActionName" } else { $null }
                    if ($contextKey -and $self._keyMap.ContainsKey($contextKey)) {
                        return (& $self._matchesBinding -self $self -binding $self._keyMap[$contextKey] -keyInfo $KeyInfo)
                    }
                    
                    # Check global binding
                    if (-not $self._keyMap.ContainsKey($ActionName)) { return $false }
                    
                    return (& $self._matchesBinding -self $self -binding $self._keyMap[$ActionName] -keyInfo $KeyInfo)
                } -Context @{ ActionName = $ActionName; KeyInfo = $KeyInfo; Context = $Context } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService IsAction error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            _matchesBinding = {
                param($self, $binding, $keyInfo)
                Invoke-WithErrorHandling -Component "KeybindingService._matchesBinding" -ScriptBlock {
                    # Match key
                    $keyMatches = $false
                    if ($binding.Key -is [System.ConsoleKey]) {
                        $keyMatches = $keyInfo.Key -eq $binding.Key
                    }
                    elseif ($binding.Key -is [string] -and $binding.Key.Length -eq 1) {
                        $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.Key, [System.StringComparison]::InvariantCultureIgnoreCase)
                    }
                    
                    if (-not $keyMatches) { return $false }
                    
                    # Match modifiers
                    $requiredModifiers = $binding.Modifiers ?? @()
                    $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
                    $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
                    $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
                    
                    $ctrlRequired = 'Ctrl' -in $requiredModifiers
                    $altRequired = 'Alt' -in $requiredModifiers
                    $shiftRequired = 'Shift' -in $requiredModifiers
                    
                    return ($hasCtrl -eq $ctrlRequired) -and 
                           ($hasAlt -eq $altRequired) -and 
                           ($hasShift -eq $shiftRequired)
                } -Context @{ Binding = $binding; KeyInfo = $KeyInfo } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService _matchesBinding error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            GetBinding = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.GetBinding" -ScriptBlock {
                    return $self._keyMap[$ActionName]
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetBinding error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            SetBinding = {
                param($self, [string]$ActionName, $Key, [string[]]$Modifiers = @())
                Invoke-WithErrorHandling -Component "KeybindingService.SetBinding" -ScriptBlock {
                    $self._keyMap[$ActionName] = @{ Key = $Key; Modifiers = $Modifiers }
                    Write-Log -Level Debug -Message "Set keybinding for '$ActionName': $Key + $($Modifiers -join '+')"
                } -Context @{ ActionName = $ActionName; Key = $Key; Modifiers = $Modifiers } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService SetBinding error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            RemoveBinding = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.RemoveBinding" -ScriptBlock {
                    $self._keyMap.Remove($ActionName)
                    Write-Log -Level Debug -Message "Removed keybinding for '$ActionName'"
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService RemoveBinding error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            GetBindingDescription = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.GetBindingDescription" -ScriptBlock {
                    if (-not $self._keyMap.ContainsKey($ActionName)) { return $null }
                    $binding = $self._keyMap[$ActionName]
                    $keyStr = if ($binding.Key -is [System.ConsoleKey]) { $binding.Key.ToString() } else { $binding.Key.ToString().ToUpper() }
                    if ($binding.Modifiers.Count -gt 0) { return "$($binding.Modifiers -join '+') + $keyStr" }
                    return $keyStr
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetBindingDescription error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            RegisterGlobalHandler = {
                param($self, [string]$ActionName, [scriptblock]$Handler)
                Invoke-WithErrorHandling -Component "KeybindingService.RegisterGlobalHandler" -ScriptBlock {
                    $self._globalHandlers[$ActionName] = $Handler
                    Write-Log -Level Debug -Message "Registered global handler for '$ActionName'"
                } -Context @{ ActionName = $ActionName } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService RegisterGlobalHandler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            HandleKey = {
                param($self, [System.ConsoleKeyInfo]$KeyInfo, [string]$Context = $null)
                Invoke-WithErrorHandling -Component "KeybindingService.HandleKey" -ScriptBlock {
                    foreach ($action in $self._keyMap.Keys) {
                        if ((& $self.IsAction -self $self -ActionName $action -KeyInfo $KeyInfo -Context $Context)) {
                            if ($self._globalHandlers.ContainsKey($action)) {
                                Write-Log -Level Debug -Message "Executing global handler for '$action'"
                                return (& $self._globalHandlers[$action] -KeyInfo $KeyInfo -Context $Context)
                            }
                            return $action
                        }
                    }
                    return $null
                } -Context @{ KeyInfo = $KeyInfo; Context = $Context } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService HandleKey error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            PushContext = {
                param($self, [string]$Context)
                Invoke-WithErrorHandling -Component "KeybindingService.PushContext" -ScriptBlock {
                    $self._contextStack += $Context
                    Write-Log -Level Debug -Message "Pushed keybinding context: $Context"
                } -Context @{ Context = $Context } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService PushContext error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            PopContext = {
                param($self)
                Invoke-WithErrorHandling -Component "KeybindingService.PopContext" -ScriptBlock {
                    if ($self._contextStack.Count -gt 0) {
                        $context = $self._contextStack[-1]
                        $self._contextStack = $self._contextStack[0..($self._contextStack.Count - 2)]
                        Write-Log -Level Debug -Message "Popped keybinding context: $context"
                        return $context
                    }
                    return $null
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService PopContext error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            GetCurrentContext = {
                param($self)
                Invoke-WithErrorHandling -Component "KeybindingService.GetCurrentContext" -ScriptBlock {
                    if ($self._contextStack.Count -gt 0) { return $self._contextStack[-1] }
                    return $null
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetCurrentContext error: $($Exception.Message)" -Data $Exception.Context
                    return $null
                }
            }
            
            GetAllBindings = {
                param($self, [bool]$GroupByCategory = $false)
                Invoke-WithErrorHandling -Component "KeybindingService.GetAllBindings" -ScriptBlock {
                    if (-not $GroupByCategory) { return $self._keyMap }
                    $grouped = @{}
                    foreach ($action in $self._keyMap.Keys) {
                        $parts = $action.Split('.')
                        $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
                        if (-not $grouped.ContainsKey($category)) { $grouped[$category] = @{} }
                        $grouped[$category][$action] = $self._keyMap[$action]
                    }
                    return $grouped
                } -Context @{ GroupByCategory = $GroupByCategory } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService GetAllBindings error: $($Exception.Message)" -Data $Exception.Context
                    return @{}
                }
            }
            
            ExportBindings = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "KeybindingService.ExportBindings" -ScriptBlock {
                    $self._keyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $Path
                    Write-Log -Level Info -Message "Exported keybindings to: $Path"
                } -Context @{ FilePath = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService ExportBindings error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            ImportBindings = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "KeybindingService.ImportBindings" -ScriptBlock {
                    if (Test-Path $Path) {
                        $imported = Get-Content $Path | ConvertFrom-Json
                        foreach ($prop in $imported.PSObject.Properties) {
                            $self._keyMap[$prop.Name] = @{
                                Key = $prop.Value.Key
                                Modifiers = $prop.Value.Modifiers
                            }
                        }
                        Write-Log -Level Info -Message "Imported keybindings from: $Path"
                    }
                } -Context @{ FilePath = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "KeybindingService ImportBindings error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        
        return $service
    } -Context @{ CustomBindings = $CustomBindings; EnableChords = $EnableChords } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Keybinding Service: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

Export-ModuleMember -Function "Initialize-KeybindingService"


####\services\navigation.psm1
# FILE: services/navigation.psm1
# PURPOSE: Decouples screens by managing all navigation through a centralized route map.

function Initialize-NavigationService {
    param(
        [hashtable]$CustomRoutes = @{},
        [bool]$EnableBreadcrumbs = $true
    )
    Invoke-WithErrorHandling -Component "NavigationService.Initialize" -ScriptBlock {
        # Default routes - can be overridden by CustomRoutes
        $defaultRoutes = @{
            "/dashboard" = @{ 
                Factory = { Get-DashboardScreen }
                Title = "Dashboard"
                RequiresAuth = $false
            }
            "/tasks" = @{ 
                Factory = { Get-TaskManagementScreen }
                Title = "Task Management"
                RequiresAuth = $false
            }
            "/timer/start" = @{ 
                Factory = { Get-TimerStartScreen }
                Title = "Timer"
                RequiresAuth = $false
            }
            "/timer/manage" = @{
                Factory = { Get-TimerManagementScreen }
                Title = "Timer Management"
                RequiresAuth = $false
            }
            "/reports" = @{ 
                Factory = { Get-ReportsScreen }
                Title = "Reports"
                RequiresAuth = $false
            }
            "/settings" = @{ 
                Factory = { Get-SettingsScreen }
                Title = "Settings"
                RequiresAuth = $false
            }
            "/projects" = @{ 
                Factory = { Get-ProjectManagementScreen }
                Title = "Projects"
                RequiresAuth = $false
            }
            "/log" = @{ 
                Factory = { Get-DebugLogScreen }
                Title = "Debug Log"
                RequiresAuth = $false
            }
            "/simple-test" = @{ # ADDED THIS ROUTE
                Factory = { Get-SimpleTestScreen }
                Title = "Simple Test"
                RequiresAuth = $false
            }
        }
        
        # Merge custom routes
        $routes = $defaultRoutes
        foreach ($key in $CustomRoutes.Keys) {
            $routes[$key] = $CustomRoutes[$key]
        }
        
        $service = @{
            _routes = $routes
            _history = @()  # Navigation history for back button
            _breadcrumbs = @()  # For UI breadcrumb display
            _beforeNavigate = @()  # Navigation guards
            _afterNavigate = @()  # Navigation hooks
            
            GoTo = {
                param(
                    $self,
                    [string]$Path,
                    [hashtable]$Params = @{},
                    [hashtable]$Services = $null
                )
                Invoke-WithErrorHandling -Component "NavigationService.GoTo" -ScriptBlock {
                    if ([string]::IsNullOrWhiteSpace($Path)) {
                        Write-Log -Level Error -Message "Navigation path cannot be empty"
                        return $false
                    }
                    
                    # Normalize path
                    if (-not $Path.StartsWith("/")) { $Path = "/$Path" }
                    
                    # Check if route exists
                    if (-not $self._routes.ContainsKey($Path)) {
                        $availableRoutes = ($self._routes.Keys | Sort-Object) -join ", "
                        $msg = "Route not found: $Path. Available routes: $availableRoutes"
                        Write-Log -Level Error -Message $msg
                        Show-AlertDialog -Title "Navigation Error" -Message "The screen '$Path' does not exist."
                        return $false
                    }
                    
                    $route = $self._routes[$Path]
                    
                    # Run before navigation guards
                    foreach ($guard in $self._beforeNavigate) {
                        try {
                            $canNavigate = & $guard -Path $Path -Route $route -Params $Params
                            if (-not $canNavigate) {
                                Write-Log -Level Debug -Message "Navigation to '$Path' cancelled by guard"
                                return $false
                            }
                        } catch {
                            Write-Log -Level Error -Message "Navigation guard failed for path '$Path': $_" -Data @{ Path = $Path; Guard = $guard; Exception = $_ }
                            Show-AlertDialog -Title "Navigation Error" -Message "A navigation check failed. Cannot proceed."
                            return $false
                        }
                    }
                    
                    # Check authentication if required
                    if ($route.RequiresAuth -and -not (& $self._checkAuth -self $self)) {
                        Write-Log -Level Warning -Message "Navigation to '$Path' requires authentication"
                        Show-AlertDialog -Title "Access Denied" -Message "You must be logged in to access this screen."
                        return $false
                    }
                    
                    try {
                        # Pass Services to factory if provided
                        if ($Services) {
                            $screen = & $route.Factory -Services $Services
                        } else {
                            $screen = & $route.Factory
                        }
                        if (-not $screen) { throw "Screen factory returned null for route '$Path'" }
                        
                        # CRITICAL: Ensure screen has services stored
                        if ($Services -and -not $screen._services) {
                            $screen._services = $Services
                        }
                        
                        if ($screen.SetParams -and $Params.Count -gt 0) { 
                            try {
                                & $screen.SetParams -self $screen -Params $Params 
                            } catch {
                                Write-Log -Level Error -Message "Screen SetParams failed for '$Path': $_" -Data @{ Path = $Path; Params = $Params; Exception = $_ }
                            }
                        }
                        
                        $self._history += @{ Path = $Path; Timestamp = [DateTime]::UtcNow; Params = $Params }
                        if ($EnableBreadcrumbs) { $self._breadcrumbs += @{ Path = $Path; Title = $route.Title ?? $Path } }
                        
                        Push-Screen -Screen $screen
                        
                        foreach ($hook in $self._afterNavigate) { 
                            try {
                                & $hook -Path $Path -Screen $screen 
                            } catch {
                                Write-Log -Level Error -Message "After navigation hook failed for path '$Path': $_" -Data @{ Path = $Path; Hook = $hook; Exception = $_ }
                            }
                        }
                        
                        Write-Log -Level Info -Message "Navigated to: $Path"
                        return $true
                    }
                    catch {
                        throw [NavigationException]::new(
                            "Failed to create or navigate to screen for route '$Path'",
                            @{
                                Route = $Path
                                RouteConfig = $route
                                OriginalException = $_
                            }
                        )
                    }
                } -Context @{ Path = $Path; Params = $Params } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GoTo error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                    Show-AlertDialog -Title "Navigation Error" -Message "Failed to navigate to '$($Exception.Context.Path)': $($Exception.Message)"
                    return $false
                }
            }
            
            Back = { 
                param($self, [int]$Steps = 1)
                Invoke-WithErrorHandling -Component "NavigationService.Back" -ScriptBlock {
                    for ($i = 0; $i -lt $Steps; $i++) {
                        if ($global:TuiState.ScreenStack.Count -le 1) {
                            Write-Log -Level Debug -Message "Cannot go back - at root screen"
                            return $false
                        }
                        Pop-Screen
                        if ($EnableBreadcrumbs -and $self._breadcrumbs.Count -gt 0) {
                            $self._breadcrumbs = $self._breadcrumbs[0..($self._breadcrumbs.Count - 2)]
                        }
                    }
                    return $true
                } -Context @{ Steps = $Steps } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService Back error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            GetCurrentPath = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetCurrentPath" -ScriptBlock {
                    if ($self._history.Count -eq 0) { return "/" }
                    return $self._history[-1].Path
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GetCurrentPath error: $($Exception.Message)" -Data $Exception.Context
                    return "/"
                }
            }
            
            GetBreadcrumbs = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetBreadcrumbs" -ScriptBlock {
                    return $self._breadcrumbs
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GetBreadcrumbs error: $($Exception.Message)" -Data $Exception.Context
                    return @()
                }
            }
            
            AddRoute = {
                param($self, [string]$Path, [hashtable]$RouteConfig)
                Invoke-WithErrorHandling -Component "NavigationService.AddRoute" -ScriptBlock {
                    if (-not $RouteConfig.Factory) { throw "Route must have a Factory scriptblock" }
                    $self._routes[$Path] = $RouteConfig
                    Write-Log -Level Debug -Message "Added route: $Path"
                } -Context @{ Path = $Path; RouteConfig = $RouteConfig } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService AddRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            RegisterRoute = {
                param($self, [string]$Path, [scriptblock]$ScreenFactory)
                Invoke-WithErrorHandling -Component "NavigationService.RegisterRoute" -ScriptBlock {
                    # Convert the simpler RegisterRoute format to the AddRoute format
                    $routeConfig = @{
                        Factory = $ScreenFactory
                        Title = $Path.Substring(1).Replace('/', ' ').Replace('-', ' ')
                        RequiresAuth = $false
                    }
                    # Call AddRoute with the proper format
                    & $self.AddRoute -self $self -Path $Path -RouteConfig $routeConfig
                    Write-Log -Level Debug -Message "Registered route: $Path"
                } -Context @{ Path = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService RegisterRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            RemoveRoute = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "NavigationService.RemoveRoute" -ScriptBlock {
                    $self._routes.Remove($Path)
                    Write-Log -Level Debug -Message "Removed route: $Path"
                } -Context @{ Path = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService RemoveRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            AddBeforeNavigateGuard = {
                param($self, [scriptblock]$Guard)
                Invoke-WithErrorHandling -Component "NavigationService.AddBeforeNavigateGuard" -ScriptBlock {
                    $self._beforeNavigate += $Guard
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService AddBeforeNavigateGuard error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            AddAfterNavigateHook = {
                param($self, [scriptblock]$Hook)
                Invoke-WithErrorHandling -Component "NavigationService.AddAfterNavigateHook" -ScriptBlock {
                    $self._afterNavigate += $Hook
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService AddAfterNavigateHook error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            _checkAuth = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService._checkAuth" -ScriptBlock {
                    # Placeholder for authentication check
                    return $true
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService _checkAuth error: $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
            
            GetRoutes = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetRoutes" -ScriptBlock {
                    return $self._routes.Keys | Sort-Object
                } -Context @{} -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService GetRoutes error: $($Exception.Message)" -Data $Exception.Context
                    return @()
                }
            }
            
            IsValidRoute = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "NavigationService.IsValidRoute" -ScriptBlock {
                    return $self._routes.ContainsKey($Path)
                } -Context @{ Path = $Path } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "NavigationService IsValidRoute error for path '$($Exception.Context.Path)': $($Exception.Message)" -Data $Exception.Context
                    return $false
                }
            }
        }
        
        return $service
    } -Context @{ CustomRoutes = $CustomRoutes; EnableBreadcrumbs = $EnableBreadcrumbs } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Navigation Service: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

Export-ModuleMember -Function "Initialize-NavigationService"


####\services\task-services.psm1
# Task Service Module
# Manages all state and business logic related to tasks
# Replaces the old app-store pattern for task management

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Initialize-TaskService {
    <#
    .SYNOPSIS
    Initializes the Task Service with PowerShell-First architecture
    
    .DESCRIPTION
    Creates and returns a service object that manages task state and operations.
    Uses PowerShell's native eventing engine for state change notifications.
    
    .OUTPUTS
    [PSCustomObject] The initialized Task Service instance
    #>
    
    Invoke-WithErrorHandling -Component "TaskService.Initialize" -Context @{} -ScriptBlock {
        Write-Log -Level Info -Message "Initializing Task Service"
        
        # Create the service object
        $service = [PSCustomObject]@{
            _tasks = @()  # Private array to hold tasks
            _isInitialized = $false
        }
        
        # Register the service's events with PowerShell's native engine
        Register-EngineEvent -SourceIdentifier "TaskService" -SupportEvent
        Write-Log -Level Debug -Message "Registered TaskService engine event"
        
        # AddTask method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "AddTask" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [hashtable]$taskData
            )
            
            Invoke-WithErrorHandling -Component "TaskService.AddTask" -Context @{ TaskData = $taskData } -ScriptBlock {
                # Defensive validation
                if (-not $taskData) {
                    Write-Log -Level Warning -Message "AddTask: No task data provided"
                    return
                }
                
                if (-not $taskData.Title -or [string]::IsNullOrWhiteSpace($taskData.Title)) {
                    Write-Log -Level Warning -Message "AddTask: No title provided"
                    return
                }
                
                Write-Log -Level Info -Message "Adding new task: $($taskData.Title)"
                
                # Create new task with all required fields
                $newTask = @{
                    id = [Guid]::NewGuid().ToString()
                    title = $taskData.Title.Trim()
                    description = if ($taskData.Description) { $taskData.Description } else { "" }
                    completed = $false
                    priority = if ($taskData.Priority) { $taskData.Priority } else { "medium" }
                    project = if ($taskData.Category) { $taskData.Category } else { "General" }
                    due_date = if ($taskData.DueDate) { $taskData.DueDate } else { $null }
                    created_at = (Get-Date).ToString("o")
                    updated_at = (Get-Date).ToString("o")
                }
                
                # Add to internal task array
                $this._tasks = @($this._tasks) + $newTask
                
                Write-Log -Level Debug -Message "Task created with ID: $($newTask.id)"
                
                # Persist if data manager available
                if ($global:Data) {
                    if (-not $global:Data.ContainsKey('Tasks')) {
                        $global:Data.Tasks = @()
                    }
                    $global:Data.Tasks = @($global:Data.Tasks) + $newTask
                    
                    if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                        Save-UnifiedData
                        Write-Log -Level Debug -Message "Task data persisted"
                    }
                }
                
                # Announce state change using native PowerShell eventing
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Tasks.Changed" -MessageData @{
                    Action = "TaskAdded"
                    TaskId = $newTask.id
                    Task = $newTask
                }
                
                Write-Log -Level Info -Message "Task added successfully: $($newTask.id)"
                return $newTask
            }
        }
        
        # UpdateTask method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "UpdateTask" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [string]$taskId,
                
                [Parameter(Mandatory = $true)]
                [hashtable]$updates
            )
            
            Invoke-WithErrorHandling -Component "TaskService.UpdateTask" -Context @{ TaskId = $taskId; Updates = $updates } -ScriptBlock {
                # Defensive validation
                if (-not $taskId) {
                    Write-Log -Level Warning -Message "UpdateTask: No TaskId provided"
                    return
                }
                
                if (-not $updates -or $updates.Count -eq 0) {
                    Write-Log -Level Warning -Message "UpdateTask: No updates provided"
                    return
                }
                
                Write-Log -Level Info -Message "Updating task: $taskId"
                
                # Find task in internal array
                $taskIndex = -1
                for ($i = 0; $i -lt $this._tasks.Count; $i++) {
                    if ($this._tasks[$i].id -eq $taskId) {
                        $taskIndex = $i
                        break
                    }
                }
                
                if ($taskIndex -eq -1) {
                    Write-Log -Level Warning -Message "UpdateTask: Task not found with ID $taskId"
                    return
                }
                
                # Update task fields
                $task = $this._tasks[$taskIndex]
                if ($updates.ContainsKey('Title') -and $updates.Title) { 
                    $task.title = $updates.Title.Trim() 
                }
                if ($updates.ContainsKey('Description')) { 
                    $task.description = $updates.Description 
                }
                if ($updates.ContainsKey('Priority')) { 
                    $task.priority = $updates.Priority 
                }
                if ($updates.ContainsKey('Category')) { 
                    $task.project = $updates.Category 
                }
                if ($updates.ContainsKey('DueDate')) { 
                    $task.due_date = $updates.DueDate 
                }
                if ($updates.ContainsKey('Completed')) { 
                    $task.completed = $updates.Completed 
                }
                
                $task.updated_at = (Get-Date).ToString("o")
                
                Write-Log -Level Debug -Message "Task updated: $taskId"
                
                # Update in global data if available
                if ($global:Data -and $global:Data.Tasks) {
                    $globalIndex = -1
                    for ($i = 0; $i -lt $global:Data.Tasks.Count; $i++) {
                        if ($global:Data.Tasks[$i].id -eq $taskId) {
                            $globalIndex = $i
                            break
                        }
                    }
                    
                    if ($globalIndex -ne -1) {
                        $global:Data.Tasks[$globalIndex] = $task
                        
                        if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                            Save-UnifiedData
                            Write-Log -Level Debug -Message "Task data persisted"
                        }
                    }
                }
                
                # Announce state change using native PowerShell eventing
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Tasks.Changed" -MessageData @{
                    Action = "TaskUpdated"
                    TaskId = $taskId
                    Task = $task
                    Updates = $updates
                }
                
                Write-Log -Level Info -Message "Task updated successfully: $taskId"
                return $task
            }
        }
        
        # DeleteTask method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "DeleteTask" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [string]$taskId
            )
            
            Invoke-WithErrorHandling -Component "TaskService.DeleteTask" -Context @{ TaskId = $taskId } -ScriptBlock {
                # Defensive validation
                if (-not $taskId) {
                    Write-Log -Level Warning -Message "DeleteTask: No TaskId provided"
                    return $false
                }
                
                Write-Log -Level Info -Message "Deleting task: $taskId"
                
                # Find and remove from internal array
                $originalCount = $this._tasks.Count
                $deletedTask = $null
                
                $newTasks = @()
                foreach ($task in $this._tasks) {
                    if ($task.id -eq $taskId) {
                        $deletedTask = $task
                    } else {
                        $newTasks += $task
                    }
                }
                
                $this._tasks = $newTasks
                
                if (-not $deletedTask) {
                    Write-Log -Level Warning -Message "DeleteTask: Task not found with ID $taskId"
                    return $false
                }
                
                Write-Log -Level Debug -Message "Task removed from internal array: $taskId"
                
                # Remove from global data if available
                if ($global:Data -and $global:Data.Tasks) {
                    $global:Data.Tasks = @($global:Data.Tasks | Where-Object { 
                        $_ -and $_.id -ne $taskId 
                    })
                    
                    if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                        Save-UnifiedData
                        Write-Log -Level Debug -Message "Task data persisted"
                    }
                }
                
                # Announce state change using native PowerShell eventing
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Tasks.Changed" -MessageData @{
                    Action = "TaskDeleted"
                    TaskId = $taskId
                    Task = $deletedTask
                }
                
                Write-Log -Level Info -Message "Task deleted successfully: $taskId"
                return $true
            }
        }
        
        # GetTasks method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetTasks" -Value {
            param(
                [switch]$ActiveOnly
            )
            
            Invoke-WithErrorHandling -Component "TaskService.GetTasks" -Context @{ ActiveOnly = $ActiveOnly } -ScriptBlock {
                Write-Log -Level Debug -Message "Getting tasks (ActiveOnly: $ActiveOnly)"
                
                $tasks = @($this._tasks)
                
                if ($ActiveOnly) {
                    $tasks = @($tasks | Where-Object { 
                        $_ -and $_.ContainsKey('completed') -and (-not $_.completed) 
                    })
                }
                
                Write-Log -Level Debug -Message "Returning $($tasks.Count) tasks"
                return $tasks
            }
        }
        
        # GetTaskById method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetTaskById" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [string]$taskId
            )
            
            Invoke-WithErrorHandling -Component "TaskService.GetTaskById" -Context @{ TaskId = $taskId } -ScriptBlock {
                if (-not $taskId) {
                    Write-Log -Level Warning -Message "GetTaskById: No TaskId provided"
                    return $null
                }
                
                foreach ($task in $this._tasks) {
                    if ($task.id -eq $taskId) {
                        return $task
                    }
                }
                
                Write-Log -Level Debug -Message "GetTaskById: Task not found with ID $taskId"
                return $null
            }
        }
        
        # GetTasksForDisplay method (formatted for UI tables)
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetTasksForDisplay" -Value {
            Invoke-WithErrorHandling -Component "TaskService.GetTasksForDisplay" -Context @{} -ScriptBlock {
                Write-Log -Level Debug -Message "Getting tasks for display"
                
                $tasksForTable = @()
                
                foreach ($task in $this._tasks) {
                    if (-not $task) { continue }
                    
                    # Safe property access with defaults
                    $taskItem = @{
                        Id = if ($task.ContainsKey('id')) { $task.id } else { [Guid]::NewGuid().ToString() }
                        Status = if ($task.ContainsKey('completed') -and $task.completed) { "✓" } else { "○" }
                        Priority = if ($task.ContainsKey('priority')) { $task.priority } else { "medium" }
                        Title = if ($task.ContainsKey('title')) { $task.title } else { "Untitled" }
                        Category = if ($task.ContainsKey('project')) { $task.project } else { "General" }
                        DueDate = "N/A"
                    }
                    
                    # Safe date parsing
                    if ($task.ContainsKey('due_date') -and $task.due_date) {
                        try {
                            $taskItem.DueDate = ([DateTime]$task.due_date).ToString("yyyy-MM-dd")
                        } catch {
                            $taskItem.DueDate = "Invalid"
                        }
                    }
                    
                    $tasksForTable += $taskItem
                }
                
                Write-Log -Level Debug -Message "Returning $($tasksForTable.Count) tasks for display"
                return @($tasksForTable)
            }
        }
        
        # GetStatistics method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetStatistics" -Value {
            Invoke-WithErrorHandling -Component "TaskService.GetStatistics" -Context @{} -ScriptBlock {
                Write-Log -Level Debug -Message "Calculating task statistics"
                
                $stats = @{
                    TotalTasks = $this._tasks.Count
                    ActiveTasks = 0
                    CompletedTasks = 0
                    HighPriorityTasks = 0
                    OverdueTasks = 0
                }
                
                $today = Get-Date
                
                foreach ($task in $this._tasks) {
                    if (-not $task) { continue }
                    
                    if ($task.ContainsKey('completed') -and $task.completed) {
                        $stats.CompletedTasks++
                    } else {
                        $stats.ActiveTasks++
                    }
                    
                    if ($task.ContainsKey('priority') -and $task.priority -eq 'high') {
                        $stats.HighPriorityTasks++
                    }
                    
                    if ($task.ContainsKey('due_date') -and $task.due_date -and -not $task.completed) {
                        try {
                            $dueDate = [DateTime]$task.due_date
                            if ($dueDate -lt $today) {
                                $stats.OverdueTasks++
                            }
                        } catch {
                            # Invalid date format
                        }
                    }
                }
                
                Write-Log -Level Debug -Message "Statistics calculated: Total=$($stats.TotalTasks), Active=$($stats.ActiveTasks)"
                return $stats
            }
        }
        
        # Initialize method - loads tasks from global data
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "Initialize" -Value {
            Invoke-WithErrorHandling -Component "TaskService.Initialize" -Context @{} -ScriptBlock {
                if ($this._isInitialized) {
                    Write-Log -Level Debug -Message "TaskService already initialized"
                    return
                }
                
                Write-Log -Level Info -Message "Initializing TaskService data"
                
                # Load tasks from global data if available
                if ($global:Data -and $global:Data.ContainsKey('Tasks')) {
                    $this._tasks = @($global:Data.Tasks)
                    Write-Log -Level Info -Message "Loaded $($this._tasks.Count) tasks from global data"
                } else {
                    $this._tasks = @()
                    Write-Log -Level Info -Message "No existing tasks found, starting with empty list"
                }
                
                $this._isInitialized = $true
                
                # Announce initialization complete
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Service.Initialized" -MessageData @{
                    TaskCount = $this._tasks.Count
                }
            }
        }
        
        # Initialize the service
        $service.Initialize()
        
        Write-Log -Level Info -Message "Task Service initialized successfully"
        return $service
    }
}

# Export the initialization function
Export-ModuleMember -Function Initialize-TaskService


####\utilities\DO_NOT_USE\file_util.ps1
# --- CONFIGURATION ---
# The root folder of your existing structure where the files are located.
# This script will search recursively starting from here.
$sourceFolderStructureRoot = "C:\Users\jhnhe\Documents\GitHub\_HELIOS"

# The separate folder where files will be copied and renamed.
$destDir = "C:\Users\jhnhe\Documents\GitHub\_HELIOS\Copies"

# Path to the text file listing the filenames to process.
$fileListPath = "C:\Users\jhnhe\Documents\GitHub\_HELIOS\file_list.txt"


#
# === KEY RENAMING SETTINGS ===
#


# The NEW file extension for all processed files (e.g., ".log", ".txt"). Include the dot.
$newExtension = ".txt"

# A prefix to add to the renamed files (optional, can be "").
$newPrefix = "_"

# Set to $true to automatically delete all files in the destination
# folder before the script runs. This prevents "already exists" errors on re-runs.
$cleanDestinationBeforeRun = $true

# --- CONCATENATION SETTINGS ---
$doConcatenate = $true
$concatenatedFile = "all_processed_data.txt"

# --- SCRIPT (No need to edit below this line) ---

Write-Host "--- Starting File Processing ---" -ForegroundColor Green

# Resolve paths and perform initial checks
try {
    $sourceFolderStructureRoot = (Resolve-Path $sourceFolderStructureRoot -ErrorAction Stop).Path
    $destDir = (Resolve-Path $destDir -ErrorAction Stop).Path
    $fileListPath = (Resolve-Path $fileListPath -ErrorAction Stop).Path
} catch { Write-Error "Error resolving paths. Check your configuration."; Read-Host "Press Enter to exit"; Exit }

if (-not (Test-Path $fileListPath)) { Write-Error "File list not found: $fileListPath"; Read-Host "Press Enter to exit"; Exit }
$filesToProcess = Get-Content $fileListPath -ErrorAction Stop

# Ensure destination directory exists, create if not
if (-not (Test-Path $destDir -PathType Container)) {
    Write-Host "Destination directory '$destDir' not found. Creating it..." -ForegroundColor Yellow
    New-Item -Path $destDir -ItemType Directory | Out-Null
}

if ($cleanDestinationBeforeRun) {
    Write-Host "Cleaning destination directory: $destDir" -ForegroundColor Yellow
    Get-ChildItem -Path $destDir | Remove-Item -Recurse -Force
}

Write-Host "`n--- Step 1 & 2: Backing up (Copying) and Renaming Specified Files ---" -ForegroundColor Green
$renamedFiles = @()

# === CORE LOGIC CHANGE IS HERE ===
foreach ($filePathInList in $filesToProcess) {
    # Skip empty lines in the file list
    if ([string]::IsNullOrWhiteSpace($filePathInList)) { continue }

    # Construct the full path to the source file.
    # This handles both full paths (C:\...) and relative paths (subfolder\file.txt) in your list.
    $fullSourcePath = Join-Path -Path $sourceFolderStructureRoot -ChildPath $filePathInList
    if ([System.IO.Path]::IsPathRooted($filePathInList)) {
        $fullSourcePath = $filePathInList
    }

    Write-Host "Processing: '$fullSourcePath'" -ForegroundColor Cyan

    # Check if the specified file actually exists before trying to process it
    if (-not (Test-Path $fullSourcePath -PathType Leaf)) {
        Write-Warning "  SKIPPED: File not found at the specified path: '$fullSourcePath'"
        continue # Move to the next file in the list
    }

    # Get the file object for the validated path
    $sourceFile = Get-Item -Path $fullSourcePath

    # Construct a unique new name for the destination file
    $baseFileName = $sourceFile.BaseName
    $newFileName = "$newPrefix$baseFileName$newExtension"
    
    # In case of duplicate filenames from different subfolders, add parent folder to name
    if (($renamedFiles.Name).Contains($newFileName)) {
        $parentFolderName = $sourceFile.Directory.Name
        $newFileName = "$newPrefix${baseFileName}_$parentFolderName$newExtension"
    }

    try {
        # 1. BACKUP: Copy the exact file to the destination
        $copiedFile = Copy-Item -Path $sourceFile.FullName -Destination $destDir -PassThru -ErrorAction Stop
        
        # 2. RENAME: Rename the copy in the destination folder
        $renamedFile = Rename-Item -Path $copiedFile.FullName -NewName $newFileName -PassThru -ErrorAction Stop
        
        Write-Host "  OK: Copied and renamed to '$($renamedFile.Name)'"
        $renamedFiles += $renamedFile
    } catch {
        Write-Error "  FAILED: Error during copy or rename of '$($sourceFile.FullName)'"
        Write-Error "  $($_.Exception.Message)"
    }
}

# --- Step 3: (Optional) Concatenate the Files ---
if ($doConcatenate -and $renamedFiles.Count -gt 0) {
    Write-Host "`n--- Step 3: Concatenating Files ---" -ForegroundColor Green
    $concatenatedFilePath = Join-Path -Path $destDir -ChildPath $concatenatedFile
    if (Test-Path $concatenatedFilePath) { Remove-Item -Path $concatenatedFilePath -Force }
    Write-Host "Creating combined file '$concatenatedFile'..."
    Get-Content -Path $renamedFiles.FullName | Set-Content -Path $concatenatedFilePath
    Write-Host "All processed files have been concatenated into '$concatenatedFilePath'" -ForegroundColor Green
} elseif ($doConcatenate) {
    Write-Warning "`nConcatenation skipped: No files were successfully processed."
}

Write-Host "`n--- Process Complete! ---" -ForegroundColor Green
Read-Host "Press Enter to exit"


####\utilities\context-helpers.psm1
# Context capture helper for consistent handler creation
function New-ContextHandler {
    param(
        [hashtable]$CapturedContext,
        [scriptblock]$Handler
    )
    
    # Create a closure that captures the context
    $wrapper = {
        param($Event, $Args)
        $context = $CapturedContext
        & $Handler -Context $context -Event $Event -Args $Args
    }.GetNewClosure()
    
    # Store the captured context for debugging
    Add-Member -InputObject $wrapper -MemberType NoteProperty -Name "_CapturedContext" -Value $CapturedContext
    
    return $wrapper
}

# Screen context capture helper
function Get-ScreenContext {
    param([hashtable]$Screen)
    
    return @{
        Screen = $Screen
        Services = $Screen._services
        Store = $Screen._services.Store
        Navigation = $Screen._services.Navigation
        Components = $Screen.Components
    }
}

# Safe method invocation helper
function Invoke-SafeMethod {
    param(
        [hashtable]$Object,
        [string]$MethodName,
        [hashtable]$Parameters = @{}
    )
    
    if (-not $Object) {
        Write-Log -Level Warning -Message "Cannot invoke $MethodName on null object"
        return $null
    }
    
    if (-not $Object[$MethodName]) {
        Write-Log -Level Warning -Message "Method $MethodName not found on object"
        return $null
    }
    
    try {
        return & $Object[$MethodName] -self $Object @Parameters
    } catch {
        Write-Log -Level Error -Message "Error invoking $MethodName" -Data $_
        throw
    }
}

Export-ModuleMember -Function @(
    'New-ContextHandler',
    'Get-ScreenContext',
    'Invoke-SafeMethod'
)



####\utilities\focus-manager.psm1
# FILE: utilities/focus-manager.psm1
# PURPOSE: Provides the single source of truth for component focus management with scope support.

$script:Focus = @{
    FocusedComponent = $null 
    TabOrder = @()
    ActiveScope = $null
    History = @()  # Focus history for debugging
    ScopeStack = @()  # For nested focus scopes
}

function global:Request-Focus {
    param(
        [hashtable]$Component,
        [bool]$UpdateTabOrder = $false,
        [string]$Reason = "Direct"
    )
    Invoke-WithErrorHandling -Component "FocusManager.RequestFocus" -ScriptBlock {
        # Validate component
        if ($Component -and -not $Component.IsFocusable) {
            Write-Log -Level Debug -Message "Cannot focus non-focusable component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        if ($Component -and -not $Component.Visible) {
            Write-Log -Level Debug -Message "Cannot focus invisible component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        # Handle losing focus on previous component
        $oldFocused = $script:Focus.FocusedComponent
        if ($oldFocused -and ($oldFocused -ne $Component)) {
            $oldFocused.IsFocused = $false
            
            if ($oldFocused.OnBlur) {
                try {
                    & $oldFocused.OnBlur -self $oldFocused
                } catch {
                    Write-Log -Level Error -Message "Error in OnBlur handler for '$($oldFocused.Name ?? $oldFocused.Type)': $_" -Data @{ Component = $oldFocused.Name; Exception = $_ }
                }
            }
            
            # Fire blur event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Blur" -Data @{ Component = $oldFocused }
            }
        }
        
        # Update focus scope if needed
        $newScope = if ($Component) { Get-FocusScope -Component $Component } else { $null }
        if ($newScope -ne $script:Focus.ActiveScope) {
            # Leave old scope
            if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.OnLeaveFocusScope) {
                try {
                    & $script:Focus.ActiveScope.OnLeaveFocusScope -self $script:Focus.ActiveScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnLeaveFocusScope handler for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Component = $script:Focus.ActiveScope.Name; Exception = $_ }
                }
            }
            
            $script:Focus.ActiveScope = $newScope
            
            # Enter new scope
            if ($newScope -and $newScope.OnEnterFocusScope) {
                try {
                    & $newScope.OnEnterFocusScope -self $newScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnEnterFocusScope handler for '$($newScope.Name ?? $newScope.Type)': $_" -Data @{ Component = $newScope.Name; Exception = $_ }
                }
            }
        }
        
        # Set new focus
        $script:Focus.FocusedComponent = $Component
        
        # Update global state if available
        if ($global:TuiState) {
            $global:TuiState.FocusedComponent = $Component
        }
        
        # Update history
        $script:Focus.History += @{
            Component = $Component
            Timestamp = [DateTime]::UtcNow
            Reason = $Reason
        }
        if ($script:Focus.History.Count -gt 50) {
            $script:Focus.History = $script:Focus.History[-50..-1]
        }
        
        if ($Component) {
            $Component.IsFocused = $true
            
            # Call focus handler
            if ($Component.OnFocus) {
                try {
                    & $Component.OnFocus -self $Component
                } catch {
                    Write-Log -Level Error -Message "Error in OnFocus handler for '$($Component.Name ?? $Component.Type)': $_" -Data @{ Component = $Component.Name; Exception = $_ }
                }
            }
            
            # Fire focus event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Focus" -Data @{ Component = $Component }
            }
            
            # Update tab order if requested
            if ($UpdateTabOrder) {
                Update-TabOrder -FocusedComponent $Component
            }
        }
        
        # Request screen refresh
        if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
        
        if ($Component) {
            Write-Log -Level Debug -Message "Focused: $($Component.Name ?? $Component.Type) (Reason: $Reason)"
        } else {
            Write-Log -Level Debug -Message "Cleared focus (Reason: $Reason)"
        }
        
        return $true
    } -Context @{ Component = $Component.Name; Reason = $Reason } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager RequestFocus error for '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

function global:Clear-Focus {
    Invoke-WithErrorHandling -Component "FocusManager.ClearFocus" -ScriptBlock {
        Request-Focus -Component $null -Reason "Clear"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager ClearFocus error: $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Move-Focus {
    param(
        [bool]$Reverse = $false,
        [bool]$Wrap = $true
    )
    Invoke-WithErrorHandling -Component "FocusManager.MoveFocus" -ScriptBlock {
        # Check if active scope handles its own focus movement
        if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.HandleScopedFocus) {
            try {
                $handled = & $script:Focus.ActiveScope.HandleScopedFocus -self $script:Focus.ActiveScope -Reverse $Reverse
                if ($handled) {
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Active focus scope HandleScopedFocus failed for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Scope = $script:Focus.ActiveScope.Name; Reverse = $Reverse; Exception = $_ }
            }
        }
        
        # No focusable components
        if ($script:Focus.TabOrder.Count -eq 0) {
            Write-Log -Level Debug -Message "No focusable components in tab order"
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($script:Focus.TabOrder, $script:Focus.FocusedComponent)
        
        # If no current focus, focus first/last based on direction
        if ($currentIndex -eq -1) {
            $targetIndex = if ($Reverse) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            Request-Focus -Component $script:Focus.TabOrder[$targetIndex] -Reason "TabNavigation"
            return $true
        }
        
        # Calculate next index
        if ($Reverse) {
            $nextIndex = $currentIndex - 1
            if ($nextIndex -lt 0) {
                $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            }
        } else {
            $nextIndex = $currentIndex + 1
            if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
            }
        }
        
        # Skip invisible or disabled components
        $attempts = 0
        while ($attempts -lt $script:Focus.TabOrder.Count) {
            $candidate = $script:Focus.TabOrder[$nextIndex]
            
            if ($candidate.Visible -and $candidate.IsFocusable -and 
                (-not $candidate.PSObject.Properties['IsEnabled'] -or $candidate.IsEnabled)) {
                Request-Focus -Component $candidate -Reason "TabNavigation"
                return $true
            }
            
            # Move to next candidate
            if ($Reverse) {
                $nextIndex--
                if ($nextIndex -lt 0) {
                    $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
                }
            } else {
                $nextIndex++
                if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                    $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
                }
            }
            
            $attempts++
        }
        
        Write-Log -Level Debug -Message "No valid focus target found"
        return $false
    } -Context @{ Reverse = $Reverse; Wrap = $Wrap; CurrentFocused = $script:Focus.FocusedComponent.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager MoveFocus error: $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

function global:Get-FocusedComponent {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusedComponent" -ScriptBlock {
        return $script:Focus.FocusedComponent
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager GetFocusedComponent error: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Get-FocusHistory {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusHistory" -ScriptBlock {
        return $script:Focus.History
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager GetFocusHistory error: $($Exception.Message)" -Data $Exception.Context
        return @()
    }
}

# --- FIX: REMOVED 'private:' ---
function Get-FocusScope {
    param($Component)
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusScope" -ScriptBlock {
        $current = $Component
        while ($current) {
            if ($current.IsFocusScope) {
                return $current
            }
            $current = $current.Parent
        }
        
        return $null
    } -Context @{ Component = $Component.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager GetFocusScope error for '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Push-FocusScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.PushFocusScope" -ScriptBlock {
        if (-not $Scope.IsFocusScope) {
            $Scope.IsFocusScope = $true
        }
        
        $script:Focus.ScopeStack += $Scope
        $script:Focus.ActiveScope = $Scope
        
        Write-Log -Level Debug -Message "Pushed focus scope: $($Scope.Name ?? $Scope.Type)"
    } -Context @{ Scope = $Scope.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager PushFocusScope error for '$($Exception.Context.Scope)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Pop-FocusScope {
    Invoke-WithErrorHandling -Component "FocusManager.PopFocusScope" -ScriptBlock {
        if ($script:Focus.ScopeStack.Count -eq 0) {
            return $null
        }
        
        $poppedScope = $script:Focus.ScopeStack[-1]
        $script:Focus.ScopeStack = $script:Focus.ScopeStack[0..($script:Focus.ScopeStack.Count - 2)]
        
        # Restore previous scope
        if ($script:Focus.ScopeStack.Count -gt 0) {
            $script:Focus.ActiveScope = $script:Focus.ScopeStack[-1]
        } else {
            $script:Focus.ActiveScope = $null
        }
        
        Write-Log -Level Debug -Message "Popped focus scope: $($poppedScope.Name ?? $poppedScope.Type)"
        
        return $poppedScope
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager PopFocusScope error: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

# --- FIX: REMOVED 'private:' ---
function Update-TabOrder {
    param($FocusedComponent)
    Invoke-WithErrorHandling -Component "FocusManager.UpdateTabOrder" -ScriptBlock {
        # If component is already in tab order, no need to update
        if ($FocusedComponent -in $script:Focus.TabOrder) {
            return
        }
        
        # Rebuild tab order
        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
    } -Context @{ FocusedComponent = $FocusedComponent.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager UpdateTabOrder error: $($Exception.Message)" -Data $Exception.Context
    }
}

# --- FIX: REMOVED 'private:' ---
function Register-ScreenForFocus {
    param($Screen)
    Invoke-WithErrorHandling -Component "FocusManager.RegisterScreenForFocus" -ScriptBlock {
        $script:Focus.TabOrder = @()
        $script:Focus.ActiveScope = $null
        
        if (-not $Screen) {
            Request-Focus -Component $null -Reason "NoScreen"
            return
        }
        
        # Find all focusable components
        $focusableComponents = @()
        
        $FindFocusable = $null
        $FindFocusable = {
            param($component, $depth = 0)
            
            if (-not $component) { return }
            
            # Add focusable components
            if ($component.IsFocusable -and $component.Visible) {
                $focusableComponents += @{
                    Component = $component
                    Depth = $depth
                    TabIndex = $component.TabIndex ?? 0
                    Position = @{
                        Y = $component.Y ?? 0
                        X = $component.X ?? 0
                    }
                }
            }
            
            # Process panel children
            if ($component.Children) {
                foreach ($child in $component.Children) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
            
            # Process named children (for backward compatibility)
            if ($component.Components) {
                foreach ($child in $component.Components.Values) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
        }.GetNewClosure()
        
        # Start from screen components and children
        if ($Screen.Children) {
            foreach ($comp in $Screen.Children) {
                & $FindFocusable -component $comp
            }
        }
        
        # Also check legacy Components collection
        if ($Screen.Components) {
            foreach ($comp in $Screen.Components.Values) {
                & $FindFocusable -component $comp
            }
        }
        
        # Sort by TabIndex, then by position (top to bottom, left to right)
        $script:Focus.TabOrder = $focusableComponents | 
            Sort-Object { $_.TabIndex }, { $_.Position.Y }, { $_.Position.X } |
            ForEach-Object { $_.Component }
        
        Write-Log -Level Debug -Message "Registered $($script:Focus.TabOrder.Count) focusable components"
        
        # Focus first component if none focused
        if ($script:Focus.TabOrder.Count -gt 0 -and -not ($script:Focus.FocusedComponent -in $script:Focus.TabOrder)) {
            Request-Focus -Component $script:Focus.TabOrder[0] -Reason "InitialFocus"
        } elseif ($script:Focus.TabOrder.Count -eq 0) {
            Request-Focus -Component $null -Reason "NoFocusableComponents"
        }
    } -Context @{ ScreenName = $Screen.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager RegisterScreenForFocus error for '$($Exception.Context.ScreenName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Initialize-FocusManager {
    Invoke-WithErrorHandling -Component "FocusManager.Initialize" -ScriptBlock {
        # Subscribe to screen events
        if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
            Subscribe-Event -EventName "Screen.Pushed" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPushedHandler" -ScriptBlock {
                    Register-ScreenForFocus -Screen $Event.Data.Screen
                } -Context @{ EventData = $Event.Data } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "FocusManager Screen.Pushed event handler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            Subscribe-Event -EventName "Screen.Popped" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPoppedHandler" -ScriptBlock {
                    # Clear focus scopes
                    $script:Focus.ScopeStack = @()
                    $script:Focus.ActiveScope = $null
                    
                    # Re-register for new top screen
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                } -Context @{ EventData = $Event.Data } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "FocusManager Screen.Popped event handler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
            
            Subscribe-Event -EventName "Component.VisibilityChanged" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ComponentVisibilityChangedHandler" -ScriptBlock {
                    $component = $Event.Data.Component
                    
                    # If hiding focused component, move focus
                    if (-not $component.Visible -and $component -eq $script:Focus.FocusedComponent) {
                        Move-Focus
                    }
                    
                    # Update tab order if visibility changed
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                } -Context @{ EventData = $Event.Data } -ErrorHandler {
                    param($Exception)
                    Write-Log -Level Error -Message "FocusManager Component.VisibilityChanged event handler error: $($Exception.Message)" -Data $Exception.Context
                }
            }
        }
        
        Write-Log -Level Info -Message "Focus Manager initialized"
    } -Context @{} -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to initialize Focus Manager: $($Exception.Message)" -Data $Exception.Context
    }
}

# Utility functions for components
function global:Set-ComponentFocusable {
    param(
        [hashtable]$Component,
        [bool]$IsFocusable
    )
    Invoke-WithErrorHandling -Component "FocusManager.SetComponentFocusable" -ScriptBlock {
        $wasFocusable = $Component.IsFocusable
        $Component.IsFocusable = $IsFocusable
        
        # If making unfocusable and it's currently focused, clear focus
        if ($wasFocusable -and -not $IsFocusable -and $Component -eq $script:Focus.FocusedComponent) {
            Move-Focus
        }
        
        # Update tab order
        if ($global:TuiState -and $global:TuiState.CurrentScreen) {
            Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
        }
    } -Context @{ Component = $Component.Name; IsFocusable = $IsFocusable } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager SetComponentFocusable error for '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Focus-NextInScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.FocusNextInScope" -ScriptBlock {
        if (-not $Scope -or -not $Scope.IsFocusScope) {
            return $false
        }
        
        # Find focusable children within scope
        $scopeFocusable = @()
        
        $FindScopeFocusable = {
            param($component)
            
            if ($component.IsFocusable -and $component.Visible) {
                $scopeFocusable += $component
            }
            
            if ($component.Children -and $component -ne $Scope) {
                foreach ($child in $component.Children) {
                    & $FindScopeFocusable -component $child
                }
            }
        }
        
        & $FindScopeFocusable -component $Scope
        
        if ($scopeFocusable.Count -eq 0) {
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($scopeFocusable, $script:Focus.FocusedComponent)
        $nextIndex = ($currentIndex + 1) % $scopeFocusable.Count
        
        Request-Focus -Component $scopeFocusable[$nextIndex] -Reason "ScopeNavigation"
        return $true
    } -Context @{ Scope = $Scope.Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "FocusManager FocusNextInScope error for '$($Exception.Context.Scope)': $($Exception.Message)" -Data $Exception.Context
        return $false
    }
}

Export-ModuleMember -Function @(
    "Initialize-FocusManager",
    "Request-Focus", 
    "Clear-Focus",
    "Move-Focus",
    "Get-FocusedComponent",
    "Get-FocusHistory",
    "Push-FocusScope",
    "Pop-FocusScope",
    "Set-ComponentFocusable",
    "Focus-NextInScope"
)


####\utilities\layout-manager.psm1
# Layout Manager Utility Module
# Provides helper functions for component positioning and layout management

function global:New-TuiLayoutManager {
    <#
    .SYNOPSIS
    Creates a layout manager for organizing components within a container
    
    .DESCRIPTION
    The layout manager helps with automatic positioning, spacing, and alignment of components.
    It provides various layout modes: Stack, Grid, Dock, and Manual.
    
    .PARAMETER Container
    A hashtable with X, Y, Width, Height properties defining the container bounds
    
    .PARAMETER Mode
    Layout mode: 'Stack', 'Grid', 'Dock', or 'Manual'
    
    .EXAMPLE
    $layout = New-TuiLayoutManager -Container @{X=0; Y=0; Width=80; Height=25} -Mode 'Stack'
    $layout.Add($component1)
    $layout.Add($component2)
    $layout.Apply()
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [string]$Mode = 'Manual',
        [hashtable]$Options = @{}
    )
    
    $manager = @{
        Container = $Container
        Mode = $Mode
        Components = @()
        Options = @{
            # Stack options
            Direction = $Options.Direction ?? 'Vertical'  # 'Vertical' or 'Horizontal'
            Spacing = $Options.Spacing ?? 1
            Padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
            Alignment = $Options.Alignment ?? 'Left'  # 'Left', 'Center', 'Right'
            
            # Grid options
            Columns = $Options.Columns ?? 2
            RowHeight = $Options.RowHeight ?? 5
            ColumnWidth = $Options.ColumnWidth ?? 20
            
            # Dock options
            FillLast = $Options.FillLast ?? $true
        }
        
        # Methods
        Add = {
            param($Component, [hashtable]$LayoutProps = @{})
            $this = $args[-1]
            $this.Components += @{
                Component = $Component
                LayoutProps = $LayoutProps
            }
        }.GetNewClosure()
        
        Clear = {
            $this = $args[-1]
            $this.Components = @()
        }.GetNewClosure()
        
        Apply = {
            $this = $args[-1]
            switch ($this.Mode) {
                'Stack' { & $this.ApplyStackLayout }
                'Grid' { & $this.ApplyGridLayout }
                'Dock' { & $this.ApplyDockLayout }
                'Manual' { # Do nothing - components use their existing positions }
            }
        }.GetNewClosure()
        
        ApplyStackLayout = {
            $this = $args[-1]
            $x = $this.Container.X + $this.Options.Padding.Left
            $y = $this.Container.Y + $this.Options.Padding.Top
            $maxWidth = $this.Container.Width - $this.Options.Padding.Left - $this.Options.Padding.Right
            $maxHeight = $this.Container.Height - $this.Options.Padding.Top - $this.Options.Padding.Bottom
            
            foreach ($item in $this.Components) {
                $comp = $item.Component
                
                # Apply alignment
                switch ($this.Options.Alignment) {
                    'Center' { $comp.X = $x + [Math]::Floor(($maxWidth - $comp.Width) / 2) }
                    'Right' { $comp.X = $x + $maxWidth - $comp.Width }
                    default { $comp.X = $x }
                }
                
                if ($this.Options.Direction -eq 'Vertical') {
                    $comp.Y = $y
                    $y += $comp.Height + $this.Options.Spacing
                } else {
                    $comp.Y = $y
                    $x += $comp.Width + $this.Options.Spacing
                }
            }
        }.GetNewClosure()
        
        ApplyGridLayout = {
            $this = $args[-1]
            $startX = $this.Container.X + $this.Options.Padding.Left
            $startY = $this.Container.Y + $this.Options.Padding.Top
            $cols = $this.Options.Columns
            
            for ($i = 0; $i -lt $this.Components.Count; $i++) {
                $comp = $this.Components[$i].Component
                $row = [Math]::Floor($i / $cols)
                $col = $i % $cols
                
                $comp.X = $startX + ($col * ($this.Options.ColumnWidth + $this.Options.Spacing))
                $comp.Y = $startY + ($row * ($this.Options.RowHeight + $this.Options.Spacing))
                
                # Optionally constrain size to grid cell
                if ($this.Components[$i].LayoutProps.ConstrainToCell) {
                    $comp.Width = [Math]::Min($comp.Width, $this.Options.ColumnWidth)
                    $comp.Height = [Math]::Min($comp.Height, $this.Options.RowHeight)
                }
            }
        }.GetNewClosure()
        
        ApplyDockLayout = {
            $this = $args[-1]
            $remainingX = $this.Container.X
            $remainingY = $this.Container.Y
            $remainingWidth = $this.Container.Width
            $remainingHeight = $this.Container.Height
            
            # Process in order: Top, Bottom, Left, Right, Fill
            $dockOrder = @('Top', 'Bottom', 'Left', 'Right', 'Fill')
            
            foreach ($dock in $dockOrder) {
                $items = $this.Components | Where-Object { $_.LayoutProps.Dock -eq $dock }
                
                foreach ($item in $items) {
                    $comp = $item.Component
                    
                    switch ($dock) {
                        'Top' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $remainingY += $comp.Height
                            $remainingHeight -= $comp.Height
                        }
                        'Bottom' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY + $remainingHeight - $comp.Height
                            $comp.Width = $remainingWidth
                            $remainingHeight -= $comp.Height
                        }
                        'Left' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingX += $comp.Width
                            $remainingWidth -= $comp.Width
                        }
                        'Right' {
                            $comp.X = $remainingX + $remainingWidth - $comp.Width
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingWidth -= $comp.Width
                        }
                        'Fill' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $comp.Height = $remainingHeight
                        }
                    }
                }
            }
        }.GetNewClosure()
        
        # Helper to calculate required size
        GetRequiredSize = {
            $this = $args[-1]
            $width = 0
            $height = 0
            
            switch ($this.Mode) {
                'Stack' {
                    if ($this.Options.Direction -eq 'Vertical') {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Maximum).Maximum
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Sum).Sum
                        $height += ($this.Components.Count - 1) * $this.Options.Spacing
                    } else {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Sum).Sum
                        $width += ($this.Components.Count - 1) * $this.Options.Spacing
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Maximum).Maximum
                    }
                }
                'Grid' {
                    $cols = $this.Options.Columns
                    $rows = [Math]::Ceiling($this.Components.Count / $cols)
                    $width = $cols * $this.Options.ColumnWidth + ($cols - 1) * $this.Options.Spacing
                    $height = $rows * $this.Options.RowHeight + ($rows - 1) * $this.Options.Spacing
                }
            }
            
            $width += $this.Options.Padding.Left + $this.Options.Padding.Right
            $height += $this.Options.Padding.Top + $this.Options.Padding.Bottom
            
            return @{ Width = $width; Height = $height }
        }.GetNewClosure()
    }
    
    # Bind methods to the manager instance
    $manager.Add = $manager.Add.Invoke(@($manager))
    $manager.Clear = $manager.Clear.Invoke(@($manager))
    $manager.Apply = $manager.Apply.Invoke(@($manager))
    $manager.ApplyStackLayout = $manager.ApplyStackLayout.Invoke(@($manager))
    $manager.ApplyGridLayout = $manager.ApplyGridLayout.Invoke(@($manager))
    $manager.ApplyDockLayout = $manager.ApplyDockLayout.Invoke(@($manager))
    $manager.GetRequiredSize = $manager.GetRequiredSize.Invoke(@($manager))
    
    return $manager
}

function global:Center-Component {
    <#
    .SYNOPSIS
    Centers a component within a container
    #>
    param(
        [hashtable]$Component,
        [hashtable]$Container = @{ X = 0; Y = 0; Width = $global:TuiState.BufferWidth; Height = $global:TuiState.BufferHeight }
    )
    
    $Component.X = $Container.X + [Math]::Floor(($Container.Width - $Component.Width) / 2)
    $Component.Y = $Container.Y + [Math]::Floor(($Container.Height - $Component.Height) / 2)
}

function global:Align-Components {
    <#
    .SYNOPSIS
    Aligns multiple components horizontally or vertically
    #>
    param(
        [hashtable[]]$Components,
        [string]$Direction = 'Horizontal',  # 'Horizontal' or 'Vertical'
        [string]$Alignment = 'Center',      # 'Top', 'Middle', 'Bottom' for horizontal; 'Left', 'Center', 'Right' for vertical
        [int]$Spacing = 2
    )
    
    if ($Components.Count -eq 0) { return }
    
    if ($Direction -eq 'Horizontal') {
        # Calculate total width needed
        $totalWidth = ($Components | ForEach-Object { $_.Width } | Measure-Object -Sum).Sum
        $totalWidth += ($Components.Count - 1) * $Spacing
        
        # Starting X position
        $currentX = switch ($Alignment) {
            'Left' { 0 }
            'Right' { $global:TuiState.BufferWidth - $totalWidth }
            default { [Math]::Floor(($global:TuiState.BufferWidth - $totalWidth) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.X = $currentX
            $currentX += $comp.Width + $Spacing
        }
    } else {
        # Calculate total height needed
        $totalHeight = ($Components | ForEach-Object { $_.Height } | Measure-Object -Sum).Sum
        $totalHeight += ($Components.Count - 1) * $Spacing
        
        # Starting Y position
        $currentY = switch ($Alignment) {
            'Top' { 0 }
            'Bottom' { $global:TuiState.BufferHeight - $totalHeight }
            default { [Math]::Floor(($global:TuiState.BufferHeight - $totalHeight) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.Y = $currentY
            $currentY += $comp.Height + $Spacing
        }
    }
}

function global:Create-ComponentGrid {
    <#
    .SYNOPSIS
    Arranges components in a grid layout
    #>
    param(
        [hashtable[]]$Components,
        [int]$Columns = 2,
        [int]$StartX = 0,
        [int]$StartY = 0,
        [int]$CellWidth = 20,
        [int]$CellHeight = 5,
        [int]$HorizontalSpacing = 2,
        [int]$VerticalSpacing = 1
    )
    
    for ($i = 0; $i -lt $Components.Count; $i++) {
        $row = [Math]::Floor($i / $Columns)
        $col = $i % $Columns
        
        $Components[$i].X = $StartX + ($col * ($CellWidth + $HorizontalSpacing))
        $Components[$i].Y = $StartY + ($row * ($CellHeight + $VerticalSpacing))
    }
}

Export-ModuleMember -Function @(
    'New-TuiLayoutManager',
    'Center-Component',
    'Align-Components',
    'Create-ComponentGrid'
)


####\utilities\positioning-helper.psm1
# Component Positioning Helper Module
# Provides utilities for easier component placement and relative positioning

function global:New-TuiPositioner {
    <#
    .SYNOPSIS
    Creates a positioning helper for managing component placement
    
    .DESCRIPTION
    The positioner helps calculate positions for components relative to each other
    and handles common layout patterns like rows, columns, and grids.
    
    .PARAMETER Container
    Defines the bounding container for positioning
    
    .EXAMPLE
    $pos = New-TuiPositioner -Container @{X=0; Y=0; Width=80; Height=25}
    $button1Pos = $pos.NextInRow(10, 3)  # Width=10, Height=3
    $button2Pos = $pos.NextInRow(10, 3)  # Automatically positioned after button1
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $positioner = @{
        Container = $Container
        CurrentX = $Container.X + ($Options.PaddingLeft ?? 0)
        CurrentY = $Container.Y + ($Options.PaddingTop ?? 0)
        RowHeight = 0
        Options = @{
            Spacing = $Options.Spacing ?? 1
            PaddingTop = $Options.PaddingTop ?? 0
            PaddingRight = $Options.PaddingRight ?? 0
            PaddingBottom = $Options.PaddingBottom ?? 0
            PaddingLeft = $Options.PaddingLeft ?? 0
        }
        
        # Reset to start of container
        Reset = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
            $this.RowHeight = 0
        }
        
        # Move to next row
        NewRow = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY += $this.RowHeight + $this.Options.Spacing
            $this.RowHeight = 0
        }
        
        # Get next position in current row
        NextInRow = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current row
            $maxX = $this.Container.X + $this.Container.Width - $this.Options.PaddingRight
            if (($this.CurrentX + $Width) -gt $maxX) {
                & $this.NewRow
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentX += $Width + $this.Options.Spacing
            $this.RowHeight = [Math]::Max($this.RowHeight, $Height)
            
            return $position
        }
        
        # Get next position in current column
        NextInColumn = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current column
            $maxY = $this.Container.Y + $this.Container.Height - $this.Options.PaddingBottom
            if (($this.CurrentY + $Height) -gt $maxY) {
                # Move to next column
                $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
                $this.CurrentX += $Width + $this.Options.Spacing
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentY += $Height + $this.Options.Spacing
            
            return $position
        }
        
        # Position at specific coordinates
        At = {
            param([int]$X, [int]$Y, [int]$Width, [int]$Height)
            
            $this.CurrentX = $X + $Width + $this.Options.Spacing
            $this.CurrentY = $Y
            $this.RowHeight = $Height
            
            return @{
                X = $X
                Y = $Y
                Width = $Width
                Height = $Height
            }
        }
        
        # Position relative to another position
        RelativeTo = {
            param(
                [hashtable]$Reference,
                [string]$Direction = "Right",  # Right, Left, Above, Below
                [int]$Width,
                [int]$Height,
                [int]$Offset = $null
            )
            
            if ($null -eq $Offset) { $Offset = $this.Options.Spacing }
            
            $position = switch ($Direction) {
                "Right" {
                    @{
                        X = $Reference.X + $Reference.Width + $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Left" {
                    @{
                        X = $Reference.X - $Width - $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Below" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y + $Reference.Height + $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
                "Above" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y - $Height - $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
            }
            
            return $position
        }
        
        # Center component in container
        Center = {
            param([int]$Width, [int]$Height)
            
            return @{
                X = $this.Container.X + [Math]::Floor(($this.Container.Width - $Width) / 2)
                Y = $this.Container.Y + [Math]::Floor(($this.Container.Height - $Height) / 2)
                Width = $Width
                Height = $Height
            }
        }
        
        # Align to edges
        AlignTopLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignTopRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
    }
    
    return $positioner
}

function global:Position-Components {
    <#
    .SYNOPSIS
    Positions multiple components using a layout pattern
    
    .PARAMETER Components
    Array of component hashtables to position
    
    .PARAMETER Pattern
    Layout pattern: 'Row', 'Column', 'Grid', 'Flow'
    
    .PARAMETER Container
    Container bounds
    
    .PARAMETER Options
    Layout options (spacing, columns for grid, etc.)
    #>
    param(
        [hashtable[]]$Components,
        [string]$Pattern = 'Row',
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $spacing = $Options.Spacing ?? 1
    $padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
    
    switch ($Pattern) {
        'Row' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
            }
        }
        
        'Column' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $y += $comp.Height + $spacing
            }
        }
        
        'Grid' {
            $columns = $Options.Columns ?? 2
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $col = 0
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                if ($col -ge $columns) {
                    $col = 0
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
                $col++
            }
        }
        
        'Flow' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $maxX = $Container.X + $Container.Width - $padding.Right
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                # Check if component fits in current row
                if (($x + $comp.Width) -gt $maxX -and $x -ne ($Container.X + $padding.Left)) {
                    # Move to next row
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
            }
        }
    }
}

function global:Get-RelativePosition {
    <#
    .SYNOPSIS
    Calculate position relative to another component
    #>
    param(
        [hashtable]$Reference,
        [string]$Direction = "Right",
        [int]$Offset = 1
    )
    
    switch ($Direction) {
        "Right" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "Left" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "Above" { return @{ X = $Reference.X; Y = $Reference.Y - $Offset } }
        "Below" { return @{ X = $Reference.X; Y = $Reference.Y + $Reference.Height + $Offset } }
        "TopRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "TopLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "BottomRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y + $Reference.Height } }
        "BottomLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y + $Reference.Height } }
    }
}

Export-ModuleMember -Function @(
    'New-TuiPositioner',
    'Position-Components',
    'Get-RelativePosition'
)


####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


####\main.ps1
#
# FILE: main.ps1
# PURPOSE: PMC Terminal v5 "Helios" - Main Entry Point
# AI: This file has been refactored to orchestrate module loading and application startup
#     with a clear, dependency-aware, service-oriented architecture.
#

# Set strict mode for better error handling and PowerShell best practices.
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located to build absolute paths for modules.
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

# AI: Corrected module load order to include 'models.psm1' before 'data-manager.psm1'.
# This is critical because the DataManager service depends on the classes defined in the models.
$script:ModulesToLoad = @(
    # Core infrastructure (no dependencies)
    @{ Name = "event-system"; Path = "modules\event-system.psm1"; Required = $true },
    @{ Name = "models"; Path = "modules\models.psm1"; Required = $true },

    # Data and theme (depend on event system and models)
    @{ Name = "data-manager"; Path = "modules\data-manager.psm1"; Required = $true },
    @{ Name = "theme-manager"; Path = "modules\theme-manager.psm1"; Required = $true },

    # Framework (depends on event system)
    @{ Name = "tui-framework"; Path = "modules\tui-framework.psm1"; Required = $true },

    # Engine (depends on theme and framework)
    @{ Name = "tui-engine-v2"; Path = "modules\tui-engine-v2.psm1"; Required = $true },

    # Dialog system (depends on engine)
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },

    # Services
    @{ Name = "navigation"; Path = "services\navigation.psm1"; Required = $true },
    @{ Name = "keybindings"; Path = "services\keybindings.psm1"; Required = $true },

    # Layout system
    @{ Name = "layout-panels"; Path = "layout\panels.psm1"; Required = $true },

    # Focus management (depends on event system)
    @{ Name = "focus-manager"; Path = "utilities\focus-manager.psm1"; Required = $true },

    # Components (depend on engine and panels)
    @{ Name = "tui-components"; Path = "components\tui-components.psm1"; Required = $true },
    @{ Name = "advanced-input-components"; Path = "components\advanced-input-components.psm1"; Required = $false },
    @{ Name = "advanced-data-components"; Path = "components\advanced-data-components.psm1"; Required = $true }
)

# Screen modules will be loaded dynamically by the framework.
$script:ScreenModules = @(
    "dashboard-screen-helios",
    "task-screen",
    "simple-test-screen" # AI: Added for consistency with navigation routes.
)

function Initialize-PMCModules {
    param([bool]$Silent = $false)
    
    return Invoke-WithErrorHandling -Component "ModuleLoader" -Context "Initializing core and utility modules" -ScriptBlock {
        if (-not $Silent) {
            Write-Host "Verifying console environment..." -ForegroundColor Gray
        }
        $minWidth = 80
        $minHeight = 24
        if ($Host.UI.RawUI) {
            if ($Host.UI.RawUI.WindowSize.Width -lt $minWidth -or $Host.UI.RawUI.WindowSize.Height -lt $minHeight) {
                Write-Host "Console window too small. Please resize to at least $minWidth x $minHeight and restart." -ForegroundColor Yellow
                Read-Host "Press Enter to exit."
                throw "Console window too small."
            }
        }

        $loadedModules = @()
        $totalModules = $script:ModulesToLoad.Count
        $currentModule = 0

        foreach ($module in $script:ModulesToLoad) {
            $currentModule++
            $modulePath = Join-Path $script:BasePath $module.Path
            
            if (-not $Silent) {
                $percent = [Math]::Round(($currentModule / $totalModules) * 100)
                Write-Host "`rLoading modules... [$percent%] $($module.Name)" -NoNewline -ForegroundColor Cyan
            }
            
            if (Test-Path $modulePath) {
                try {
                    Import-Module $modulePath -Force -Global
                    $loadedModules += $module.Name
                } catch {
                    if ($module.Required) {
                        Write-Host "`nFATAL: Failed to load required module: $($module.Name)" -ForegroundColor Red
                        throw "Failed to load required module: $($module.Name). Error: $($_.Exception.Message)"
                    } else {
                        if (-not $Silent) { Write-Host "`nSkipping optional module: $($module.Name)" -ForegroundColor Yellow }
                    }
                }
            } else {
                if ($module.Required) {
                    throw "Required module file not found: $($module.Name) at $modulePath"
                }
            }
        }
        
        if (-not $Silent) { Write-Host "`rModules loaded successfully.                                    " -ForegroundColor Green }
        return $loadedModules
    }
}

function Initialize-PMCScreens {
    param([bool]$Silent = $false)
    
    return Invoke-WithErrorHandling -Component "ScreenLoader" -Context "Initializing screen modules" -ScriptBlock {
        if (-not $Silent) { Write-Host "Loading screens..." -ForegroundColor Cyan }
        
        $loadedScreens = @()
        foreach ($screenName in $script:ScreenModules) {
            $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
            if (Test-Path $screenPath) {
                try {
                    Import-Module $screenPath -Force -Global
                    $loadedScreens += $screenName
                } catch {
                    Write-Warning "Failed to load screen module '$screenName': $_"
                }
            }
        }
        
        if (-not $Silent) { Write-Host "Screens loaded: $($loadedScreens.Count) of $($script:ScreenModules.Count)" -ForegroundColor Green }
        return $loadedScreens
    }
}

# AI: Removed the Initialize-PMCServices function. Service initialization is now handled
#     directly and explicitly within Start-PMCTerminal for clarity and correct dependency injection.

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    Invoke-WithErrorHandling -Component "Application" -Context "Main startup sequence" -ScriptBlock {
        Write-Log -Level Info -Message "PMC Terminal v5 'Helios' startup initiated."
        
        # --- 1. Load Core Modules ---
        $loadedModules = Initialize-PMCModules -Silent:$Silent
        Write-Log -Level Info -Message "Core modules loaded: $($loadedModules -join ', ')"
        
        # --- 2. Initialize Core Systems (in dependency order) ---
        # AI: The service initialization sequence is now explicit and ordered by dependency.
        Initialize-EventSystem
        Initialize-ThemeManager
        $dataManagerService = Initialize-DataManager
        Initialize-TuiFramework
        Initialize-FocusManager
        Initialize-DialogSystem
        
        # --- 3. Initialize and Assemble Services ---
        $services = @{
            DataManager = $dataManagerService
            Navigation  = Initialize-NavigationService
            Keybindings = Initialize-KeybindingService
        }
        $global:Services = $services
        Write-Log -Level Info -Message "All services initialized and assembled."
        
        # --- 4. Register Navigation Routes ---
        # AI: Route registration now happens after the Navigation service is fully initialized.
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/dashboard" -ScreenFactory { Get-DashboardScreen -Services $services }
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/tasks" -ScreenFactory { Get-TaskManagementScreen -Services $services }
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/simple-test" -ScreenFactory { Get-SimpleTestScreen -Services $services }
        Write-Log -Level Info -Message "Navigation routes registered."
        
        # --- 5. Load UI Screens ---
        $loadedScreens = Initialize-PMCScreens -Silent:$Silent
        Write-Log -Level Info -Message "Screen modules loaded: $($loadedScreens -join ', ')"
        
        # --- 6. Initialize TUI Engine and Navigate ---
        if (-not $Silent) { Write-Host "`nStarting TUI..." -ForegroundColor Green }
        Clear-Host
        
        Initialize-TuiEngine
        
        $startPath = if ($args -contains "-start" -and ($args.IndexOf("-start") + 1) -lt $args.Count) {
            $args[$args.IndexOf("-start") + 1]
        } else {
            "/dashboard"
        }
        
        if (-not (& $services.Navigation.IsValidRoute -self $services.Navigation -Path $startPath)) {
            Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
            $startPath = "/dashboard"
        }
        
        & $services.Navigation.GoTo -self $services.Navigation -Path $startPath -Services $services
        
        # --- 7. Start the Main Loop ---
        Start-TuiLoop
        
        Write-Log -Level Info -Message "PMC Terminal exited gracefully."
    }
}

# ===================================================================
# MAIN EXECUTION BLOCK
# ===================================================================
try {
    # CRITICAL: Pre-load logger and exceptions BEFORE anything else to ensure
    # error handling and logging are available throughout the entire startup sequence.
    $loggerModulePath = Join-Path $script:BasePath "modules\logger.psm1"
    $exceptionsModulePath = Join-Path $script:BasePath "modules\exceptions.psm1"
    
    if (-not (Test-Path $exceptionsModulePath)) { throw "CRITICAL: The core exceptions module is missing at '$exceptionsModulePath'." }
    if (-not (Test-Path $loggerModulePath)) { throw "CRITICAL: The core logger module is missing at '$loggerModulePath'." }
    
    Import-Module $exceptionsModulePath -Force -Global
    Import-Module $loggerModulePath -Force -Global

    # Now that logger is available, initialize it.
    Initialize-Logger
    
    # Start the main application logic, wrapped in top-level error handling.
    Start-PMCTerminal -Silent:$false
    
} catch {
    # This is our absolute last resort error handler.
    $errorMessage = "A fatal, unhandled exception occurred during application startup: $($_.Exception.Message)"
    Write-Host "`n$errorMessage" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    # Try to log if possible.
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Fatal -Message $errorMessage -Data @{
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
        } -Force
    }
    
    # Exit with a non-zero code to indicate failure.
    exit 1
}


