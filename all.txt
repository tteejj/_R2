####\components\advanced-data-components.psm1
# Advanced Data Components Module
# Enhanced data display components with sorting, filtering, and pagination

#region Advanced Table Component

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "DataTable"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 80 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Title = $Props.Title
        ShowBorder = if ($null -ne $Props.ShowBorder) { $Props.ShowBorder } else { $true }  # <-- NEW: Controls whether component draws its own border
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortDirection = "Ascending"
        FilterText = ""
        FilterColumn = $null
        PageSize = 0  # 0 = auto-calculate
        CurrentPage = 0
        ShowHeader = if ($null -ne $Props.ShowHeader) { $Props.ShowHeader } else { $true }
        ShowFooter = if ($null -ne $Props.ShowFooter) { $Props.ShowFooter } else { $true }
        ShowRowNumbers = if ($null -ne $Props.ShowRowNumbers) { $Props.ShowRowNumbers } else { $false }
        AllowSort = if ($null -ne $Props.AllowSort) { $Props.AllowSort } else { $true }
        AllowFilter = if ($null -ne $Props.AllowFilter) { $Props.AllowFilter } else { $true }
        AllowSelection = if ($null -ne $Props.AllowSelection) { $Props.AllowSelection } else { $true }
        MultiSelect = if ($null -ne $Props.MultiSelect) { $Props.MultiSelect } else { $false }
        SelectedRows = @()
        IsFocusable = if ($null -ne $Props.IsFocusable) { $Props.IsFocusable } else { $true }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        Name = $Props.Name
        FilteredData = @()
        ProcessedData = @()
        _lastRenderedWidth = 0
        _lastRenderedHeight = 0
        
        # Event handlers from Props
        OnRowSelect = $Props.OnRowSelect
        OnSelectionChange = $Props.OnSelectionChange
        
        # Column configuration example:
        # @{
        #     Name = "PropertyName"
        #     Header = "Display Header"
        #     Width = 20
        #     Align = "Left"  # Left, Right, Center
        #     Format = { param($value) $value.ToString("N2") }
        #     Sortable = $true
        #     Filterable = $true
        #     Color = { param($value, $row) if ($value -lt 0) { "Red" } else { "Green" } }
        # }
        
        ProcessData = {
            param($self)
            try {
                # Filter data
                if ([string]::IsNullOrWhiteSpace($self.FilterText)) {
                    $self.FilteredData = $self.Data
                } else {
                    if ($self.FilterColumn) {
                        # Filter specific column
                        $self.FilteredData = @($self.Data | Where-Object {
                            $value = $_."$($self.FilterColumn)"
                            $value -and $value.ToString() -like "*$($self.FilterText)*"
                        })
                    } else {
                        # Filter all columns
                        $self.FilteredData = @($self.Data | Where-Object {
                            $row = $_
                            $matched = $false
                            foreach ($col in $self.Columns) {
                                if ($col.Filterable -ne $false) {
                                    $value = $row."$($col.Name)"
                                    if ($value -and $value.ToString() -like "*$($self.FilterText)*") {
                                        $matched = $true
                                        break
                                    }
                                }
                            }
                            $matched
                        })
                    }
                }
                
                # Sort data
                if ($self.SortColumn -and $self.AllowSort) {
                    $self.ProcessedData = $self.FilteredData | Sort-Object -Property $self.SortColumn -Descending:($self.SortDirection -eq "Descending")
                } else {
                    $self.ProcessedData = $self.FilteredData
                }
                
                # Reset selection if needed
                if ($self.SelectedRow -ge $self.ProcessedData.Count) {
                    $self.SelectedRow = [Math]::Max(0, $self.ProcessedData.Count - 1)
                }
                
                # Calculate page size if auto
                if ($self.PageSize -eq 0) {
                    $headerLines = if ($self.ShowHeader) { 3 } else { 0 }
                    $footerLines = if ($self.ShowFooter) { 2 } else { 0 }
                    $filterLines = if ($self.AllowFilter) { 2 } else { 0 }
                    $borderAdjust = if ($self.ShowBorder) { 2 } else { 0 }
                    $self.PageSize = $self.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                }
                
                # Adjust current page
                $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                if ($self.CurrentPage -ge $totalPages) {
                    $self.CurrentPage = [Math]::Max(0, $totalPages - 1)
                }
            } catch {
                Write-Log -Level Error -Message "DataTable ProcessData error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        Render = {
            param($self)
            try {
                # CRITICAL: Check if component is visible
                if ($self.Visible -eq $false) { return }
                
                # Force ProcessData if dimensions changed
                if ($self._lastRenderedWidth -ne $self.Width -or $self._lastRenderedHeight -ne $self.Height) {
                    & $self.ProcessData -self $self
                    $self._lastRenderedWidth = $self.Width
                    $self._lastRenderedHeight = $self.Height
                }
                
                # NOTE: ProcessData is now called by external code when data changes
                # This prevents unnecessary recalculation on every render frame
                
                # Calculate content area based on border settings
                if ($self.ShowBorder) {
                    $borderColor = if ($self.IsFocusable -and $self.IsFocused) { 
                        Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                    } else { 
                        Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                    }
                    
                    $titleText = if ($null -ne $self.Title) { $self.Title } else { 'Data Table' }
                    Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                        -BorderColor $borderColor -Title " $titleText "
                    
                    # Adjust content area for border
                    $contentX = $self.X + 1
                    $contentY = $self.Y + 1
                    $contentWidth = $self.Width - 2
                    $contentHeight = $self.Height - 2
                } else {
                    # No border, use full dimensions
                    $contentX = $self.X
                    $contentY = $self.Y
                    $contentWidth = $self.Width
                    $contentHeight = $self.Height
                }
                
                $currentY = $contentY
                $innerWidth = $contentWidth
                
                # Filter bar
                if ($self.AllowFilter) {
                    $filterBg = if ($self.FilterText) { Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    $filterFg = if ($self.FilterText) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                    
                    Write-BufferString -X ($contentX + 1) -Y $currentY -Text "Filter: " -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
                    
                    $filterDisplayText = if ($self.FilterText) { $self.FilterText } else { "Type to filter..." }
                    Write-BufferString -X ($contentX + 9) -Y $currentY -Text $filterDisplayText `
                        -ForegroundColor $filterFg -BackgroundColor $filterBg
                    
                    if ($self.FilterColumn) {
                        $filterCol = $self.Columns | Where-Object { $_.Name -eq $self.FilterColumn }
                        $colName = if ($filterCol -and $filterCol.Header) { $filterCol.Header } else { $self.FilterColumn }
                        Write-BufferString -X ($contentX + $contentWidth - 19) -Y $currentY `
                            -Text "Column: $colName" -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                    }
                    
                    $currentY += 2
                }
                
                # Calculate column widths - FIXED VERSION
                $totalDefinedWidth = ($self.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum
                if ($null -eq $totalDefinedWidth) { $totalDefinedWidth = 0 }
                $flexColumns = @($self.Columns | Where-Object { -not $_.Width })
                $columnSeparators = if ($self.Columns.Count -gt 1) { $self.Columns.Count - 1 } else { 0 }  # Only add separators if multiple columns
                $rowNumberWidth = if ($self.ShowRowNumbers) { 5 } else { 0 }
                $remainingWidth = $innerWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
                
                # CRITICAL FIX: Ensure flex columns get adequate width, especially for single-column tables
                $flexWidth = 0
                if ($flexColumns.Count -gt 0) {
                    $flexWidth = [Math]::Floor($remainingWidth / $flexColumns.Count)
                }
                
                # Assign calculated widths
                foreach ($col in $self.Columns) {
                    if ($col.Width) {
                        $col.CalculatedWidth = $col.Width
                    } else {
                        # For flex columns, use the calculated flex width
                        $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
                    }
                }
                
                # Header
                if ($self.ShowHeader) {
                    $headerX = $contentX
                    
                    # Row number header
                    if ($self.ShowRowNumbers) {
                        Write-BufferString -X $headerX -Y $currentY -Text "#".PadRight(4) `
                            -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                        $headerX += 5
                    }
                    
                    # Column headers
                    foreach ($col in $self.Columns) {
                        $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                        $width = $col.CalculatedWidth
                        
                        # Add sort indicator
                        if ($self.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $self.SortColumn) {
                            $sortIndicator = if ($self.SortDirection -eq "Ascending") { "‚ñ≤" } else { "‚ñº" }
                            $headerText = "$headerText $sortIndicator"
                        }
                        
                        # Truncate if needed
                        if ($headerText.Length -gt $width) {
                            # FIX: Robust substring
                            $maxLength = [Math]::Max(0, $width - 3)
                            $headerText = $headerText.Substring(0, $maxLength) + "..."
                        }
                        
                        # Align header
                        if ($col.Align -eq "Right") {
                            $alignedText = $headerText.PadLeft($width)
                        } elseif ($col.Align -eq "Center") {
                            $padding = $width - $headerText.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            $alignedText = " " * $leftPad + $headerText + " " * $rightPad
                        } else {
                            $alignedText = $headerText.PadRight($width)
                        }
                        
                        Write-BufferString -X $headerX -Y $currentY -Text $alignedText `
                            -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                        
                        $headerX += $width + 1
                    }
                    
                    $currentY++
                    
                    # Header separator
                    $separatorColor = Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                    Write-BufferString -X $contentX -Y $currentY `
                        -Text ("‚îÄ" * $contentWidth) -ForegroundColor $separatorColor
                    $currentY++
                }
                
                # Data rows
                $startIdx = $self.CurrentPage * $self.PageSize
                $endIdx = [Math]::Min($startIdx + $self.PageSize - 1, $self.ProcessedData.Count - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.ProcessedData[$i]
                    $rowX = $contentX
                    
                    # Selection highlighting
                    $isSelected = if ($self.MultiSelect) {
                        $self.SelectedRows -contains $i
                    } else {
                        $i -eq $self.SelectedRow
                    }
                    
                    $rowBg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    $rowFg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                    
                    # Clear row background if selected - FIXED to respect actual component width
                    if ($isSelected) {
                        # Calculate actual row width based on column widths and separators
                        $actualRowWidth = 0
                        if ($self.ShowRowNumbers) { $actualRowWidth += 5 }
                        foreach ($col in $self.Columns) {
                            $actualRowWidth += $col.CalculatedWidth
                        }
                        # Add column separators
                        if ($self.Columns.Count -gt 1) {
                            $actualRowWidth += ($self.Columns.Count - 1)
                        }
                        # Ensure we don't exceed content width
                        $actualRowWidth = [Math]::Min($actualRowWidth, $contentWidth)
                        
                        Write-BufferString -X $rowX -Y $currentY -Text (" " * $actualRowWidth) `
                            -BackgroundColor $rowBg
                    }
                    
                    # Row number
                    if ($self.ShowRowNumbers) {
                        Write-BufferString -X $rowX -Y $currentY -Text ($i + 1).ToString().PadRight(4) `
                            -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)) -BackgroundColor $rowBg
                        $rowX += 5
                    }
                    
                    # Cell data
                    foreach ($col in $self.Columns) {
                        $value = $row."$($col.Name)"
                        $width = $col.CalculatedWidth
                        
                        # Format value
                        $displayValue = if ($col.Format -and $value -ne $null) {
                            & $col.Format $value
                        } elseif ($value -ne $null) {
                            $value.ToString()
                        } else {
                            ""
                        }
                        
                        # Truncate if needed
                        if ($displayValue.Length -gt $width) {
                            # FIX: Robust substring
                            $maxLength = [Math]::Max(0, $width - 3)
                            if ($maxLength -le 0) {
                                Write-Log -Level Warning -Message "DataTable '$($self.Title)' column '$($col.Name)' width too small: $width (max length: $maxLength)"
                                $displayValue = "..."
                            } else {
                                $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                            }
                        }
                        
                        
                        # Align value
                        if ($col.Align -eq "Right") {
                            $alignedValue = $displayValue.PadLeft($width)
                        } elseif ($col.Align -eq "Center") {
                            $padding = $width - $displayValue.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            $alignedValue = " " * $leftPad + $displayValue + " " * $rightPad
                        } else {
                            $alignedValue = $displayValue.PadRight($width)
                        }
                        
                        # Determine color
                        $cellFg = if ($col.Color -and -not $isSelected) {
                            $colorName = & $col.Color $value $row
                            Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                        } else {
                            $rowFg
                        }
                        
                        # Ensure we don't write beyond component boundaries
                        if ($rowX + $alignedValue.Length -le $contentX + $contentWidth) {
                            Write-BufferString -X $rowX -Y $currentY -Text $alignedValue `
                                -ForegroundColor $cellFg -BackgroundColor $rowBg
                        } else {
                            # Clip the text to fit within boundaries
                            $availableWidth = ($contentX + $contentWidth) - $rowX
                            if ($availableWidth -gt 0) {
                                $clippedText = $alignedValue.Substring(0, [Math]::Min($alignedValue.Length, $availableWidth))
                                Write-BufferString -X $rowX -Y $currentY -Text $clippedText `
                                    -ForegroundColor $cellFg -BackgroundColor $rowBg
                            }
                        }
                        
                        $rowX += $width + 1
                    }
                    
                    $currentY++
                }
                
                # Empty state
                if ($self.ProcessedData.Count -eq 0) {
                    $emptyMessage = if ($self.FilterText) {
                        "No results match the filter"
                    } else {
                        "No data to display"
                    }
                    $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
                    $msgY = $contentY + [Math]::Floor($contentHeight / 2)
                    Write-BufferString -X $msgX -Y $msgY -Text $emptyMessage `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                }
                
                # Footer
                if ($self.ShowFooter) {
                    $footerY = $contentY + $contentHeight - 1
                    
                    # Status
                    $statusText = "$($self.ProcessedData.Count) rows"
                    if ($self.FilterText) {
                        $statusText += " (filtered from $($self.Data.Count))"
                    }
                    if ($self.MultiSelect) {
                        $statusText += " | $($self.SelectedRows.Count) selected"
                    }
                    Write-BufferString -X ($contentX + 1) -Y $footerY -Text $statusText `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                    
                    # Pagination
                    if ($self.ProcessedData.Count -gt $self.PageSize) {
                        $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                        $pageText = "Page $($self.CurrentPage + 1)/$totalPages"
                        Write-BufferString -X ($contentX + $contentWidth - $pageText.Length - 1) -Y $footerY `
                            -Text $pageText -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                    }
                    
                    # Scrollbar
                    if ($self.ProcessedData.Count -gt $self.PageSize) {
                        $scrollHeight = $contentHeight - 4 - (if ($self.ShowHeader) { 2 } else { 0 }) - (if ($self.AllowFilter) { 2 } else { 0 })
                        $scrollPos = [Math]::Floor(($self.SelectedRow / ($self.ProcessedData.Count - 1)) * ($scrollHeight - 1))
                        $scrollX = $contentX + $contentWidth - 1
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $scrollY = $currentY - $scrollHeight + $i
                            $char = if ($i -eq $scrollPos) { "‚ñà" } else { "‚îÇ" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                            Write-BufferString -X $scrollX -Y $scrollY -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "DataTable Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                # Filter mode
                if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                    switch ($Key.Key) {
                        ([ConsoleKey]::F) {
                            # Toggle filter focus
                            $self.FilterMode = -not $self.FilterMode
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::S) {
                            # Cycle sort column
                            if ($self.AllowSort) {
                                $sortableCols = @($self.Columns | Where-Object { $_.Sortable -ne $false })
                                if ($sortableCols.Count -gt 0) {
                                    $currentIdx = [array]::IndexOf($sortableCols.Name, $self.SortColumn)
                                    $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                                    $self.SortColumn = $sortableCols[$nextIdx].Name
                                    & $self.ProcessData -self $self
                                    Request-TuiRefresh
                                }
                            }
                            return $true
                        }
                        ([ConsoleKey]::A) {
                            # Select all (if multi-select)
                            if ($self.MultiSelect) {
                                if ($self.SelectedRows.Count -eq $self.ProcessedData.Count) {
                                    $self.SelectedRows = @()
                                } else {
                                    $self.SelectedRows = @(0..($self.ProcessedData.Count - 1))
                                }
                                if ($self.OnSelectionChange) {
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnSelectionChange" -Context "OnSelectionChange" -AdditionalData @{ Component = $self.Name; SelectedRows = $self.SelectedRows } -ScriptBlock {
                                        & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                                    }
                                }
                                Request-TuiRefresh
                            }
                            return $true
                        }
                    }
                }
                
                # Filter text input
                if ($self.FilterMode) {
                    switch ($Key.Key) {
                        ([ConsoleKey]::Escape) {
                            $self.FilterMode = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Enter) {
                            $self.FilterMode = $false
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Backspace) {
                            if ($self.FilterText.Length -gt 0) {
                                $self.FilterText = $self.FilterText.Substring(0, $self.FilterText.Length - 1)
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                            return $true
                        }
                        default {
                            if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                $self.FilterText += $Key.KeyChar
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                                return $true
                            }
                        }
                    }
                    return $false
                }
                
                # Normal navigation
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedRow -gt 0) {
                            $self.SelectedRow--
                            
                            # Adjust page if needed
                            if ($self.SelectedRow -lt ($self.CurrentPage * $self.PageSize)) {
                                $self.CurrentPage--
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedRow -lt ($self.ProcessedData.Count - 1)) {
                            $self.SelectedRow++
                            
                            # Adjust page if needed
                            if ($self.SelectedRow -ge (($self.CurrentPage + 1) * $self.PageSize)) {
                                $self.CurrentPage++
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::PageUp) {
                        if ($self.CurrentPage -gt 0) {
                            $self.CurrentPage--
                            $self.SelectedRow = $self.CurrentPage * $self.PageSize
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::PageDown) {
                        $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                        if ($self.CurrentPage -lt ($totalPages - 1)) {
                            $self.CurrentPage++
                            $self.SelectedRow = $self.CurrentPage * $self.PageSize
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.SelectedRow = 0
                        $self.CurrentPage = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.SelectedRow = $self.ProcessedData.Count - 1
                        $self.CurrentPage = [Math]::Floor($self.SelectedRow / [Math]::Max(1, $self.PageSize))
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.MultiSelect) {
                            if ($self.SelectedRows -contains $self.SelectedRow) {
                                $self.SelectedRows = @($self.SelectedRows | Where-Object { $_ -ne $self.SelectedRow })
                            } else {
                                $self.SelectedRows += $self.SelectedRow
                            }
                            if ($self.OnSelectionChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnSelectionChange" -Context "OnSelectionChange" -AdditionalData @{ Component = $self.Name; SelectedRows = $self.SelectedRows } -ScriptBlock {
                                    & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                                }
                            }
                            Request-TuiRefresh
                        } elseif ($self.AllowSort) {
                            # Toggle sort direction
                            if ($self.SortDirection -eq "Ascending") {
                                $self.SortDirection = "Descending"
                            } else {
                                $self.SortDirection = "Ascending"
                            }
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnRowSelect -and $self.ProcessedData.Count -gt 0) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -Context "OnRowSelect" -AdditionalData @{ Component = $self.Name; SelectedRow = $self.SelectedRow; MultiSelect = $self.MultiSelect } -ScriptBlock {
                                $selectedData = if ($self.MultiSelect) {
                                    @($self.SelectedRows | ForEach-Object { $self.ProcessedData[$_] })
                                } else {
                                    $self.ProcessedData[$self.SelectedRow]
                                }
                                & $self.OnRowSelect -SelectedData $selectedData -SelectedIndex $self.SelectedRow
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::F) {
                        if ($self.AllowFilter) {
                            $self.FilterMode = $true
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        # Number keys for column sorting
                        if ($Key.KeyChar -match '\d' -and $self.AllowSort) {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $col = $self.Columns[$colIndex]
                                if ($col.Sortable -ne $false) {
                                    if ($self.SortColumn -eq $col.Name) {
                                        # Toggle direction
                                        $self.SortDirection = if ($self.SortDirection -eq "Ascending") { "Descending" } else { "Ascending" }
                                    } else {
                                        $self.SortColumn = $col.Name
                                        $self.SortDirection = "Ascending"
                                    }
                                    & $self.ProcessData -self $self
                                    Request-TuiRefresh
                                }
                            }
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "DataTable HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
        
        # Public methods
        RefreshData = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).RefreshData" -Context "RefreshData" -AdditionalData @{ Component = $self.Name } -ScriptBlock {
                & $self.ProcessData -self $self
                Request-TuiRefresh
            }
        }
        
        SetFilter = {
            param($self, $FilterText, $FilterColumn)
            Invoke-WithErrorHandling -Component "$($self.Name).SetFilter" -Context "SetFilter" -AdditionalData @{ Component = $self.Name; FilterText = $FilterText; FilterColumn = $FilterColumn } -ScriptBlock {
                $self.FilterText = $FilterText
                $self.FilterColumn = $FilterColumn
                & $self.ProcessData -self $self
                Request-TuiRefresh
            }
        }
        
        ExportData = {
            param($self, $Format = "CSV", $FilePath)
            Invoke-WithErrorHandling -Component "$($self.Name).ExportData" -Context "ExportData" -AdditionalData @{ Component = $self.Name; Format = $Format; FilePath = $FilePath } -ScriptBlock {
                $exportData = if ($self.FilterText) { $self.ProcessedData } else { $self.Data }
                
                switch ($Format.ToUpper()) {
                    "CSV" {
                        $exportData | Export-Csv -Path $FilePath -NoTypeInformation
                    }
                    "JSON" {
                        $exportData | ConvertTo-Json -Depth 10 | Set-Content -Path $FilePath
                    }
                    "HTML" {
                        # Simple HTML table export
                        $html = "<table border='1'><tr>"
                        foreach ($col in $self.Columns) {
                            $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                            $html += "<th>$headerText</th>"
                        }
                        $html += "</tr>"
                        
                        foreach ($row in $exportData) {
                            $html += "<tr>"
                            foreach ($col in $self.Columns) {
                                $value = $row."$($col.Name)"
                                $html += "<td>$value</td>"
                            }
                            $html += "</tr>"
                        }
                        $html += "</table>"
                        
                        $html | Set-Content -Path $FilePath
                    }
                }
            }
        }
    }
    
    # Initialize data processing after component is created
    & $component.ProcessData -self $component
    
    return $component
}

#endregion

#region Tree View Component

function global:New-TuiTreeView {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TreeView"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        RootNode = if ($null -ne $Props.RootNode) { $Props.RootNode } else { @{ Name = "Root"; Children = @(); Expanded = $true } }
        SelectedNode = $null
        SelectedPath = @()
        FlattenedNodes = @()
        ScrollOffset = 0
        ShowRoot = if ($null -ne $Props.ShowRoot) { $Props.ShowRoot } else { $true }
        IsFocusable = $true
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        Name = $Props.Name
        OnNodeSelect = $Props.OnNodeSelect
        
        # Node structure:
        # @{
        #     Name = "Node Name"
        #     Data = @{}  # Custom data
        #     Children = @()
        #     Expanded = $false
        #     Icon = "üìÅ"  # Optional
        #     Parent = $null  # Set automatically
        # }
        
        FlattenTree = {
            param($self)
            try {
                $flattened = @()
                
                $processNode = {
                    param($Node, $Level, $Parent)
                    
                    $node.Parent = $Parent
                    $node.Level = $Level
                    
                    if ($self.ShowRoot -or $Level -gt 0) {
                        $flattened += $Node
                    }
                    
                    if ($Node.Expanded -and $Node.Children) {
                        foreach ($child in $Node.Children) {
                            & $processNode $child ($Level + 1) $Node
                        }
                    }
                }
                
                & $processNode $self.RootNode 0 $null
                $self.FlattenedNodes = $flattened
            } catch {
                Write-Log -Level Error -Message "TreeView FlattenTree error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        Render = {
            param($self)
            try {
                # Check if component is visible
                if ($self.Visible -eq $false) { return }
                
                # Flatten tree first
                & $self.FlattenTree -self $self
                
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Tree View "
                
                $visibleHeight = $self.Height - 2
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.FlattenedNodes.Count - 1, $startIdx + $visibleHeight - 1)
                
                $currentY = $self.Y + 1
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $node = $self.FlattenedNodes[$i]
                    $isSelected = ($node -eq $self.SelectedNode)
                    
                    # Indentation
                    $indent = "  " * $node.Level
                    
                    # Expand/collapse indicator
                    $expandIcon = if ($node.Children -and $node.Children.Count -gt 0) {
                        if ($node.Expanded) { "‚ñº" } else { "‚ñ∂" }
                    } else {
                        " "
                    }
                    
                    # Node icon
                    $nodeIcon = if ($node.Icon) { 
                        $node.Icon 
                    } elseif ($node.Children -and $node.Children.Count -gt 0) {
                        if ($node.Expanded) { "üìÇ" } else { "üìÅ" }
                    } else {
                        "üìÑ"
                    }
                    
                    # Colors
                    $fg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                    $bg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                    
                    # Clear line if selected
                    if ($isSelected) {
                        Write-BufferString -X ($self.X + 1) -Y $currentY -Text (" " * ($self.Width - 2)) `
                            -BackgroundColor $bg
                    }
                    
                    # Render node
                    $nodeText = "$indent$expandIcon $nodeIcon $($node.Name)"
                    if ($nodeText.Length -gt ($self.Width - 3)) {
                        $nodeText = $nodeText.Substring(0, $self.Width - 6) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 1) -Y $currentY -Text $nodeText `
                        -ForegroundColor $fg -BackgroundColor $bg
                    
                    $currentY++
                }
                
                # Scrollbar
                if ($self.FlattenedNodes.Count -gt $visibleHeight) {
                    $scrollHeight = $visibleHeight
                    $scrollPos = if ($self.FlattenedNodes.Count -gt 1) {
                        $selectedIdx = [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                        [Math]::Floor(($selectedIdx / ($self.FlattenedNodes.Count - 1)) * ($scrollHeight - 1))
                    } else { 0 }
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $char = if ($i -eq $scrollPos) { "‚ñà" } else { "‚îÇ" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) `
                            -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TreeView Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.FlattenedNodes.Count -eq 0) { return $false }
                
                $currentIdx = if ($self.SelectedNode) {
                    [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                } else { 0 }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($currentIdx -gt 0) {
                            $currentIdx--
                            $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                            
                            # Adjust scroll
                            if ($currentIdx -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $currentIdx
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($currentIdx -lt ($self.FlattenedNodes.Count - 1)) {
                            $currentIdx++
                            $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                            
                            # Adjust scroll
                            $visibleHeight = $self.Height - 2
                            if ($currentIdx -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $currentIdx - $visibleHeight + 1
                            }
                            
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.SelectedNode) {
                            if ($self.SelectedNode.Expanded -and $self.SelectedNode.Children) {
                                # Collapse
                                $self.SelectedNode.Expanded = $false
                                Request-TuiRefresh
                            } elseif ($self.SelectedNode.Parent) {
                                # Move to parent
                                $self.SelectedNode = $self.SelectedNode.Parent
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                            if (-not $self.SelectedNode.Expanded) {
                                # Expand
                                $self.SelectedNode.Expanded = $true
                                Request-TuiRefresh
                            } else {
                                # Move to first child
                                $self.SelectedNode = $self.SelectedNode.Children[0]
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                            $self.SelectedNode.Expanded = -not $self.SelectedNode.Expanded
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnNodeSelect -and $self.SelectedNode) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnNodeSelect" -Context "OnNodeSelect" -AdditionalData @{ Component = $self.Name; SelectedNode = $self.SelectedNode.Name } -ScriptBlock {
                                # Build path
                                $path = @()
                                $current = $self.SelectedNode
                                while ($current) {
                                    $path = @($current.Name) + $path
                                    $current = $current.Parent
                                }
                                
                                & $self.OnNodeSelect -Node $self.SelectedNode -Path $path
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        if ($self.FlattenedNodes.Count -gt 0) {
                            $self.SelectedNode = $self.FlattenedNodes[0]
                            $self.ScrollOffset = 0
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        if ($self.FlattenedNodes.Count -gt 0) {
                            $self.SelectedNode = $self.FlattenedNodes[-1]
                            $visibleHeight = $self.Height - 2
                            $self.ScrollOffset = [Math]::Max(0, $self.FlattenedNodes.Count - $visibleHeight)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    { $_ -in @([ConsoleKey]::Add, [ConsoleKey]::OemPlus) } {
                        # Expand all
                        $expandAll = {
                            param($Node)
                            $Node.Expanded = $true
                            foreach ($child in $Node.Children) {
                                & $expandAll $child
                            }
                        }
                        & $expandAll $self.RootNode
                        Request-TuiRefresh
                        return $true
                    }
                    { $_ -in @([ConsoleKey]::Subtract, [ConsoleKey]::OemMinus) } {
                        # Collapse all
                        $collapseAll = {
                            param($Node)
                            $Node.Expanded = $false
                            foreach ($child in $Node.Children) {
                                & $collapseAll $child
                            }
                        }
                        & $collapseAll $self.RootNode
                        $self.RootNode.Expanded = $true  # Keep root expanded
                        Request-TuiRefresh
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TreeView HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
        
        # Public methods
        AddNode = {
            param($self, $ParentNode, $NewNode)
            Invoke-WithErrorHandling -Component "$($self.Name).AddNode" -Context "AddNode" -AdditionalData @{ Component = $self.Name; ParentNode = $ParentNode.Name; NewNode = $NewNode.Name } -ScriptBlock {
                if (-not $ParentNode.Children) {
                    $ParentNode.Children = @()
                }
                $ParentNode.Children += $NewNode
                $NewNode.Parent = $ParentNode
                Request-TuiRefresh
            }
        }
        
        RemoveNode = {
            param($self, $Node)
            Invoke-WithErrorHandling -Component "$($self.Name).RemoveNode" -Context "RemoveNode" -AdditionalData @{ Component = $self.Name; Node = $Node.Name } -ScriptBlock {
                if ($Node.Parent) {
                    $Node.Parent.Children = @($Node.Parent.Children | Where-Object { $_ -ne $Node })
                    if ($self.SelectedNode -eq $Node) {
                        $self.SelectedNode = $Node.Parent
                    }
                    Request-TuiRefresh
                }
            }
        }
        
        FindNode = {
            param($self, $Predicate)
            Invoke-WithErrorHandling -Component "$($self.Name).FindNode" -Context "FindNode" -AdditionalData @{ Component = $self.Name } -ScriptBlock {
                $find = {
                    param($Node)
                    if (& $Predicate $Node) { return $Node }
                    foreach ($child in $Node.Children) {
                        $found = & $find $child
                        if ($found) { return $found }
                    }
                    return $null
                }
                
                return & $find $self.RootNode
            }
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiDataTable',
    'New-TuiTreeView'
)


####\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Mode = if ($null -ne $Props.Mode) { $Props.Mode } else { "Date" } # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        ViewDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "‚óÑ" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "‚ñ∫" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                            continue
                        }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { 
                                Get-ThemeColor "Background" 
                            } elseif ($isToday) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Primary" 
                            }
                            
                            $bg = if ($isSelected) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Background" 
                            }
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                                -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                        -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Previous month
                            $self.ViewDate = $viewDate.AddMonths(-1)
                        } else {
                            # Previous day
                            $date = $date.AddDays(-1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Next month
                            $self.ViewDate = $viewDate.AddMonths(1)
                        } else {
                            # Next day
                            $date = $date.AddDays(1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::UpArrow) {
                        $date = $date.AddDays(-7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        $date = $date.AddDays(7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) {
                        $date = Get-Date
                        $self.ViewDate = $date
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock {
                                & $self.OnSelect -Date $date
                            } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $date
                        } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Type to search..." }
        MaxDisplayItems = if ($null -ne $Props.MaxDisplayItems) { $Props.MaxDisplayItems } else { 5 }
        AllowCustomValue = if ($null -ne $Props.AllowCustomValue) { $Props.AllowCustomValue } else { $false }
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        if ($selected) {
                            $displayText = $selected.Display
                        } else {
                            $displayText = $self.Value.ToString()
                        }
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = if ($self.IsOpen) { "‚ñ≤" } else { "‚ñº" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                    -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = 0
                    if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                        $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                    }
                    
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                # Draw text before match
                                if ($matchIndex -gt 0) {
                                    Write-BufferString -X ($self.X + 2) -Y $y `
                                        -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                                }
                                
                                # Draw matching text highlighted
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                    -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                    -ForegroundColor (Get-ThemeColor "Warning")
                                
                                # Draw text after match
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) {
                                    Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                        -Text $text.Substring($afterMatch) -ForegroundColor $fg
                                }
                                
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                            -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = if ($i -eq $scrollPos) { "‚ñà" } else { "‚îÇ" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                                -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.FilteredOptions = $this.Options
                } else {
                    $this.FilteredOptions = @($this.Options | Where-Object {
                        $_.Display -like "*$($this.SearchText)*"
                    })
                    
                    # Add custom value option if allowed and no exact match
                    if ($this.AllowCustomValue) {
                        $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                        if (-not $exactMatch) {
                            $this.FilteredOptions = @(@{
                                Display = $this.SearchText
                                Value = $this.SearchText
                                IsCustom = $true
                            }) + $this.FilteredOptions
                        }
                    }
                }
                
                # Reset selection to first item
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    switch ($Key.Key) {
                        { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                            $self.IsOpen = $true
                            $self.SearchText = ""
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    return $false
                }
                
                # Handle open dropdown
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                    & $self.OnChange -NewValue $selected.Value -Option $selected
                                } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedIndex -gt 0) {
                            $self.SelectedIndex--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                            $self.SelectedIndex++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        SelectedValues = if ($null -ne $Props.SelectedValues) { $Props.SelectedValues } else { @() }
        Title = if ($null -ne $Props.Title) { $Props.Title } else { "Select items" }
        AllowSelectAll = if ($null -ne $Props.AllowSelectAll) { $Props.AllowSelectAll } else { $true }
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title) "
                
                # Select all option
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                    $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                        -ForegroundColor $fg
                    $currentY += 2
                }
                
                # Options
                $visibleHeight = $self.Height - 4
                if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                    $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                # Status line
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $maxIndex = $self.Options.Count - 1
                if ($self.AllowSelectAll) { $maxIndex++ }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                            $self.SelectedIndex = -1
                        } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $self.SelectedIndex
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4
                            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            # Toggle all
                            if ($self.SelectedValues.Count -eq $self.Options.Count) {
                                $self.SelectedValues = @()
                            } else {
                                $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                            }
                        } elseif ($self.SelectedIndex -ge 0) {
                            # Toggle individual
                            $option = $self.Options[$self.SelectedIndex]
                            if ($self.SelectedValues -contains $option.Value) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                            } else {
                                $self.SelectedValues += $option.Value
                            }
                        }
                        
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -SelectedValues $self.SelectedValues
                            } -AdditionalData @{ Component = $self.Name; SelectedValues = $self.SelectedValues }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock {
                                & $self.OnSubmit -SelectedValues $self.SelectedValues
                            } -AdditionalData @{ Component = $self.Name; SelectedValues = $self.SelectedValues }
                        }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        DecimalPlaces = if ($null -ne $Props.DecimalPlaces) { $Props.DecimalPlaces } else { 0 }
        IsFocusable = $true
        TextValue = (if ($null -ne $Props.Value) { $Props.Value } else { 0 }).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Value display
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) {
                    $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                # Cursor
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Spinner buttons
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "‚ñ≤" `
                    -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "‚ñº" `
                    -ForegroundColor $borderColor
                
                # Min/Max indicators
                if ($self.Value -le $self.Min) {
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "‚ä•" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
                if ($self.Value -ge $self.Max) {
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "‚ä§" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $newValue
                    } -AdditionalData @{ Component = $this.Name; NewValue = $newValue }
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -AdditionalData @{ Component = $self.Name; NewValue = $self.Value }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -AdditionalData @{ Component = $self.Name; NewValue = $self.Value }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.CursorPosition++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.TextValue.Length
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.CursorPosition -gt 0) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        & $self.ValidateAndUpdate -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 50 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        ShowValue = if ($null -ne $Props.ShowValue) { $Props.ShowValue } else { $true }
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                }
                
                # Calculate position
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                # Draw track
                $track = "‚îÄ" * $trackWidth
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
                
                # Draw filled portion
                if ($thumbPos -gt 0) {
                    $filled = "‚ïê" * $thumbPos
                    Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
                }
                
                # Draw thumb
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "‚óè" -ForegroundColor $fg
                
                # Draw bounds
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                # Show value
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch {
                Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    }
                    ([ConsoleKey]::Home) {
                        $self.Value = $self.Min
                    }
                    ([ConsoleKey]::End) {
                        $self.Value = $self.Max
                    }
                    ([ConsoleKey]::PageDown) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                    }
                    ([ConsoleKey]::PageUp) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $self.Value
                        } -AdditionalData @{ Component = $self.Name; NewValue = $self.Value }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)


####\components\IRenderable.psm1
# IRenderable Base Class - Stable Component Pattern
# Provides robust error handling and consistent rendering for all UI components

using namespace System.Text

class IRenderable {
    [string]$_componentName
    [string]$_lastRenderOutput
    [DateTime]$_lastRenderTime
    [bool]$_renderCacheValid = $false
    [int]$_renderCount = 0
    [hashtable]$_renderMetrics = @{}
    
    # AI: Constructor requires component name for error tracking
    IRenderable([string]$componentName) {
        if ([string]::IsNullOrWhiteSpace($componentName)) {
            throw "Component name cannot be null or empty"
        }
        $this._componentName = $componentName
        $this._lastRenderTime = [DateTime]::MinValue
        $this._renderMetrics = @{
            TotalRenders = 0
            LastRenderDuration = 0
            AverageRenderDuration = 0
            ErrorCount = 0
            LastError = $null
        }
    }
    
    # Public render method - handles all error cases and metrics
    [string] Render() {
        $startTime = Get-Date
        $this._renderCount++
        $this._renderMetrics.TotalRenders++
        
        try {
            # Validate component state before rendering
            $validationResult = $this.ValidateRender()
            if (-not $validationResult) {
                $errorMsg = "Component validation failed"
                $this._renderMetrics.ErrorCount++
                $this._renderMetrics.LastError = $errorMsg
                return "[$($this._componentName)] Validation Error: Component not ready for rendering"
            }
            
            # Call the derived class implementation
            $output = $this._RenderContent()
            
            # Validate output
            if ($null -eq $output) {
                $output = ""
            }
            
            # Cache successful render
            $this._lastRenderOutput = $output
            $this._lastRenderTime = $startTime
            $this._renderCacheValid = $true
            
            # Update metrics
            $duration = ([DateTime]::Now - $startTime).TotalMilliseconds
            $this._renderMetrics.LastRenderDuration = $duration
            
            # Calculate average duration
            if ($this._renderMetrics.TotalRenders -gt 0) {
                $oldAvg = $this._renderMetrics.AverageRenderDuration
                $this._renderMetrics.AverageRenderDuration = 
                    (($oldAvg * ($this._renderMetrics.TotalRenders - 1)) + $duration) / $this._renderMetrics.TotalRenders
            }
            
            return $output
        }
        catch {
            $this._renderMetrics.ErrorCount++
            $this._renderMetrics.LastError = $_.Exception.Message
            $this._renderCacheValid = $false
            
            # Log error with full context
            if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Render error in component '$($this._componentName)': $($_.Exception.Message)" -Data @{
                    Component = $this._componentName
                    Context = "Render"
                    Exception = $_.Exception
                    StackTrace = $_.ScriptStackTrace
                    RenderCount = $this._renderCount
                    LastSuccessfulRender = $this._lastRenderTime
                }
            }
            
            # Return safe error display instead of throwing
            return "[$($this._componentName)] Render Error: $($_.Exception.Message)"
        }
    }
    
    # Abstract method - must be implemented by derived classes
    hidden [string] _RenderContent() {
        throw "Component '$($this._componentName)' must implement the _RenderContent() method"
    }
    
    # Virtual method - can be overridden for custom validation
    [bool] ValidateRender() {
        # Default validation - component name exists
        return -not [string]::IsNullOrWhiteSpace($this._componentName)
    }
    
    # Utility method to clear render cache
    [void] ClearRenderCache() {
        $this._renderCacheValid = $false
        $this._lastRenderOutput = ""
    }
    
    # Get component performance metrics
    [hashtable] GetRenderMetrics() {
        return $this._renderMetrics.Clone()
    }
    
    # Get component name
    [string] GetComponentName() {
        return $this._componentName
    }
    
    # Check if component has cached valid render output
    [bool] HasValidRenderCache() {
        return $this._renderCacheValid
    }
    
    # Get last successful render output (useful for fallback displays)
    [string] GetLastRenderOutput() {
        return if ($this._renderCacheValid) { $this._lastRenderOutput } else { "" }
    }
    
    # Force a fresh render (clears cache first)
    [string] ForceRender() {
        $this.ClearRenderCache()
        return $this.Render()
    }
    
    # AI: Safe method to check if rendering should be attempted
    [bool] ShouldRender() {
        # Override in derived classes for custom logic
        # Default: always attempt render unless validation fails
        return $this.ValidateRender()
    }
    
    # AI: Method to get component status for debugging
    [hashtable] GetComponentStatus() {
        return @{
            ComponentName = $this._componentName
            RenderCount = $this._renderCount
            LastRenderTime = $this._lastRenderTime
            HasValidCache = $this._renderCacheValid
            Metrics = $this.GetRenderMetrics()
            IsReady = $this.ValidateRender()
        }
    }
}

# AI: Error handling wrapper specifically for use with IRenderable components
function global:Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Component,
        
        [Parameter(Mandatory = $true)]
        [string]$Context,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$AdditionalData = @{}
    )
    
    # Validate parameters
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown"
    }
    
    try {
        # Execute the script block
        & $ScriptBlock
    }
    catch {
        # Create enriched error data
        $errorData = @{
            Component = $Component
            Context = $Context
            Error = $_
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Merge additional data
        foreach ($key in $AdditionalData.Keys) {
            $errorData[$key] = $AdditionalData[$key]
        }
        
        # Log the error if logging is available
        if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$Component' during '$Context': $($_.Exception.Message)" -Data $errorData
        }
        
        # Re-throw the original exception
        throw
    }
}

# Export the base class and utility function
Export-ModuleMember -Function @('Invoke-WithErrorHandling')


####\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts
# AI: Implements Phase 2.2 of the class migration plan - Navigation Component

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import base classes
using module '.\ui-classes.psm1'

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if ($null -eq $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    # AI: Execute the action with error handling
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)" -Component "NavigationItem"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)" -Component "NavigationItem"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_" -Component "NavigationItem"
            throw
        }
    }
    
    # AI: Format the menu item for display
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = [System.Text.StringBuilder]::new()
        
        # Key with brackets
        [void]$display.Append($this.SetColor($this.KeyColor))
        [void]$display.Append("[$($this.Key)]")
        [void]$display.Append($this.ResetColor())
        
        # Label
        [void]$display.Append(" ")
        
        if ($this.Enabled) {
            [void]$display.Append($this.SetColor($this.LabelColor))
            [void]$display.Append($this.Label)
        }
        else {
            [void]$display.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$display.Append($this.Label)
            [void]$display.Append(" (Disabled)")
        }
        
        [void]$display.Append($this.ResetColor())
        
        # Description if requested
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            [void]$display.Append(" - ")
            [void]$display.Append($this.SetColor([ConsoleColor]::Gray))
            [void]$display.Append($this.Description)
            [void]$display.Append($this.ResetColor())
        }
        
        return $display.ToString()
    }
    
    # AI: Helper methods for ANSI colors
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Horizontal" # Horizontal or Vertical
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
    }
    
    [void] AddItem([NavigationItem]$item) {
        if ($null -eq $item) {
            throw [System.ArgumentNullException]::new("item", "NavigationItem cannot be null")
        }
        
        # AI: Check for duplicate keys
        $existingItem = $this.Items | Where-Object { $_.Key -eq $item.Key } | Select-Object -First 1
        if ($null -ne $existingItem) {
            throw [System.InvalidOperationException]::new("Navigation item with key '$($item.Key)' already exists")
        }
        
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.Items | Where-Object { $_.Key -eq $key.ToUpper() } | Select-Object -First 1
        if ($null -ne $item) {
            [void]$this.Items.Remove($item)
        }
    }
    
    [void] EnableItem([string]$key, [bool]$enabled = $true) {
        $item = $this.GetItem($key)
        if ($null -ne $item) {
            $item.Enabled = $enabled
        }
    }
    
    [void] ShowItem([string]$key, [bool]$visible = $true) {
        $item = $this.GetItem($key)
        if ($null -ne $item) {
            $item.Visible = $visible
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items | Where-Object { $_.Key -eq $key.ToUpper() } | Select-Object -First 1
    }
    
    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        
        if ($null -eq $item) {
            Write-Log -Level Debug -Message "Navigation key '$key' not found" -Component "NavigationMenu"
            return
        }
        
        if (-not $item.Visible) {
            Write-Log -Level Debug -Message "Navigation item '$key' is not visible" -Component "NavigationMenu"
            return
        }
        
        Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock {
            $item.Execute()
        }
    }
    
    [void] AddSeparator() {
        # AI: Add a special separator item
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Visible = $true
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }
    
    # AI: Build navigation menu with context-aware items
    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", {
                    $this.Services.Navigation.PushScreen("NewTaskScreen")
                }))
                
                $this.AddItem([NavigationItem]::new("P", "Projects", {
                    $this.Services.Navigation.PushScreen("ProjectListScreen")
                }))
                
                $this.AddItem([NavigationItem]::new("S", "Settings", {
                    $this.Services.Navigation.PushScreen("SettingsScreen")
                }))
                
                $this.AddSeparator()
                
                $this.AddItem([NavigationItem]::new("Q", "Quit", {
                    $this.Services.AppState.RequestExit()
                }))
            }
            
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", {
                    $this.Services.Navigation.PushScreen("NewTaskScreen")
                }))
                
                $this.AddItem([NavigationItem]::new("E", "Edit", {
                    # Context-specific logic would go here
                }))
                
                $this.AddItem([NavigationItem]::new("D", "Delete", {
                    # Context-specific logic would go here
                }))
                
                $this.AddItem([NavigationItem]::new("F", "Filter", {
                    $this.Services.Navigation.PushScreen("FilterScreen")
                }))
                
                $this.AddSeparator()
                
                $this.AddItem([NavigationItem]::new("B", "Back", {
                    $this.Services.Navigation.PopScreen()
                }))
            }
            
            default {
                # Default navigation for unknown contexts
                $this.AddItem([NavigationItem]::new("B", "Back", {
                    $this.Services.Navigation.PopScreen()
                }))
                
                $this.AddItem([NavigationItem]::new("H", "Home", {
                    $this.Services.Navigation.NavigateToRoot()
                }))
            }
        }
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "NavigationMenu" -Context "Render:$($this.Name)" -ScriptBlock {
            $menuBuilder = [System.Text.StringBuilder]::new()
            
            $visibleItems = $this.Items | Where-Object { $_.Visible }
            
            if ($visibleItems.Count -eq 0) {
                return ""
            }
            
            if ($this.Orientation -eq "Horizontal") {
                $this.RenderHorizontal($menuBuilder, $visibleItems)
            }
            else {
                $this.RenderVertical($menuBuilder, $visibleItems)
            }
            
            return $menuBuilder.ToString()
        }
    }
    
    hidden [void] RenderHorizontal([System.Text.StringBuilder]$builder, [object[]]$items) {
        $isFirst = $true
        
        foreach ($item in $items) {
            if (-not $isFirst) {
                [void]$builder.Append($this.SetColor($this.SeparatorColor))
                [void]$builder.Append($this.Separator)
                [void]$builder.Append($this.ResetColor())
            }
            
            [void]$builder.Append($item.FormatDisplay($this.ShowDescriptions))
            $isFirst = $false
        }
    }
    
    hidden [void] RenderVertical([System.Text.StringBuilder]$builder, [object[]]$items) {
        foreach ($item in $items) {
            [void]$builder.AppendLine($item.FormatDisplay($this.ShowDescriptions))
        }
    }
    
    # AI: Helper methods for ANSI colors
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\components\panel-classes.psm1
# Panel Classes Module - Specialized panel implementations
# Fixes the Context parameter binding issues by using strongly-typed classes

using namespace System.Collections.Generic
using namespace System.Text

# Import base classes
using module .\ui-classes.psm1

# Import utilities
Import-Module "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# BorderPanel - Panel with customizable border
class BorderPanel : Panel {
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [string] $BorderStyle = "Single" # Single, Double, Rounded
    hidden [hashtable] $BorderChars = @{
        Single = @{
            TopLeft = "‚îå"; TopRight = "‚îê"; BottomLeft = "‚îî"; BottomRight = "‚îò"
            Horizontal = "‚îÄ"; Vertical = "‚îÇ"
        }
        Double = @{
            TopLeft = "‚ïî"; TopRight = "‚ïó"; BottomLeft = "‚ïö"; BottomRight = "‚ïù"
            Horizontal = "‚ïê"; Vertical = "‚ïë"
        }
        Rounded = @{
            TopLeft = "‚ï≠"; TopRight = "‚ïÆ"; BottomLeft = "‚ï∞"; BottomRight = "‚ïØ"
            Horizontal = "‚îÄ"; Vertical = "‚îÇ"
        }
    }
    
    BorderPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {
        Write-Log -Level Debug -Message "Creating BorderPanel: $name at ($x,$y) size ($width,$height)"
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "BorderPanel" -Context "Render.$($this.Name)" -ScriptBlock {
            $output = [StringBuilder]::new()
            
            if ($this.ShowBorder) {
                [void]$output.Append($this.RenderBorder())
            }
            
            # Render children inside border
            $contentArea = $this.GetContentArea()
            foreach ($child in $this.Children) {
                if ($child.Visible) {
                    [void]$output.Append($child.Render())
                }
            }
            
            return $output.ToString()
        }
    }
    
    hidden [string] RenderBorder() {
        $chars = $this.BorderChars[$this.BorderStyle]
        $output = [StringBuilder]::new()
        
        # Top border
        [void]$output.Append("`e[$($this.Y);$($this.X)H")
        [void]$output.Append($chars.TopLeft)
        
        if (-not [string]::IsNullOrEmpty($this.Title)) {
            $titleText = " $($this.Title) "
            $titleLength = $titleText.Length
            $borderWidth = $this.Width - 2
            $leftPadding = [Math]::Max(0, ($borderWidth - $titleLength) / 2)
            
            [void]$output.Append($chars.Horizontal * [Math]::Floor($leftPadding))
            [void]$output.Append($titleText)
            [void]$output.Append($chars.Horizontal * [Math]::Ceiling($borderWidth - $titleLength - $leftPadding))
        } else {
            [void]$output.Append($chars.Horizontal * ($this.Width - 2))
        }
        
        [void]$output.Append($chars.TopRight)
        
        # Side borders
        for ($i = 1; $i -lt $this.Height - 1; $i++) {
            [void]$output.Append("`e[$($this.Y + $i);$($this.X)H")
            [void]$output.Append($chars.Vertical)
            [void]$output.Append("`e[$($this.Y + $i);$($this.X + $this.Width - 1)H")
            [void]$output.Append($chars.Vertical)
        }
        
        # Bottom border
        [void]$output.Append("`e[$($this.Y + $this.Height - 1);$($this.X)H")
        [void]$output.Append($chars.BottomLeft)
        [void]$output.Append($chars.Horizontal * ($this.Width - 2))
        [void]$output.Append($chars.BottomRight)
        
        return $output.ToString()
    }
    
    hidden [hashtable] GetContentArea() {
        if ($this.ShowBorder) {
            return @{
                X = $this.X + 1
                Y = $this.Y + 1
                Width = $this.Width - 2
                Height = $this.Height - 2
            }
        } else {
            return @{
                X = $this.X
                Y = $this.Y
                Width = $this.Width
                Height = $this.Height
            }
        }
    }
}

# ContentPanel - Panel that displays scrollable text content
class ContentPanel : Panel {
    [string[]] $Content = @()
    [int] $ScrollOffset = 0
    [bool] $WordWrap = $true
    [ConsoleColor] $TextColor = [ConsoleColor]::Gray
    
    ContentPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {
        Write-Log -Level Debug -Message "Creating ContentPanel: $name"
    }
    
    [void] SetContent([string[]]$content) {
        $this.Content = $content ?? @()
        $this.ScrollOffset = 0
        Write-Log -Level Debug -Message "ContentPanel $($this.Name): Set content with $($this.Content.Count) lines"
    }
    
    [void] AppendContent([string]$text) {
        $this.Content += $text
    }
    
    [void] ClearContent() {
        $this.Content = @()
        $this.ScrollOffset = 0
    }
    
    [void] ScrollUp([int]$lines = 1) {
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset - $lines)
    }
    
    [void] ScrollDown([int]$lines = 1) {
        $maxScroll = [Math]::Max(0, $this.Content.Count - $this.Height)
        $this.ScrollOffset = [Math]::Min($maxScroll, $this.ScrollOffset + $lines)
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "ContentPanel" -Context "Render.$($this.Name)" -ScriptBlock {
            $output = [StringBuilder]::new()
            
            # Get visible lines
            $visibleLines = $this.Height
            $endLine = [Math]::Min($this.Content.Count, $this.ScrollOffset + $visibleLines)
            
            for ($i = $this.ScrollOffset; $i -lt $endLine; $i++) {
                $line = $this.Content[$i]
                $y = $this.Y + ($i - $this.ScrollOffset)
                
                [void]$output.Append("`e[$y;$($this.X)H")
                
                # Truncate or wrap line based on WordWrap setting
                if ($this.WordWrap -and $line.Length -gt $this.Width) {
                    $wrappedLine = $line.Substring(0, $this.Width)
                    [void]$output.Append($wrappedLine)
                } else {
                    $displayLine = if ($line.Length -gt $this.Width) {
                        $line.Substring(0, $this.Width - 3) + "..."
                    } else {
                        $line.PadRight($this.Width)
                    }
                    [void]$output.Append($displayLine)
                }
            }
            
            # Clear remaining lines
            for ($i = $endLine - $this.ScrollOffset; $i -lt $visibleLines; $i++) {
                $y = $this.Y + $i
                [void]$output.Append("`e[$y;$($this.X)H")
                [void]$output.Append(" " * $this.Width)
            }
            
            return $output.ToString()
        }
    }
}

# Export classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\components\table-class.psm1
# Table Component Classes Module for PMC Terminal v5
# Implements table display functionality with column formatting and selection
# AI: Implements Phase 2.1 of the class migration plan - Table Component

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import base classes
using module '.\ui-classes.psm1'

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# TableColumn - Defines a single column in a table
class TableColumn {
    [string] $Name
    [string] $Header
    [int] $Width
    [scriptblock] $Formatter
    [string] $Alignment = "Left" # Left, Center, Right
    [bool] $Sortable = $true
    
    TableColumn([string]$name, [string]$header, [int]$width) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("Column name cannot be null or empty")
        }
        if ($width -le 0) {
            throw [System.ArgumentException]::new("Column width must be positive")
        }
        
        $this.Name = $name
        $this.Header = $header
        $this.Width = $width
    }
    
    # AI: Format a value according to column settings
    [string] FormatValue([object]$value) {
        $formattedValue = ""
        
        if ($null -ne $this.Formatter) {
            try {
                $formattedValue = & $this.Formatter $value
            }
            catch {
                Write-Log -Level Warning -Message "Column formatter failed: $_" -Component "TableColumn"
                $formattedValue = $value.ToString()
            }
        }
        else {
            $formattedValue = if ($null -eq $value) { "" } else { $value.ToString() }
        }
        
        # Apply width constraints
        if ($formattedValue.Length -gt $this.Width) {
            $formattedValue = $formattedValue.Substring(0, $this.Width - 3) + "..."
        }
        
        # Apply alignment
        switch ($this.Alignment) {
            "Center" {
                $padding = $this.Width - $formattedValue.Length
                $padLeft = [Math]::Floor($padding / 2)
                $padRight = $padding - $padLeft
                $formattedValue = (' ' * $padLeft) + $formattedValue + (' ' * $padRight)
            }
            "Right" {
                $formattedValue = $formattedValue.PadLeft($this.Width)
            }
            default {
                $formattedValue = $formattedValue.PadRight($this.Width)
            }
        }
        
        return $formattedValue
    }
}

# Table - Component for displaying tabular data with selection and scrolling
class Table : Component {
    [TableColumn[]] $Columns = @()
    [object[]] $Data = @()
    [int] $SelectedIndex = 0
    [bool] $ShowHeaders = $true
    [bool] $ShowRowNumbers = $false
    [ConsoleColor] $HeaderColor = [ConsoleColor]::Cyan
    [ConsoleColor] $SelectedRowColor = [ConsoleColor]::Yellow
    [ConsoleColor] $TextColor = [ConsoleColor]::White
    [int] $ScrollOffset = 0
    [int] $MaxVisibleRows = 10
    [string] $SortColumn = ""
    [bool] $SortDescending = $false
    
    Table([string]$name) : base($name) {
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        if ($null -eq $columns) {
            throw [System.ArgumentNullException]::new("columns", "Columns cannot be null")
        }
        if ($columns.Count -eq 0) {
            throw [System.ArgumentException]::new("Table must have at least one column")
        }
        
        $this.Columns = $columns
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = if ($null -eq $data) { @() } else { $data }
        
        # Reset selection if out of bounds
        if ($this.SelectedIndex -ge $this.Data.Count) {
            $this.SelectedIndex = if ($this.Data.Count -gt 0) { $this.Data.Count - 1 } else { 0 }
        }
        
        # Apply current sort if set
        if (-not [string]::IsNullOrWhiteSpace($this.SortColumn)) {
            $this.SortData($this.SortColumn, $this.SortDescending)
        }
    }
    
    [void] SelectNext() {
        if ($this.SelectedIndex -lt $this.Data.Count - 1) {
            $this.SelectedIndex++
            $this.EnsureSelectedVisible()
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
            $this.EnsureSelectedVisible()
        }
    }
    
    [void] SelectFirst() {
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
    }
    
    [void] SelectLast() {
        if ($this.Data.Count -gt 0) {
            $this.SelectedIndex = $this.Data.Count - 1
            $this.EnsureSelectedVisible()
        }
    }
    
    [object] GetSelectedItem() {
        if ($this.Data.Count -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Data.Count) {
            return $this.Data[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SortData([string]$columnName, [bool]$descending = $false) {
        $column = $this.Columns | Where-Object { $_.Name -eq $columnName } | Select-Object -First 1
        
        if ($null -eq $column) {
            Write-Log -Level Warning -Message "Sort column '$columnName' not found" -Component "Table"
            return
        }
        
        if (-not $column.Sortable) {
            Write-Log -Level Warning -Message "Column '$columnName' is not sortable" -Component "Table"
            return
        }
        
        $this.SortColumn = $columnName
        $this.SortDescending = $descending
        
        try {
            $this.Data = if ($descending) {
                $this.Data | Sort-Object -Property $columnName -Descending
            }
            else {
                $this.Data | Sort-Object -Property $columnName
            }
        }
        catch {
            Write-Log -Level Error -Message "Failed to sort by column '$columnName': $_" -Component "Table"
        }
    }
    
    # AI: Ensure selected row is visible in viewport
    hidden [void] EnsureSelectedVisible() {
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $this.MaxVisibleRows)) {
            $this.ScrollOffset = $this.SelectedIndex - $this.MaxVisibleRows + 1
        }
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "Table" -Context "Render:$($this.Name)" -ScriptBlock {
            if ($this.Columns.Count -eq 0) {
                return ""
            }
            
            $tableBuilder = [System.Text.StringBuilder]::new()
            $currentY = 0
            
            # Render headers if enabled
            if ($this.ShowHeaders) {
                [void]$tableBuilder.Append($this.RenderHeaders())
                $currentY++
                
                # Header separator
                [void]$tableBuilder.Append($this.RenderSeparator())
                $currentY++
            }
            
            # Render data rows
            $endRow = [Math]::Min($this.ScrollOffset + $this.MaxVisibleRows, $this.Data.Count)
            
            for ($i = $this.ScrollOffset; $i -lt $endRow; $i++) {
                $isSelected = ($i -eq $this.SelectedIndex)
                [void]$tableBuilder.Append($this.RenderRow($this.Data[$i], $i, $isSelected))
                $currentY++
            }
            
            # Fill empty rows if data doesn't fill viewport
            $emptyRows = $this.MaxVisibleRows - ($endRow - $this.ScrollOffset)
            for ($i = 0; $i -lt $emptyRows; $i++) {
                [void]$tableBuilder.Append($this.RenderEmptyRow())
                $currentY++
            }
            
            return $tableBuilder.ToString()
        }
    }
    
    hidden [string] RenderHeaders() {
        $headerBuilder = [System.Text.StringBuilder]::new()
        
        [void]$headerBuilder.Append($this.SetColor($this.HeaderColor))
        
        if ($this.ShowRowNumbers) {
            [void]$headerBuilder.Append(" # ".PadRight(5))
            [void]$headerBuilder.Append(" | ")
        }
        
        foreach ($column in $this.Columns) {
            $headerText = $column.Header
            
            # Add sort indicator
            if ($column.Name -eq $this.SortColumn) {
                $sortIndicator = if ($this.SortDescending) { " ‚ñº" } else { " ‚ñ≤" }
                $headerText += $sortIndicator
            }
            
            [void]$headerBuilder.Append($column.FormatValue($headerText))
            [void]$headerBuilder.Append(" | ")
        }
        
        [void]$headerBuilder.Append($this.ResetColor())
        [void]$headerBuilder.AppendLine()
        
        return $headerBuilder.ToString()
    }
    
    hidden [string] RenderSeparator() {
        $separatorBuilder = [System.Text.StringBuilder]::new()
        
        if ($this.ShowRowNumbers) {
            [void]$separatorBuilder.Append("-" * 5)
            [void]$separatorBuilder.Append("-+-")
        }
        
        foreach ($column in $this.Columns) {
            [void]$separatorBuilder.Append("-" * $column.Width)
            [void]$separatorBuilder.Append("-+-")
        }
        
        # Remove last separator
        if ($separatorBuilder.Length -ge 3) {
            $separatorBuilder.Length -= 3
        }
        
        [void]$separatorBuilder.AppendLine()
        
        return $separatorBuilder.ToString()
    }
    
    hidden [string] RenderRow([object]$rowData, [int]$rowIndex, [bool]$isSelected) {
        $rowBuilder = [System.Text.StringBuilder]::new()
        
        $rowColor = if ($isSelected) { $this.SelectedRowColor } else { $this.TextColor }
        [void]$rowBuilder.Append($this.SetColor($rowColor))
        
        if ($this.ShowRowNumbers) {
            [void]$rowBuilder.Append(($rowIndex + 1).ToString().PadRight(5))
            [void]$rowBuilder.Append(" | ")
        }
        
        foreach ($column in $this.Columns) {
            $value = $null
            
            # AI: Safe property access with error handling
            try {
                if ($null -ne $rowData) {
                    $value = $rowData.($column.Name)
                }
            }
            catch {
                Write-Log -Level Warning -Message "Failed to access property '$($column.Name)': $_" -Component "Table"
                $value = "ERROR"
            }
            
            [void]$rowBuilder.Append($column.FormatValue($value))
            [void]$rowBuilder.Append(" | ")
        }
        
        [void]$rowBuilder.Append($this.ResetColor())
        [void]$rowBuilder.AppendLine()
        
        return $rowBuilder.ToString()
    }
    
    hidden [string] RenderEmptyRow() {
        $emptyBuilder = [System.Text.StringBuilder]::new()
        
        if ($this.ShowRowNumbers) {
            [void]$emptyBuilder.Append(" " * 5)
            [void]$emptyBuilder.Append(" | ")
        }
        
        foreach ($column in $this.Columns) {
            [void]$emptyBuilder.Append(" " * $column.Width)
            [void]$emptyBuilder.Append(" | ")
        }
        
        [void]$emptyBuilder.AppendLine()
        
        return $emptyBuilder.ToString()
    }
    
    # AI: Helper methods for ANSI colors
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\components\tui-components.psm1
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture
# LEGACY New-TuiPanel has been REMOVED.

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
                Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "Label Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Label HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Button" }
        Name = $Props.Name
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor
                    
                $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
                Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                    -ForegroundColor $fgColor -BackgroundColor $bgColor
            } catch {
                Write-Log -Level Error -Message "Button Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    if ($self.OnClick) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnClick" -Context "OnClick" -AdditionalData @{ Component = $self.Name; Key = $Key } -ScriptBlock {
                            & $self.OnClick
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Button HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "" }
        MaxLength = if ($null -ne $Props.MaxLength) { $Props.MaxLength } else { 100 }
        Name = $Props.Name
        
        # Internal State
        CursorPosition = if ($null -ne $Props.CursorPosition) { $Props.CursorPosition } else { 0 }
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = if ($self.Text) { $self.Text } else { "" }
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                    $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
                }
                
                $maxDisplayLength = $self.Width - 4
                if ($displayText.Length -gt $maxDisplayLength) {
                    $displayText = $displayText.Substring(0, $maxDisplayLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            } catch {
                Write-Log -Level Error -Message "TextBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $text = if ($self.Text) { $self.Text } else { "" }
                $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
                $oldText = $text
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) { 
                        if ($cursorPos -gt 0) { 
                            $text = $text.Remove($cursorPos - 1, 1)
                            $cursorPos-- 
                        }
                    }
                    ([ConsoleKey]::Delete) { 
                        if ($cursorPos -lt $text.Length) { 
                            $text = $text.Remove($cursorPos, 1) 
                        }
                    }
                    ([ConsoleKey]::LeftArrow) { 
                        if ($cursorPos -gt 0) { $cursorPos-- }
                    }
                    ([ConsoleKey]::RightArrow) { 
                        if ($cursorPos -lt $text.Length) { $cursorPos++ }
                    }
                    ([ConsoleKey]::Home) { $cursorPos = 0 }
                    ([ConsoleKey]::End) { $cursorPos = $text.Length }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Remove newlines for single-line textbox
                                    $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                    
                                    # Insert as much as will fit
                                    $remainingSpace = $self.MaxLength - $text.Length
                                    if ($remainingSpace -gt 0) {
                                        $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                            $clipboardText.Substring(0, $remainingSpace)
                                        } else {
                                            $clipboardText
                                        }
                                        
                                        $text = $text.Insert($cursorPos, $toInsert)
                                        $cursorPos += $toInsert.Length
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextBox clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                                $text = $text.Insert($cursorPos, $Key.KeyChar)
                                $cursorPos++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                    $self.Text = $text
                    $self.CursorPosition = $cursorPos
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $text } -ScriptBlock {
                            & $self.OnChange -NewValue $text
                        }
                    }
                    Request-TuiRefresh
                }
                return $true
            } catch {
                Write-Log -Level Error -Message "TextBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Checkbox" }
        Checked = if ($null -ne $Props.Checked) { $Props.Checked } else { $false }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
                Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "CheckBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    $self.Checked = -not $self.Checked
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $self.Checked } -ScriptBlock {
                            & $self.OnChange -NewValue $self.Checked 
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "CheckBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Select..." }
        Name = $Props.Name
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Placeholder
                if ($self.Value -and $self.Options) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) { $displayText = $selected.Display }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                $indicator = if ($self.IsOpen) { "‚ñ≤" } else { "‚ñº" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
                
                if ($self.IsOpen -and $self.Options.Count -gt 0) {
                    $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                    Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $displayCount = [Math]::Min($self.Options.Count, 6)
                    for ($i = 0; $i -lt $displayCount; $i++) {
                        $option = $self.Options[$i]
                        $y = $self.Y + 4 + $i
                        $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                        $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) { 
                            $text = $text.Substring(0, $self.Width - 7) + "..." 
                        }
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        Request-TuiRefresh
                        return $true
                    }
                } else {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { 
                            if ($self.SelectedIndex -gt 0) { 
                                $self.SelectedIndex--
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::DownArrow) { 
                            if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                                $self.SelectedIndex++
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::Enter) {
                            if ($self.Options.Count -gt 0) {
                                $selected = $self.Options[$self.SelectedIndex]
                                $self.Value = $selected.Value
                                
                                if ($self.OnChange) { 
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value } -ScriptBlock {
                                        & $self.OnChange -NewValue $selected.Value 
                                    }
                                }
                            }
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Escape) { 
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        ShowPercent = if ($null -ne $Props.ShowPercent) { $Props.ShowPercent } else { $false }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
                $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
                $empty = ($self.Width - 2) - $filled
                
                $bar = "‚ñà" * $filled + "‚ñë" * $empty
                Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
                
                if ($self.ShowPercent) {
                    $percentText = "$([Math]::Round($percent))%"
                    $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "ProgressBar Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "ProgressBar HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 6 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Enter text..." }
        WrapText = if ($null -ne $Props.WrapText) { $Props.WrapText } else { $true }
        Name = $Props.Name
        
        # Internal State
        Lines = @((if ($null -ne $Props.Text) { $Props.Text } else { "" }) -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $innerWidth = $self.Width - 4
                $innerHeight = $self.Height - 2
                $displayLines = @()
                if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
                
                foreach ($line in $self.Lines) {
                    if ($self.WrapText -and $line.Length -gt $innerWidth) {
                        for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                            $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                        }
                    } else { 
                        $displayLines += $line 
                    }
                }
                
                if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                    Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                    return
                }
                
                $startLine = $self.ScrollOffset
                $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
                
                for ($i = $startLine; $i -le $endLine; $i++) {
                    $y = $self.Y + 1 + ($i - $startLine)
                    $line = $displayLines[$i]
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $line
                }
                
                if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                    $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                    $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                    Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
                
                if ($displayLines.Count -gt $innerHeight) {
                    $scrollbarHeight = $innerHeight
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "‚ñà" } else { "‚îÇ" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TextArea Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $lines = $self.Lines
                $cursorY = $self.CursorY
                $cursorX = $self.CursorX
                $innerHeight = $self.Height - 2
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($cursorY -gt 0) {
                            $cursorY--
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $cursorY 
                            }
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($cursorY -lt $lines.Count - 1) {
                            $cursorY++
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                $self.ScrollOffset = $cursorY - $innerHeight + 1 
                            }
                        }
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($cursorX -gt 0) { 
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) { 
                            $cursorY--
                            $cursorX = $lines[$cursorY].Length 
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $cursorX++ 
                        } elseif ($cursorY -lt $lines.Count - 1) { 
                            $cursorY++
                            $cursorX = 0 
                        }
                    }
                    ([ConsoleKey]::Home) { $cursorX = 0 }
                    ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                    ([ConsoleKey]::Enter) {
                        $currentLine = $lines[$cursorY]
                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                        $afterCursor = $currentLine.Substring($cursorX)
                        $lines[$cursorY] = $beforeCursor
                        $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                        $cursorY++
                        $cursorX = 0
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($cursorX -gt 0) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) {
                            $prevLineLength = $lines[$cursorY - 1].Length
                            $lines[$cursorY - 1] += $lines[$cursorY]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                            $cursorY--
                            $cursorX = $prevLineLength
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                        } elseif ($cursorY -lt $lines.Count - 1) {
                            $lines[$cursorY] += $lines[$cursorY + 1]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                        }
                    }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Split clipboard text into lines
                                    $clipboardLines = $clipboardText -split '[\r\n]+'
                                    
                                    if ($clipboardLines.Count -eq 1) {
                                        # Single line paste - insert at cursor
                                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                        $cursorX += $clipboardLines[0].Length
                                    } else {
                                        # Multi-line paste
                                        $currentLine = $lines[$cursorY]
                                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                                        $afterCursor = $currentLine.Substring($cursorX)
                                        
                                        # First line
                                        $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                        
                                        # Insert middle lines
                                        $insertLines = @()
                                        for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                            $insertLines += $clipboardLines[$i]
                                        }
                                        
                                        # Last line
                                        $lastLine = $clipboardLines[-1] + $afterCursor
                                        $insertLines += $lastLine
                                        
                                        # Insert all new lines
                                        $newLines = @()
                                        for ($i = 0; $i -le $cursorY; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        $newLines += $insertLines
                                        for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        
                                        $lines = $newLines
                                        $cursorY += $clipboardLines.Count - 1
                                        $cursorX = $clipboardLines[-1].Length
                                    }
                                    
                                    # Adjust scroll if needed
                                    $innerHeight = $self.Height - 2
                                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextArea clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar)) {
                                $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                                $cursorX++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                $self.Lines = $lines
                $self.CursorX = $cursorX
                $self.CursorY = $cursorY
                $self.Text = $lines -join "`n"
                
                if ($self.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $self.Text } -ScriptBlock {
                        & $self.OnChange -NewValue $self.Text 
                    }
                }
                Request-TuiRefresh
                return $true
            } catch {
                Write-Log -Level Error -Message "TextArea HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Format = if ($null -ne $Props.Format) { $Props.Format } else { "yyyy-MM-dd" }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                $dateStr = $self.Value.ToString($self.Format)
                
                # Truncate date string if too long
                $maxLength = $self.Width - 6
                if ($dateStr.Length -gt $maxLength) {
                    $dateStr = $dateStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "üìÖ" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "DatePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $date = $self.Value
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                    ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                    ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                    ([ConsoleKey]::Home)      { $date = Get-Date }
                    ([ConsoleKey]::T) { 
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                            $date = Get-Date 
                        } else { 
                            $handled = $false 
                        } 
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Value = $date
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $date } -ScriptBlock {
                            & $self.OnChange -NewValue $date 
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "DatePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 15 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Hour = if ($null -ne $Props.Hour) { $Props.Hour } else { 0 }
        Minute = if ($null -ne $Props.Minute) { $Props.Minute } else { 0 }
        Format24H = if ($null -ne $Props.Format24H) { $Props.Format24H } else { $true }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                if ($self.Format24H) { 
                    $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
                } else {
                    $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                    $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                    $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
                }
                
                # Truncate time string if too long
                $maxLength = $self.Width - 6
                if ($timeStr.Length -gt $maxLength) {
                    $timeStr = $timeStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "‚è∞" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "TimePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $hour = $self.Hour
                $minute = $self.Minute
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        $minute = ($minute + 15) % 60
                        if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        $minute = ($minute - 15 + 60) % 60
                        if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                    }
                    ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                    ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Hour = $hour
                    $self.Minute = $minute
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewHour = $hour; NewMinute = $minute } -ScriptBlock {
                            & $self.OnChange -NewHour $hour -NewMinute $minute 
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "TimePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 60 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 15 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        Rows = if ($null -ne $Props.Rows) { $Props.Rows } else { @() }
        Name = $Props.Name
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $totalWidth = $self.Width - 4
                $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
                $headerY = $self.Y + 1
                $currentX = $self.X + 2
                
                # Draw headers
                foreach ($col in $self.Columns) {
                    $header = $col.Header
                    if ($col.Name -eq $self.SortColumn) { 
                        $arrow = if ($self.SortAscending) { "‚ñ≤" } else { "‚ñº" }
                        $header = "$header $arrow" 
                    }
                    if ($header.Length -gt $colWidth - 1) { 
                        $header = $header.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                    $currentX += $colWidth
                }
                
                # Header separator
                Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("‚îÄ" * ($self.Width - 2)) -ForegroundColor $borderColor
                
                # Draw rows
                $visibleRows = $self.Height - 5
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.Rows[$i]
                    $rowY = ($headerY + 2) + ($i - $startIdx)
                    $currentX = $self.X + 2
                    $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                    $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    
                    if ($isSelected) { 
                        Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                    }
                    
                    foreach ($col in $self.Columns) {
                        $value = $row.($col.Name)
                        if ($null -eq $value) { $value = "" }
                        $text = $value.ToString()
                        if ($text.Length -gt $colWidth - 1) { 
                            $text = $text.Substring(0, $colWidth - 4) + "..." 
                        }
                        Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                        $currentX += $colWidth
                    }
                }
                
                # Scrollbar
                if ($self.Rows.Count -gt $visibleRows) {
                    $scrollbarHeight = $visibleRows
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "‚ñà" } else { "‚îÇ" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.Rows.Count -eq 0) { return $false }
                
                $visibleRows = $self.Height - 5
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedRow -gt 0) { 
                            $self.SelectedRow--
                            if ($self.SelectedRow -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $self.SelectedRow 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                            $self.SelectedRow++
                            if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                                $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::PageUp) { 
                        $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                        $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::PageDown) { 
                        $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                        $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Home) { 
                        $self.SelectedRow = 0
                        $self.ScrollOffset = 0
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::End) { 
                        $self.SelectedRow = $self.Rows.Count - 1
                        $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Enter) { 
                        if ($self.OnRowSelect) { 
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -Context "OnRowSelect" -AdditionalData @{ Component = $self.Name; SelectedRow = $self.SelectedRow } -ScriptBlock {
                                & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                            }
                        } 
                    }
                    default {
                        if ($Key.KeyChar -match '\d') {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $colName = $self.Columns[$colIndex].Name
                                if ($self.SortColumn -eq $colName) { 
                                    $self.SortAscending = -not $self.SortAscending 
                                } else { 
                                    $self.SortColumn = $colName
                                    $self.SortAscending = $true 
                                }
                                $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                                Request-TuiRefresh
                            }
                        } else { 
                            $handled = $false 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        ChartType = if ($null -ne $Props.ChartType) { $Props.ChartType } else { "Bar" }
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        ShowValues = if ($null -ne $Props.ShowValues) { $Props.ShowValues } else { $true }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
                
                switch ($self.ChartType) {
                    "Bar" {
                        $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $chartHeight = $self.Height - 2
                        $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                        
                        for ($i = 0; $i -lt $self.Data.Count; $i++) {
                            $item = $self.Data[$i]
                            $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                            $barX = $self.X + 2 + ($i * $barWidth)
                            
                            for ($y = 0; $y -lt $barHeight; $y++) { 
                                $barY = $self.Y + $self.Height - 2 - $y
                                Write-BufferString -X $barX -Y $barY -Text ("‚ñà" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                            }
                            
                            if ($item.Label -and $barWidth -gt 3) { 
                                $label = $item.Label
                                if ($label.Length -gt $barWidth - 1) { 
                                    $label = $label.Substring(0, $barWidth - 2) 
                                }
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                            }
                            
                            if ($self.ShowValues -and $barHeight -gt 0) { 
                                $valueText = $item.Value.ToString()
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                            }
                        }
                    }
                    "Sparkline" {
                        $width = $self.Width - 2
                        $height = $self.Height - 1
                        $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        
                        $sparkChars = @(" ", " ", "‚ñÇ", "‚ñÉ", "‚ñÑ", "‚ñÖ", "‚ñÜ", "‚ñá", "‚ñà")
                        $sparkline = ""
                        
                        foreach ($value in $self.Data) { 
                            $normalized = ($value / $maxValue)
                            $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                            $sparkline += $sparkChars[$charIndex] 
                        }
                        
                        if ($sparkline.Length -gt $width) { 
                            $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                        } else { 
                            $sparkline = $sparkline.PadLeft($width) 
                        }
                        
                        Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Chart Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Chart HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Container Components

# FIX: REMOVED the legacy New-TuiPanel function entirely.
# All code should now use the more specific panels from layout/panels.psm1.

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart'
)


####\components\ui-classes.psm1
# UI Base Classes Module for PMC Terminal v5
# Provides the foundational class hierarchy for all UI components
# AI: Implements Phase 1.1 of the class migration plan - base UI element hierarchy

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import error handling utilities
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# Base UI Element - foundation for all visual components
class UIElement {
    [string] $Name
    [hashtable] $Style = @{}
    [bool] $Visible = $true
    [bool] $Enabled = $true
    
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("UIElement name cannot be null or empty")
        }
        $this.Name = $name
    }
    
    [string] Render() {
        throw [System.NotImplementedException]::new("Render() must be implemented by derived class")
    }
    
    # AI: Added for debugging and logging purposes
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# Base Component - container that can hold child elements
class Component : UIElement {
    [object] $Parent
    [System.Collections.Generic.List[UIElement]] $Children
    
    Component([string]$name) : base($name) {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    [void] AddChild([UIElement]$child) {
        if ($null -eq $child) {
            throw [System.ArgumentNullException]::new("child", "Cannot add null child to component")
        }
        
        # AI: Prevent circular references
        if ($child -eq $this) {
            throw [System.InvalidOperationException]::new("Component cannot be its own child")
        }
        
        $child.Parent = $this
        $this.Children.Add($child)
    }
    
    [void] RemoveChild([UIElement]$child) {
        if ($null -ne $child) {
            $child.Parent = $null
            [void]$this.Children.Remove($child)
        }
    }
    
    [void] RemoveAllChildren() {
        foreach ($child in $this.Children) {
            $child.Parent = $null
        }
        $this.Children.Clear()
    }
    
    # AI: Helper method to find child by name
    [UIElement] FindChildByName([string]$childName) {
        foreach ($child in $this.Children) {
            if ($child.Name -eq $childName) {
                return $child
            }
            # Recursive search if child is also a component
            if ($child -is [Component]) {
                $found = $child.FindChildByName($childName)
                if ($null -ne $found) {
                    return $found
                }
            }
        }
        return $null
    }
}

# Base Panel - rectangular area with position and dimensions
class Panel : Component {
    [int] $X
    [int] $Y
    [int] $Width
    [int] $Height
    [string] $Title = ""
    [bool] $ShowBorder = $true
    
    Panel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name) {
        # AI: Validate dimensions
        if ($width -le 0 -or $height -le 0) {
            throw [System.ArgumentException]::new("Panel width and height must be positive values")
        }
        if ($x -lt 0 -or $y -lt 0) {
            throw [System.ArgumentException]::new("Panel position cannot be negative")
        }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
    }
    
    # AI: Helper to check if a point is within the panel bounds
    [bool] ContainsPoint([int]$pointX, [int]$pointY) {
        return ($pointX -ge $this.X -and 
                $pointX -lt ($this.X + $this.Width) -and
                $pointY -ge $this.Y -and 
                $pointY -lt ($this.Y + $this.Height))
    }
    
    # AI: Get the inner content area (accounting for borders)
    [hashtable] GetContentArea() {
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height
        
        if ($this.ShowBorder) {
            $contentX += 1
            $contentY += 1
            $contentWidth -= 2
            $contentHeight -= 2
        }
        
        return @{
            X = $contentX
            Y = $contentY
            Width = $contentWidth
            Height = $contentHeight
        }
    }
}

# Base Screen - top-level container for a complete UI view
class Screen : UIElement {
    [hashtable] $Services
    [System.Collections.Generic.Dictionary[string, object]] $State
    [System.Collections.Generic.List[Panel]] $Panels
    hidden [System.Collections.Generic.Dictionary[string, string]] $EventSubscriptions
    [bool] $IsInitialized = $false
    
    Screen([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        
        # AI: Validate required services
        $requiredServices = @('Navigation', 'DataManager')
        foreach ($service in $requiredServices) {
            if (-not $services.ContainsKey($service)) {
                throw [System.ArgumentException]::new("services", "Required service '$service' not found")
            }
        }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[Panel]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    # Virtual method - override in derived classes
    [void] Initialize() {
        # AI: Base implementation logs initialization
        Write-Log -Level Debug -Message "Initializing screen: $($this.Name)" -Component $this.Name
    }
    
    # Virtual method - override in derived classes
    [void] Cleanup() {
        # AI: Unsubscribe from all events to prevent memory leaks
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
                Write-Log -Level Debug -Message "Unsubscribed from event: $($kvp.Key)" -Component $this.Name
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event: $($kvp.Key)" -Component $this.Name
            }
        }
        $this.EventSubscriptions.Clear()
        
        # Clear panels
        $this.Panels.Clear()
        
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)" -Component $this.Name
    }
    
    # Virtual method - override in derived classes
    [void] HandleInput([ConsoleKeyInfo]$key) {
        # AI: Base implementation does nothing
    }
    
    # AI: Helper method for safe event subscription
    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [System.ArgumentException]::new("Event name cannot be null or empty")
        }
        if ($null -eq $action) {
            throw [System.ArgumentNullException]::new("action", "Event action cannot be null")
        }
        
        $subscriptionId = Subscribe-Event -EventName $eventName -Action $action
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
    
    # AI: Helper to add panel with validation
    [void] AddPanel([Panel]$panel) {
        if ($null -eq $panel) {
            throw [System.ArgumentNullException]::new("panel", "Cannot add null panel to screen")
        }
        $this.Panels.Add($panel)
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\layout\panels-class.psm1
# Panel Classes Module for PMC Terminal v5
# Implements specialized panel types for the TUI layout system
# AI: Implements Phase 1.2 of the class migration plan - layout components

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import base classes
using module '..\components\ui-classes.psm1'

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# BorderPanel - Panel with customizable border rendering
class BorderPanel : Panel {
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [string] $BorderStyle = "Single" # Single, Double, Rounded
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    
    # AI: Border character sets for different styles
    hidden static [hashtable] $BorderChars = @{
        Single = @{
            TopLeft = '‚îå'; TopRight = '‚îê'; BottomLeft = '‚îî'; BottomRight = '‚îò'
            Horizontal = '‚îÄ'; Vertical = '‚îÇ'
        }
        Double = @{
            TopLeft = '‚ïî'; TopRight = '‚ïó'; BottomLeft = '‚ïö'; BottomRight = '‚ïù'
            Horizontal = '‚ïê'; Vertical = '‚ïë'
        }
        Rounded = @{
            TopLeft = '‚ï≠'; TopRight = '‚ïÆ'; BottomLeft = '‚ï∞'; BottomRight = '‚ïØ'
            Horizontal = '‚îÄ'; Vertical = '‚îÇ'
        }
    }
    
    BorderPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "BorderPanel" -Context "Render:$($this.Name)" -ScriptBlock {
            $renderedContent = [System.Text.StringBuilder]::new()
            
            if ($this.ShowBorder) {
                [void]$renderedContent.Append($this.RenderBorder())
            }
            
            # Render children within content area
            if ($this.Children.Count -gt 0) {
                [void]$renderedContent.Append($this.RenderContent())
            }
            
            return $renderedContent.ToString()
        }
    }
    
    hidden [string] RenderBorder() {
        $borderBuilder = [System.Text.StringBuilder]::new()
        $chars = [BorderPanel]::BorderChars[$this.BorderStyle]
        
        if ($null -eq $chars) {
            Write-Log -Level Warning -Message "Unknown border style: $($this.BorderStyle), defaulting to Single" -Component "BorderPanel"
            $chars = [BorderPanel]::BorderChars["Single"]
        }
        
        # Top border
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y))
        [void]$borderBuilder.Append($this.SetColor($this.BorderColor))
        [void]$borderBuilder.Append($chars.TopLeft)
        
        # Title handling
        $horizontalSpace = $this.Width - 2
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $titleText = " $($this.Title) "
            if ($titleText.Length -gt $horizontalSpace) {
                $titleText = $titleText.Substring(0, $horizontalSpace)
            }
            
            $paddingBefore = [Math]::Floor(($horizontalSpace - $titleText.Length) / 2)
            $paddingAfter = $horizontalSpace - $titleText.Length - $paddingBefore
            
            [void]$borderBuilder.Append($chars.Horizontal * $paddingBefore)
            [void]$borderBuilder.Append($this.SetColor($this.TitleColor))
            [void]$borderBuilder.Append($titleText)
            [void]$borderBuilder.Append($this.SetColor($this.BorderColor))
            [void]$borderBuilder.Append($chars.Horizontal * $paddingAfter)
        }
        else {
            [void]$borderBuilder.Append($chars.Horizontal * $horizontalSpace)
        }
        
        [void]$borderBuilder.Append($chars.TopRight)
        
        # Side borders
        for ($row = 1; $row -lt $this.Height - 1; $row++) {
            [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $row))
            [void]$borderBuilder.Append($chars.Vertical)
            [void]$borderBuilder.Append($this.MoveCursor($this.X + $this.Width - 1, $this.Y + $row))
            [void]$borderBuilder.Append($chars.Vertical)
        }
        
        # Bottom border
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $this.Height - 1))
        [void]$borderBuilder.Append($chars.BottomLeft)
        [void]$borderBuilder.Append($chars.Horizontal * $horizontalSpace)
        [void]$borderBuilder.Append($chars.BottomRight)
        
        [void]$borderBuilder.Append($this.ResetColor())
        
        return $borderBuilder.ToString()
    }
    
    hidden [string] RenderContent() {
        $contentBuilder = [System.Text.StringBuilder]::new()
        $contentArea = $this.GetContentArea()
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                [void]$contentBuilder.Append($child.Render())
            }
        }
        
        return $contentBuilder.ToString()
    }
    
    # AI: Helper methods for ANSI escape sequences
    hidden [string] MoveCursor([int]$x, [int]$y) {
        return "`e[$($y + 1);$($x + 1)H"
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# ContentPanel - Panel for displaying scrollable content
class ContentPanel : Panel {
    [string[]] $Content = @()
    [int] $ScrollOffset = 0
    [ConsoleColor] $TextColor = [ConsoleColor]::White
    [bool] $WordWrap = $true
    
    ContentPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {
    }
    
    [void] SetContent([string[]]$content) {
        if ($null -eq $content) {
            $this.Content = @()
        }
        else {
            $this.Content = $content
        }
        $this.ScrollOffset = 0
    }
    
    [void] AppendContent([string]$line) {
        if ($null -ne $line) {
            $this.Content += $line
        }
    }
    
    [void] ClearContent() {
        $this.Content = @()
        $this.ScrollOffset = 0
    }
    
    [void] ScrollUp([int]$lines = 1) {
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset - $lines)
    }
    
    [void] ScrollDown([int]$lines = 1) {
        $maxOffset = [Math]::Max(0, $this.Content.Count - $this.GetContentArea().Height)
        $this.ScrollOffset = [Math]::Min($maxOffset, $this.ScrollOffset + $lines)
    }
    
    [void] ScrollToTop() {
        $this.ScrollOffset = 0
    }
    
    [void] ScrollToBottom() {
        $maxOffset = [Math]::Max(0, $this.Content.Count - $this.GetContentArea().Height)
        $this.ScrollOffset = $maxOffset
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "ContentPanel" -Context "Render:$($this.Name)" -ScriptBlock {
            $contentBuilder = [System.Text.StringBuilder]::new()
            $contentArea = $this.GetContentArea()
            
            # Process content with word wrapping if enabled
            $processedLines = @()
            if ($this.WordWrap) {
                foreach ($line in $this.Content) {
                    $processedLines += $this.WrapText($line, $contentArea.Width)
                }
            }
            else {
                $processedLines = $this.Content
            }
            
            # Render visible lines
            $visibleLines = [Math]::Min($contentArea.Height, $processedLines.Count - $this.ScrollOffset)
            
            for ($i = 0; $i -lt $visibleLines; $i++) {
                $lineIndex = $this.ScrollOffset + $i
                if ($lineIndex -lt $processedLines.Count) {
                    $line = $processedLines[$lineIndex]
                    
                    # Truncate if needed (when word wrap is off)
                    if ($line.Length -gt $contentArea.Width) {
                        $line = $line.Substring(0, $contentArea.Width)
                    }
                    
                    [void]$contentBuilder.Append($this.MoveCursor($contentArea.X, $contentArea.Y + $i))
                    [void]$contentBuilder.Append($this.SetColor($this.TextColor))
                    [void]$contentBuilder.Append($line)
                }
            }
            
            # Clear remaining lines in content area
            $clearLine = ' ' * $contentArea.Width
            for ($i = $visibleLines; $i -lt $contentArea.Height; $i++) {
                [void]$contentBuilder.Append($this.MoveCursor($contentArea.X, $contentArea.Y + $i))
                [void]$contentBuilder.Append($clearLine)
            }
            
            [void]$contentBuilder.Append($this.ResetColor())
            
            return $contentBuilder.ToString()
        }
    }
    
    # AI: Word wrap implementation
    hidden [string[]] WrapText([string]$text, [int]$maxWidth) {
        if ([string]::IsNullOrEmpty($text) -or $maxWidth -le 0) {
            return @()
        }
        
        $lines = [System.Collections.Generic.List[string]]::new()
        $words = $text -split '\s+'
        $currentLine = [System.Text.StringBuilder]::new()
        
        foreach ($word in $words) {
            if ($currentLine.Length -eq 0) {
                [void]$currentLine.Append($word)
            }
            elseif (($currentLine.Length + 1 + $word.Length) -le $maxWidth) {
                [void]$currentLine.Append(' ').Append($word)
            }
            else {
                $lines.Add($currentLine.ToString())
                $currentLine.Clear()
                [void]$currentLine.Append($word)
            }
        }
        
        if ($currentLine.Length -gt 0) {
            $lines.Add($currentLine.ToString())
        }
        
        return $lines.ToArray()
    }
    
    # AI: Helper methods (inherited from BorderPanel, but redefined for clarity)
    hidden [string] MoveCursor([int]$x, [int]$y) {
        return "`e[$($y + 1);$($x + 1)H"
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\layout\panels.psm1
# FILE: layout/panels.psm1 - FIXED VERSION
# PURPOSE: Provides specialized layout panels with resolved parameter binding issues

function New-BasePanel {
    param([hashtable]$Props)
    
    $panel = @{
        Type = "Panel"
        Name = if ($null -ne $Props.Name) { $Props.Name } else { "Panel_$([Guid]::NewGuid().ToString('N').Substring(0,8))" }
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 20 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        IsFocusable = if ($null -ne $Props.IsFocusable) { $Props.IsFocusable } else { $false }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Children = @()
        Parent = $null
        LayoutProps = if ($null -ne $Props.LayoutProps) { $Props.LayoutProps } else { @{} }
        ShowBorder = if ($null -ne $Props.ShowBorder) { $Props.ShowBorder } else { $false }
        BorderStyle = if ($null -ne $Props.BorderStyle) { $Props.BorderStyle } else { "Single" }
        BorderColor = if ($null -ne $Props.BorderColor) { $Props.BorderColor } else { "Border" }
        Title = $Props.Title
        Padding = if ($null -ne $Props.Padding) { $Props.Padding } else { 0 }
        Margin = if ($null -ne $Props.Margin) { $Props.Margin } else { 0 }
        BackgroundColor = $Props.BackgroundColor
        ForegroundColor = $Props.ForegroundColor
        _isDirty = $true
        _cachedLayout = $null
        
        AddChild = { 
            param($self, $Child, [hashtable]$LayoutProps = @{})
            
            Invoke-WithErrorHandling -Component "$($self.Name).AddChild" -Context "Adding child component" -ScriptBlock {
                if (-not $Child) {
                    throw "Cannot add null child to panel"
                }
                
                $Child.Parent = $self
                $Child.LayoutProps = $LayoutProps
                $self.Children += $Child
                $self._isDirty = $true
                
                # Propagate visibility
                if (-not $self.Visible) {
                    $Child.Visible = $false
                }
            } -AdditionalData @{
                ParentPanel = $self.Name
                ChildType = if ($Child.Type) { $Child.Type } else { "Unknown" }
                ChildName = if ($Child.Name) { $Child.Name } else { "Unnamed" }
            }
        }
        
        RemoveChild = {
            param($self, $Child)
            
            Invoke-WithErrorHandling -Component "$($self.Name).RemoveChild" -Context "Removing child component" -ScriptBlock {
                $self.Children = $self.Children | Where-Object { $_ -ne $Child }
                if ($Child.Parent -eq $self) {
                    $Child.Parent = $null
                }
                $self._isDirty = $true
            } -AdditionalData @{
                ParentPanel = $self.Name
                ChildName = if ($Child.Name) { $Child.Name } else { "Unnamed" }
            }
        }
        
        Show = { 
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).Show" -Context "Showing panel" -ScriptBlock {
                $self.Visible = $true
                foreach ($child in $self.Children) { 
                    if ($child.Show) { 
                        & $child.Show -self $child
                    } else { 
                        $child.Visible = $true
                    }
                }
                
                if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            }
        }
        
        Hide = { 
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).Hide" -Context "Hiding panel" -ScriptBlock {
                $self.Visible = $false
                foreach ($child in $self.Children) { 
                    if ($child.Hide) { 
                        & $child.Hide -self $child
                    } else { 
                        $child.Visible = $false
                    }
                }
                
                if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            }
        }
        
        HandleInput = { 
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -Context "Handling input" -ScriptBlock {
                # Panels typically don't handle input directly
                return $false
            } -AdditionalData @{
                KeyPressed = if ($Key) { $Key.ToString() } else { "Unknown" }
            }
        }
        
        GetContentBounds = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).GetContentBounds" -Context "Calculating content bounds" -ScriptBlock {
                $borderOffset = if ($self.ShowBorder) { 1 } else { 0 }
                
                return @{
                    X = $self.X + $self.Padding + $borderOffset + $self.Margin
                    Y = $self.Y + $self.Padding + $borderOffset + $self.Margin
                    Width = $self.Width - (2 * ($self.Padding + $borderOffset + $self.Margin))
                    Height = $self.Height - (2 * ($self.Padding + $borderOffset + $self.Margin))
                }
            }
        }
        
        InvalidateLayout = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Name).InvalidateLayout" -Context "Invalidating layout" -ScriptBlock {
                $self._isDirty = $true
                
                # Propagate to parent
                if ($self.Parent -and $self.Parent.InvalidateLayout) {
                    & $self.Parent.InvalidateLayout -self $self.Parent
                }
            }
        }
    }
    
    return $panel
}

function global:New-TuiStackPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "StackPanel"
    $panel.Layout = 'Stack'
    $panel.Orientation = if ($null -ne $Props.Orientation) { $Props.Orientation } else { 'Vertical' }
    $panel.Spacing = if ($null -ne $Props.Spacing) { $Props.Spacing } else { 1 }
    $panel.HorizontalAlignment = if ($null -ne $Props.HorizontalAlignment) { $Props.HorizontalAlignment } else { 'Stretch' }
    $panel.VerticalAlignment = if ($null -ne $Props.VerticalAlignment) { $Props.VerticalAlignment } else { 'Stretch' }
    
    $panel.CalculateLayout = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).CalculateLayout" -Context "Calculating stack layout" -ScriptBlock {
            $bounds = & $self.GetContentBounds -self $self
            $layout = @{
                Children = @()
            }
            
            $currentX = $bounds.X
            $currentY = $bounds.Y
            $visibleChildren = $self.Children | Where-Object { $_.Visible }
            
            foreach ($child in $visibleChildren) {
                $childLayout = @{
                    Component = $child
                    X = $currentX
                    Y = $currentY
                    Width = if ($self.Orientation -eq 'Horizontal') { $child.Width } else { $bounds.Width }
                    Height = if ($self.Orientation -eq 'Vertical') { $child.Height } else { $bounds.Height }
                }
                
                # Update child position
                $child.X = $childLayout.X
                $child.Y = $childLayout.Y
                
                $layout.Children += $childLayout
                
                # Move to next position
                if ($self.Orientation -eq 'Vertical') {
                    $currentY += $childLayout.Height + $self.Spacing
                } else {
                    $currentX += $childLayout.Width + $self.Spacing
                }
            }
            
            $self._cachedLayout = $layout
            $self._isDirty = $false
            return $layout
        } -AdditionalData @{
            Orientation = $self.Orientation
            ChildrenCount = $self.Children.Count
        }
    }
    
    $panel.Render = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).Render" -Context "Rendering stack panel" -ScriptBlock {
            if (-not $self.Visible) { return }
            
            # Clear panel area first
            $bgColor = if ($self.BackgroundColor) { 
                $self.BackgroundColor 
            } else { 
                if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
                    Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
                } else {
                    [ConsoleColor]::Black
                }
            }
            
            if ($self.ShowBorder) {
                $borderColor = if ($self.BorderColor) {
                    if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
                        Get-ThemeColor $self.BorderColor -Default ([ConsoleColor]::Gray)
                    } else {
                        [ConsoleColor]::Gray
                    }
                } else { 
                    [ConsoleColor]::Gray
                }
                
                if (Get-Command -Name "Write-BufferBox" -ErrorAction SilentlyContinue) {
                    Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                        -BorderColor $borderColor -BackgroundColor $bgColor `
                        -BorderStyle $self.BorderStyle -Title $self.Title
                }
            }
            
            # Calculate layout
            & $self.CalculateLayout -self $self
        }
    }
    
    return $panel
}

function global:New-TuiGridPanel {
    param([hashtable]$Props = @{})
    
    $panel = New-BasePanel -Props $Props
    $panel.Type = "GridPanel"
    $panel.Layout = 'Grid'
    $panel.RowDefinitions = if ($Props.RowDefinitions) { $Props.RowDefinitions } else { @("1*") }
    $panel.ColumnDefinitions = if ($Props.ColumnDefinitions) { $Props.ColumnDefinitions } else { @("1*") }
    $panel.ShowGridLines = if ($null -ne $Props.ShowGridLines) { $Props.ShowGridLines } else { $false }
    $panel.GridLineColor = if ($Props.GridLineColor) { $Props.GridLineColor } else { "Border" }
    
    $panel.CalculateLayout = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).CalculateLayout" -Context "Calculating grid layout" -ScriptBlock {
            $bounds = & $self.GetContentBounds -self $self
            
            # Calculate row and column sizes
            $rowSizes = $self._CalculateDimensions($self.RowDefinitions, $bounds.Height)
            $colSizes = $self._CalculateDimensions($self.ColumnDefinitions, $bounds.Width)
            
            # Calculate offsets
            $rowOffsets = @(0)
            for ($i = 0; $i -lt $rowSizes.Count; $i++) {
                $rowOffsets += $rowOffsets[-1] + $rowSizes[$i]
            }
            
            $colOffsets = @(0)
            for ($i = 0; $i -lt $colSizes.Count; $i++) {
                $colOffsets += $colOffsets[-1] + $colSizes[$i]
            }
            
            $layout = @{
                Children = @()
                RowOffsets = $rowOffsets
                ColumnOffsets = $colOffsets
                RowSizes = $rowSizes
                ColumnSizes = $colSizes
            }
            
            # Position children
            foreach ($child in $self.Children) {
                if (-not $child.Visible) { continue }
                
                $row = if ($child.LayoutProps -and $child.LayoutProps["Grid.Row"]) { $child.LayoutProps["Grid.Row"] } else { 0 }
                $col = if ($child.LayoutProps -and $child.LayoutProps["Grid.Column"]) { $child.LayoutProps["Grid.Column"] } else { 0 }
                
                # Bounds checking
                if ($row -ge $rowSizes.Count) { $row = $rowSizes.Count - 1 }
                if ($col -ge $colSizes.Count) { $col = $colSizes.Count - 1 }
                if ($row -lt 0) { $row = 0 }
                if ($col -lt 0) { $col = 0 }
                
                $childLayout = @{
                    Component = $child
                    X = $bounds.X + $colOffsets[$col]
                    Y = $bounds.Y + $rowOffsets[$row]
                    Width = $colSizes[$col]
                    Height = $rowSizes[$row]
                    GridRow = $row
                    GridColumn = $col
                }
                
                # Update child position
                $child.X = $childLayout.X
                $child.Y = $childLayout.Y
                
                $layout.Children += $childLayout
            }
            
            $self._cachedLayout = $layout
            $self._isDirty = $false
            return $layout
        } -AdditionalData @{
            RowDefinitions = $self.RowDefinitions
            ColumnDefinitions = $self.ColumnDefinitions
            ChildrenCount = $self.Children.Count
        }
    }
    
    # Helper method to calculate dimensions
    $panel._CalculateDimensions = {
        param($definitions, $totalSize)
        
        $fixedSize = 0
        $starCount = 0
        $sizes = @()
        
        # First pass: calculate fixed sizes and count stars
        foreach ($def in $definitions) {
            if ($def -match '^\d+$') {
                # Fixed size
                $size = [int]$def
                $sizes += $size
                $fixedSize += $size
            }
            elseif ($def -match '^(\d*\.?\d*)\*$') {
                # Star sizing
                $weight = if ($matches[1]) { [double]$matches[1] } else { 1.0 }
                $sizes += @{ Type = "Star"; Weight = $weight }
                $starCount += $weight
            }
            else {
                # Default to star
                $sizes += @{ Type = "Star"; Weight = 1.0 }
                $starCount += 1.0
            }
        }
        
        # Second pass: calculate star sizes
        $remainingSize = [Math]::Max(0, $totalSize - $fixedSize)
        $starSize = if ($starCount -gt 0) { $remainingSize / $starCount } else { 0 }
        
        for ($i = 0; $i -lt $sizes.Count; $i++) {
            if ($sizes[$i] -is [hashtable] -and $sizes[$i].Type -eq "Star") {
                $sizes[$i] = [Math]::Floor($starSize * $sizes[$i].Weight)
            }
        }
        
        return $sizes
    }
    
    $panel.Render = {
        param($self)
        Invoke-WithErrorHandling -Component "$($self.Name).Render" -Context "Rendering grid panel" -ScriptBlock {
            if (-not $self.Visible) { return }
            
            # Clear panel area and draw border if needed
            $bgColor = if ($self.BackgroundColor) { 
                $self.BackgroundColor 
            } else { 
                if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
                    Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
                } else {
                    [ConsoleColor]::Black
                }
            }
            
            if ($self.ShowBorder) {
                $borderColor = if ($self.BorderColor) {
                    if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
                        Get-ThemeColor $self.BorderColor -Default ([ConsoleColor]::Gray)
                    } else {
                        [ConsoleColor]::Gray
                    }
                } else { 
                    [ConsoleColor]::Gray
                }
                
                if (Get-Command -Name "Write-BufferBox" -ErrorAction SilentlyContinue) {
                    Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                        -BorderColor $borderColor -BackgroundColor $bgColor `
                        -BorderStyle $self.BorderStyle -Title $self.Title
                }
            }
            
            # Calculate layout
            $layout = & $self.CalculateLayout -self $self
            
            # Draw grid lines if enabled
            if ($self.ShowGridLines -and (Get-Command -Name "Write-BufferString" -ErrorAction SilentlyContinue)) {
                $bounds = & $self.GetContentBounds -self $self
                $gridColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
                    Get-ThemeColor $self.GridLineColor -Default ([ConsoleColor]::Gray)
                } else {
                    [ConsoleColor]::Gray
                }
                
                # Vertical lines
                foreach ($offset in $layout.ColumnOffsets[1..($layout.ColumnOffsets.Count - 1)]) {
                    $x = $bounds.X + $offset
                    for ($y = $bounds.Y; $y -lt ($bounds.Y + $bounds.Height); $y++) { 
                        Write-BufferString -X $x -Y $y -Text "‚îÇ" -ForegroundColor $gridColor
                    }
                }
                
                # Horizontal lines
                foreach ($offset in $layout.RowOffsets[1..($layout.RowOffsets.Count - 1)]) {
                    $y = $bounds.Y + $offset
                    Write-BufferString -X $bounds.X -Y $y -Text ("‚îÄ" * $bounds.Width) -ForegroundColor $gridColor
                }
            }
        }
    }
    
    return $panel
}

function global:New-TuiDockPanel { 
    param([hashtable]$Props = @{}) 
    $dockProps = $Props.Clone()
    $dockProps.Orientation = 'Vertical'
    return New-TuiStackPanel -Props $dockProps
}

function global:New-TuiWrapPanel { 
    param([hashtable]$Props = @{}) 
    return New-TuiStackPanel -Props $Props 
}

Export-ModuleMember -Function @("New-BasePanel", "New-TuiStackPanel", "New-TuiGridPanel", "New-TuiDockPanel", "New-TuiWrapPanel")


####\modules\data-manager.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration
# AI: Refactored from dispatch-based actions to direct function calls
# AI: Now uses strongly-typed PmcTask and PmcProject classes from models module

using module .\models.psm1
using module .\exceptions.psm1
using module .\event-system.psm1
using module .\logger.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Module-level state variables
$script:Data = @{
    Projects = [System.Collections.Generic.List[PmcProject]]::new()
    Tasks = [System.Collections.Generic.List[PmcTask]]::new()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    # AI: Maintaining compatibility with legacy underscore format
    time_entries = @()    # underscore format for action compatibility
    timers = @()          # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system
    
    .DESCRIPTION
    Sets up the data directory, loads existing data, and configures event handlers
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        # Ensure data directory exists
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        # Ensure backup directory exists
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        # Load existing data
        Load-UnifiedData
        
        # Initialize event handlers
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        
        # AI: Return service object with methods for direct invocation
        return [PSCustomObject]@{
            AddTask = Get-Command Add-PmcTask
            UpdateTask = Get-Command Update-PmcTask
            RemoveTask = Get-Command Remove-PmcTask
            GetTasks = Get-Command Get-PmcTasks
            GetProjects = Get-Command Get-PmcProjects
            SaveData = Get-Command Save-UnifiedData
            LoadData = Get-Command Load-UnifiedData
        }
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk
    
    .DESCRIPTION
    Loads the unified data file and populates the global data structure with strongly-typed objects
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $content = Get-Content -Path $script:DataPath -Raw
                $loadedData = $content | ConvertFrom-Json -AsHashtable
                
                # AI: Defensive validation of loaded data structure
                if ($loadedData -and $loadedData -is [hashtable]) {
                    # AI: Re-hydrate Tasks as PmcTask objects
                    if ($loadedData.ContainsKey('Tasks') -and $loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) {
                                # AI: Use static method to create from legacy format
                                $task = [PmcTask]::FromLegacyFormat($taskData)
                                $script:Data.Tasks.Add($task)
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    # AI: Re-hydrate Projects as PmcProject objects
                    if ($loadedData.ContainsKey('Projects') -and $loadedData.Projects) {
                        $script:Data.Projects.Clear()
                        # AI: Projects were stored as hashtable, need to convert each value
                        if ($loadedData.Projects -is [hashtable]) {
                            foreach ($projectKey in $loadedData.Projects.Keys) {
                                $projectData = $loadedData.Projects[$projectKey]
                                if ($projectData -is [hashtable]) {
                                    $project = [PmcProject]::FromLegacyFormat($projectData)
                                    $script:Data.Projects.Add($project)
                                }
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    # AI: Load other data structures as-is for now
                    foreach ($key in @('TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers')) {
                        if ($loadedData.ContainsKey($key)) {
                            $script:Data[$key] = $loadedData[$key]
                        }
                    }
                    
                    # Update global data reference
                    $global:Data = $script:Data
                    
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                Write-Log -Level Info -Message "Using default data structure"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk
    
    .DESCRIPTION
    Persists the current data state to disk with automatic backup rotation
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        # Create backup if file exists
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            $backupFilePath = Join-Path $script:BackupPath $backupName
            Copy-Item -Path $script:DataPath -Destination $backupFilePath -Force
            
            # Rotate backups
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | 
                       Sort-Object LastWriteTime -Descending
            
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        # AI: Convert strongly-typed objects to legacy format for JSON serialization
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}  # AI: Convert back to hashtable format for compatibility
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        # AI: Rebuild Projects hashtable keyed by project key
        foreach ($project in $script:Data.Projects) {
            $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat()
        }
        
        # Save current data
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date
        $script:DataModified = $false
        
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    <#
    .SYNOPSIS
    Creates a new task
    
    .DESCRIPTION
    Adds a new task to the data store and publishes a Tasks.Changed event
    
    .PARAMETER Title
    The title of the task (required)
    
    .PARAMETER Description
    The task description
    
    .PARAMETER Priority
    Task priority: low, medium, or high
    
    .PARAMETER Category
    Task category/project name
    
    .PARAMETER DueDate
    Task due date
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Title,
        
        [string]$Description = "",
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority = "medium",
        
        [string]$Category = "General",
        
        [string]$DueDate = ""
    )
    
    Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task to data store" -ScriptBlock {
        # AI: Input validation
        if ([string]::IsNullOrWhiteSpace($Title)) {
            throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title })
        }
        
        # AI: Convert string priority to enum
        $taskPriority = switch ($Priority.ToLower()) {
            "low" { [TaskPriority]::Low }
            "medium" { [TaskPriority]::Medium }
            "high" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # AI: Create new task using class constructor
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        # AI: Set due date if provided
        if ($DueDate -and $DueDate -ne "N/A") {
            try {
                $newTask.DueDate = [datetime]::Parse($DueDate)
            } catch {
                Write-Log -Level Warning -Message "Invalid due date format: $DueDate"
                $newTask.DueDate = $null
            }
        }
        
        # AI: Add to strongly-typed task list
        $script:Data.Tasks.Add($newTask)
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Created"
            TaskId = $newTask.Id
            Task = $newTask
        }
        
        return $newTask
    }
}

function Update-PmcTask {
    <#
    .SYNOPSIS
    Updates an existing task
    
    .DESCRIPTION
    Modifies task properties and publishes a Tasks.Changed event
    
    .PARAMETER Task
    The PmcTask object to update (required)
    
    .PARAMETER Title
    New task title
    
    .PARAMETER Description
    New task description
    
    .PARAMETER Priority
    New task priority
    
    .PARAMETER Category
    New task category
    
    .PARAMETER DueDate
    New due date
    
    .PARAMETER Completed
    Task completion status
    
    .PARAMETER Progress
    Task progress percentage (0-100)
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcTask]$Task,
        
        [string]$Title,
        
        [string]$Description,
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority,
        
        [string]$Category,
        
        [string]$DueDate,
        
        [bool]$Completed,
        
        [ValidateRange(0, 100)]
        [int]$Progress
    )
    
    Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating existing task" -ScriptBlock {
        # AI: Find task in list to ensure we're updating the managed instance
        $managedTask = $script:Data.Tasks | Where-Object { $_.Id -eq $Task.Id } | Select-Object -First 1
        
        if (-not $managedTask) {
            throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id })
        }
        
        $updatedFields = @()
        
        # AI: Update task properties using proper object properties
        if ($PSBoundParameters.ContainsKey('Title') -and $Title) { 
            $managedTask.Title = $Title.Trim()
            $updatedFields += "Title"
        }
        if ($PSBoundParameters.ContainsKey('Description')) { 
            $managedTask.Description = $Description
            $updatedFields += "Description"
        }
        if ($PSBoundParameters.ContainsKey('Priority')) {
            $managedTask.Priority = switch ($Priority.ToLower()) {
                "low" { [TaskPriority]::Low }
                "medium" { [TaskPriority]::Medium }
                "high" { [TaskPriority]::High }
                default { [TaskPriority]::Medium }
            }
            $updatedFields += "Priority"
        }
        if ($PSBoundParameters.ContainsKey('Category')) { 
            $managedTask.ProjectKey = $Category
            $managedTask.Category = $Category  # AI: Maintain backward compatibility
            $updatedFields += "Category"
        }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            if ($DueDate -and $DueDate -ne "N/A") {
                try {
                    $managedTask.DueDate = [datetime]::Parse($DueDate)
                } catch {
                    Write-Log -Level Warning -Message "Invalid due date format: $DueDate"
                    $managedTask.DueDate = $null
                }
            } else {
                $managedTask.DueDate = $null
            }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) {
            # AI: Use class method which handles status updates
            $managedTask.UpdateProgress($Progress)
            $updatedFields += "Progress"
        }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) {
                $managedTask.Complete()
            } else {
                $managedTask.Status = [TaskStatus]::Pending
                $managedTask.Completed = $false
                $managedTask.Progress = 0
            }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Updated"
            TaskId = $managedTask.Id
            Task = $managedTask
            UpdatedFields = $updatedFields
        }
        
        return $managedTask
    }
}

function Remove-PmcTask {
    <#
    .SYNOPSIS
    Removes a task from the data store
    
    .DESCRIPTION
    Deletes a task and publishes a Tasks.Changed event
    
    .PARAMETER Task
    The PmcTask object to remove
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcTask]$Task
    )
    
    Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task from data store" -ScriptBlock {
        # AI: Find and remove task from strongly-typed list
        $taskToRemove = $script:Data.Tasks | Where-Object { $_.Id -eq $Task.Id } | Select-Object -First 1
        
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null
            $script:DataModified = $true
            
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            
            # Auto-save if enabled
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            # AI: Publish event for UI refresh
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Deleted"
                TaskId = $Task.Id
                Task = $Task
            }
            
            return $true
        } else {
            Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"
            return $false
        }
    }
}

function Get-PmcTasks {
    <#
    .SYNOPSIS
    Retrieves tasks from the data store
    
    .DESCRIPTION
    Returns all tasks or filtered tasks based on criteria
    
    .PARAMETER Completed
    Filter by completion status
    
    .PARAMETER Priority
    Filter by priority level
    
    .PARAMETER Category
    Filter by category/project
    #>
    [CmdletBinding()]
    param(
        [bool]$Completed,
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority,
        
        [string]$Category
    )
    
    Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks from data store" -ScriptBlock {
        # AI: Start with all tasks from strongly-typed list
        $tasks = $script:Data.Tasks
        
        # Apply filters if specified
        if ($PSBoundParameters.ContainsKey('Completed')) {
            $tasks = $tasks | Where-Object { $_.Completed -eq $Completed }
        }
        
        if ($Priority) {
            # AI: Convert string to enum for comparison
            $priorityEnum = switch ($Priority.ToLower()) {
                "low" { [TaskPriority]::Low }
                "medium" { [TaskPriority]::Medium }
                "high" { [TaskPriority]::High }
            }
            $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum }
        }
        
        if ($Category) {
            $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category }
        }
        
        # AI: Return as array to maintain compatibility
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects {
    <#
    .SYNOPSIS
    Retrieves all projects from the data store
    
    .DESCRIPTION
    Returns all PmcProject objects as an array
    #>
    [CmdletBinding()]
    param()
    
    # AI: Return projects from strongly-typed list as array
    return @($script:Data.Projects)
}

function Get-PmcProject {
    <#
    .SYNOPSIS
    Retrieves a specific project by key
    
    .PARAMETER Key
    The project key
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Key
    )
    
    # AI: Find project in list by key
    return $script:Data.Projects | Where-Object { $_.Key -eq $Key } | Select-Object -First 1
}

function Add-PmcProject {
    <#
    .SYNOPSIS
    Adds a new project to the data store
    
    .PARAMETER Project
    The PmcProject object to add
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcProject]$Project
    )
    
    Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding new project to data store" -ScriptBlock {
        # AI: Check if project with same key already exists
        $existing = $script:Data.Projects | Where-Object { $_.Key -eq $Project.Key } | Select-Object -First 1
        
        if ($existing) {
            throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key })
        }
        
        # AI: Add to strongly-typed project list
        $script:Data.Projects.Add($Project)
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Projects.Changed" -Data @{
            Action = "Created"
            ProjectKey = $Project.Key
            Project = $Project
        }
        
        return $Project
    }
}

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    <#
    .SYNOPSIS
    Sets up event handlers for data operations
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        # AI: Subscribe to refresh request events for backward compatibility
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            param($EventData)
            
            # Simply publish the current task data
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Refreshed"
                Tasks = @($script:Data.Tasks)
            }
        }
        
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion

# Export public functions
Export-ModuleMember -Function @(
    'Initialize-DataManager',
    'Add-PmcTask',
    'Update-PmcTask', 
    'Remove-PmcTask',
    'Get-PmcTasks',
    'Get-PmcProjects',
    'Get-PmcProject',
    'Add-PmcProject',
    'Save-UnifiedData',
    'Load-UnifiedData'
)


####\modules\dialog-system.psm1
# Dialog System Module - FIXED VERSION
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function global:Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    Invoke-WithErrorHandling -Component "DialogSystem.ShowDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
        }
        $script:DialogState.CurrentDialog = $DialogComponent
        Request-TuiRefresh
    } -Context "Showing dialog: $($DialogComponent.Title)" -AdditionalData @{ DialogType = $DialogComponent.Type; DialogTitle = $DialogComponent.Title }
}

function global:Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    Invoke-WithErrorHandling -Component "DialogSystem.CloseDialog" -ScriptBlock {
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        } else {
            $script:DialogState.CurrentDialog = $null
        }
        Request-TuiRefresh
    } -Context "Closing current dialog"
}

function global:Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowConfirmDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("Yes", "No")
            Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
            Height        = 10
            OnButtonClick = {
                param($Button, $Index)
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog
                    if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
                } -Context "Confirm dialog button click: $Button" -AdditionalData @{ Button = $Button; Index = $Index; DialogTitle = $Title }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog; & $OnCancel 
                } -Context "Confirm dialog cancelled" -AdditionalData @{ DialogTitle = $Title }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating confirm dialog: $Title" -AdditionalData @{ Title = $Title; Message = $Message }
}

function global:Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowAlertDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("OK")
            Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
            Height        = 10
            OnButtonClick = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog 
                } -Context "Alert dialog OK clicked" -AdditionalData @{ DialogTitle = $Title }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog 
                } -Context "Alert dialog cancelled" -AdditionalData @{ DialogTitle = $Title }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating alert dialog: $Title" -AdditionalData @{ Title = $Title; Message = $Message }
}

function global:Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowInputDialog" -ScriptBlock {
        # Create a screen that contains the input components
        $inputScreen = @{
            Name = "InputDialog"
            State = @{
                InputValue = $DefaultValue
                FocusedIndex = 0  # Start with textbox focused
            }
            _focusableNames = @("InputTextBox", "OKButton", "CancelButton")
            _focusedIndex = 0
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
                    # Calculate dialog dimensions
                    $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
                    $dialogHeight = 10
                    $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
                    $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight `
                        -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    $promptX = $dialogX + 2
                    $promptY = $dialogY + 2
                    Write-BufferString -X $promptX -Y $promptY -Text $Prompt
                    
                    # Draw text input
                    $inputY = $promptY + 2
                    $inputWidth = $dialogWidth - 4
                    $isFocused = ($self._focusedIndex -eq 0)
                    $borderColor = if ($isFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 `
                        -BorderColor $borderColor
                    
                    # Draw input value
                    $displayText = $self.State.InputValue
                    if ($displayText.Length -gt ($inputWidth - 3)) {
                        $displayText = $displayText.Substring(0, $inputWidth - 3) # Ensure it fits
                    }
                    Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
                    
                    # Draw cursor if textbox is focused
                    if ($isFocused) {
                        $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                        Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) `
                            -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
                    }
                    
                    # Draw buttons
                    $buttonY = $dialogY + $dialogHeight - 2
                    $buttonSpacing = 15
                    $buttonsWidth = $buttonSpacing * 2
                    $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
                    
                    # OK button
                    $okFocused = ($self._focusedIndex -eq 1)
                    $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
                    $okColor = if ($okFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
                    
                    # Cancel button
                    $cancelFocused = ($self._focusedIndex -eq 2)
                    $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
                    $cancelColor = if ($cancelFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
                } -Context "Rendering input dialog" -AdditionalData @{ DialogName = $self.Name; Prompt = $Prompt; CurrentValue = $self.State.InputValue }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                    # Handle Tab navigation
                    if ($Key.Key -eq [ConsoleKey]::Tab) {
                        $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                        $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                        Request-TuiRefresh
                        return $true
                    }
                    
                    # Handle Escape
                    if ($Key.Key -eq [ConsoleKey]::Escape) {
                        Close-TuiDialog
                        Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                            & $OnCancel
                        } -Context "Input dialog cancelled via Escape" -AdditionalData @{ DialogTitle = $Title }
                        return $true
                    }
                    
                    # Handle based on focused element
                    switch ($self._focusedIndex) {
                        0 {  # TextBox
                            switch ($Key.Key) {
                                ([ConsoleKey]::Enter) {
                                    Close-TuiDialog
                                    Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                        & $OnSubmit -Value $self.State.InputValue
                                    } -Context "Input dialog submitted via Enter" -AdditionalData @{ DialogTitle = $Title; InputValue = $self.State.InputValue }
                                    return $true
                                }
                                ([ConsoleKey]::Backspace) {
                                    if ($self.State.InputValue.Length -gt 0) {
                                        $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1)
                                        Request-TuiRefresh
                                    }
                                    return $true
                                }
                                default {
                                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                        $self.State.InputValue += $Key.KeyChar
                                        Request-TuiRefresh
                                        return $true
                                    }
                                }
                            }
                        }
                        1 {  # OK Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                    & $OnSubmit -Value $self.State.InputValue
                                } -Context "Input dialog submitted via OK button" -AdditionalData @{ DialogTitle = $Title; InputValue = $self.State.InputValue }
                                return $true
                            }
                        }
                        2 {  # Cancel Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                                    & $OnCancel
                                } -Context "Input dialog cancelled via Cancel button" -AdditionalData @{ DialogTitle = $Title }
                                return $true
                            }
                        }
                    }
                    
                    return $false
                } -Context "Handling input dialog key press" -AdditionalData @{ DialogName = $self.Name; Key = $Key; FocusedIndex = $self._focusedIndex }
            }
        }
        
        $script:DialogState.CurrentDialog = $inputScreen
        Request-TuiRefresh
    } -Context "Creating input dialog: $Title" -AdditionalData @{ Title = $Title; Prompt = $Prompt; DefaultValue = $DefaultValue }
}

#endregion

#region --- Engine Integration & Initialization ---

function global:Initialize-DialogSystem {
    <# .SYNOPSIS Subscribes to high-level application events to show dialogs. #>
    Invoke-WithErrorHandling -Component "DialogSystem.Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.ConfirmEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-ConfirmDialog @dialogParams
            } -Context "Handling Confirm.Request event" -AdditionalData @{ EventData = $EventData }
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.AlertEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-AlertDialog @dialogParams
            } -Context "Handling Alert.Show event" -AdditionalData @{ EventData = $EventData }
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.InputEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-InputDialog @dialogParams
            } -Context "Handling Input.Request event" -AdditionalData @{ EventData = $EventData }
        }
        
        Write-Verbose "Dialog System initialized and event handlers registered."
    } -Context "Initializing Dialog System"
}

function global:Render-Dialogs {
    <# .SYNOPSIS Engine Hook: Renders the current dialog over the screen. #>
    Invoke-WithErrorHandling -Component "DialogSystem.RenderDialogs" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            # If it's a component with its own render method
            if ($script:DialogState.CurrentDialog.Render) {
                & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
            }
        }
    } -Context "Rendering current dialog" -AdditionalData @{ CurrentDialog = $script:DialogState.CurrentDialog.Name }
}

function global:Handle-DialogInput {
    <# .SYNOPSIS Engine Hook: Intercepts input if a dialog is active. #>
    param($Key)
    Invoke-WithErrorHandling -Component "DialogSystem.HandleDialogInput" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            if ($script:DialogState.CurrentDialog.HandleInput) {
                return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
            }
        }
        return $false
    } -Context "Handling dialog input" -AdditionalData @{ CurrentDialog = $script:DialogState.CurrentDialog.Name; Key = $Key }
}

function global:Update-DialogSystem {
    <# .SYNOPSIS Engine Hook: Updates dialog system state. #>
    Invoke-WithErrorHandling -Component "DialogSystem.UpdateDialogSystem" -ScriptBlock {
        # Placeholder for any periodic updates needed
    } -Context "Updating dialog system"
}

function global:New-TuiDialog {
    <# .SYNOPSIS Creates a simple dialog component. #>
    param([hashtable]$Props = @{})
    
    $dialog = @{
        Type = "Dialog"
        Title = if ($Props.Title) { $Props.Title } else { "Dialog" }
        Message = if ($Props.Message) { $Props.Message } else { "" }
        Buttons = if ($Props.Buttons) { $Props.Buttons } else { @("OK") }
        SelectedButton = 0
        Width = if ($Props.Width) { $Props.Width } else { 50 }
        Height = if ($Props.Height) { $Props.Height } else { 10 }
        X = 0
        Y = 0
        OnButtonClick = if ($Props.OnButtonClick) { $Props.OnButtonClick } else { {} }
        OnCancel = if ($Props.OnCancel) { $Props.OnCancel } else { {} }
        
        Render = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                # Center the dialog
                $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                
                # Draw dialog box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
                
                # Use engine's word wrap helper
                $messageY = $self.Y + 2
                $messageX = $self.X + 2
                $maxWidth = $self.Width - 4
                
                $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
                
                foreach ($line in $wrappedLines) {
                    if ($messageY -ge ($self.Y + $self.Height - 3)) { break }  # Don't overwrite buttons
                    Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                    $messageY++
                }
                
                # Buttons
                $buttonY = $self.Y + $self.Height - 3
                $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
                $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
                
                for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                    $isSelected = ($i -eq $self.SelectedButton)
                    $buttonText = if ($isSelected) { "[ $($self.Buttons[$i]) ]" } else { "  $($self.Buttons[$i])  " }
                    $color = if ($isSelected) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                    $buttonX += 14
                }
            } -Context "Rendering dialog: $($self.Title)" -AdditionalData @{ DialogTitle = $self.Title; DialogMessage = $self.Message }
        }
        
        HandleInput = {
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Tab) {
                        $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count
                        Request-TuiRefresh
                        return $true
                    }
                    
                    ([ConsoleKey]::Enter) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context "Dialog button clicked: $($self.Buttons[$self.SelectedButton])" -AdditionalData @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context "Dialog button activated: $($self.Buttons[$self.SelectedButton])" -AdditionalData @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton }
                        return $true
                    }
                    ([ConsoleKey]::Escape) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnCancel" -ScriptBlock {
                            & $self.OnCancel
                        } -Context "Dialog cancelled via Escape" -AdditionalData @{ DialogTitle = $self.Title }
                        return $true
                    }
                }
                
                return $false
            } -Context "Handling dialog input" -AdditionalData @{ DialogTitle = $self.Title; Key = $Key; SelectedButton = $self.SelectedButton }
        }
    }
    
    return $dialog
}

function global:Show-ProgressDialog {
    <# .SYNOPSIS Shows a progress dialog with updating percentage. #>
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowProgressDialog" -ScriptBlock {
        $dialog = @{
            Type = "ProgressDialog"
            Title = $Title
            Message = $Message
            PercentComplete = $PercentComplete
            Width = 60
            Height = 8
            ShowCancel = $ShowCancel
            IsCancelled = $false
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    # Center the dialog
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw message
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
                    
                    # Draw progress bar
                    $barY = $y + 4
                    $barWidth = $self.Width - 4
                    $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
                    
                    # Progress bar background
                    Write-BufferString -X ($x + 2) -Y $barY `
                        -Text ("‚îÄ" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
                    
                    # Progress bar fill
                    if ($filledWidth -gt 0) {
                        Write-BufferString -X ($x + 2) -Y $barY `
                            -Text ("‚ñà" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success")
                    }
                    
                    # Percentage text
                    $percentText = "$($self.PercentComplete)%"
                    $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $percentX -Y $barY -Text $percentText
                    
                    # Cancel button if requested
                    if ($self.ShowCancel) {
                        $buttonY = $y + $self.Height - 2
                        $buttonText = if ($self.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
                        $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText `
                            -ForegroundColor (Get-ThemeColor "Warning")
                    }
                } -Context "Rendering progress dialog" -AdditionalData @{ DialogTitle = $self.Title; Percent = $self.PercentComplete }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    if ($self.ShowCancel -and -not $self.IsCancelled) {
                        if ($Key.Key -eq [ConsoleKey]::Escape -or 
                            $Key.Key -eq [ConsoleKey]::Enter -or 
                            $Key.Key -eq [ConsoleKey]::Spacebar) {
                            $self.IsCancelled = $true
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    
                    return $false
                } -Context "Handling progress dialog input" -AdditionalData @{ DialogTitle = $self.Title; Key = $Key }
            }
            
            UpdateProgress = {
                param($self, [int]$PercentComplete, [string]$Message = $null)
                Invoke-WithErrorHandling -Component "$($self.Type).UpdateProgress" -ScriptBlock {
                    $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
                    if ($Message) { $self.Message = $Message }
                    Request-TuiRefresh
                } -Context "Updating progress dialog" -AdditionalData @{ DialogTitle = $self.Title; NewPercent = $PercentComplete; NewMessage = $Message }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
        return $dialog
    } -Context "Creating progress dialog: $Title" -AdditionalData @{ Title = $Title; Message = $Message; Percent = $PercentComplete }
}

function global:Show-ListDialog {
    <# .SYNOPSIS Shows a dialog with a selectable list of items. #>
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowListDialog" -ScriptBlock {
        $dialog = @{
            Type = "ListDialog"
            Title = $Title
            Prompt = $Prompt
            Items = $Items
            SelectedIndex = 0
            SelectedItems = @()
            Width = 60
            Height = [Math]::Min(20, $Items.Count + 8)
            AllowMultiple = $AllowMultiple
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
                    
                    # Calculate list area
                    $listY = $y + 4
                    $listHeight = $self.Height - 7
                    $listWidth = $self.Width - 4
                    
                    # Draw scrollable list
                    $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
                    $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
                    
                    for ($i = $startIndex; $i -le $endIndex; $i++) {
                        $itemY = $listY + ($i - $startIndex)
                        $item = $self.Items[$i]
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $isChecked = $self.SelectedItems -contains $i
                        
                        # Selection indicator
                        $prefix = ""
                        if ($self.AllowMultiple) {
                            $prefix = if ($isChecked) { "[X] " } else { "[ ] " }
                        }
                        
                        $itemText = "$prefix$item"
                        if ($itemText.Length -gt $listWidth - 2) {
                            $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
                        }
                        
                        $bgColor = if ($isSelected) { Get-ThemeColor "Selection" } else { $null }
                        $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        
                        Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText `
                            -ForegroundColor $fgColor -BackgroundColor $bgColor
                    }
                    
                    # Draw scrollbar if needed
                    if ($self.Items.Count -gt $listHeight) {
                        $scrollbarX = $x + $self.Width - 2
                        $scrollbarHeight = $listHeight
                        $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                        $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                        
                        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "‚ñà" } else { "‚îÇ" }
                            Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char `
                                -ForegroundColor (Get-ThemeColor "Border")
                        }
                    }
                    
                    # Draw buttons
                    $buttonY = $y + $self.Height - 2
                    if ($self.AllowMultiple) {
                        $okText = "[ OK ]"
                        $cancelText = "[ Cancel ]"
                        $buttonSpacing = 15
                        $totalWidth = 30
                        $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                        
                        Write-BufferString -X $startX -Y $buttonY -Text $okText `
                            -ForegroundColor (Get-ThemeColor "Success")
                        Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText `
                            -ForegroundColor (Get-ThemeColor "Primary")
                    }
                } -Context "Rendering list dialog" -AdditionalData @{ DialogTitle = $self.Title; Prompt = $self.Prompt; SelectedIndex = $self.SelectedIndex }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) {
                            $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::DownArrow) {
                            $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Spacebar) {
                            if ($self.AllowMultiple) {
                                if ($self.SelectedItems -contains $self.SelectedIndex) {
                                    $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex }
                                } else {
                                    $self.SelectedItems += $self.SelectedIndex
                                }
                                Request-TuiRefresh
                                return $true
                            }
                        }
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            if ($self.AllowMultiple) {
                                $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $selectedValues
                                } -Context "List dialog multi-select completed" -AdditionalData @{ DialogTitle = $self.Title; SelectedValues = $selectedValues }
                            } else {
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $self.Items[$self.SelectedIndex]
                                } -Context "List dialog selection completed" -AdditionalData @{ DialogTitle = $self.Title; SelectedValue = $self.Items[$self.SelectedIndex] }
                            }
                            return $true
                        }
                        ([ConsoleKey]::Escape) {
                            Close-TuiDialog
                            Invoke-WithErrorHandling -Component "ListDialog.OnCancel" -ScriptBlock {
                                & $OnCancel
                            } -Context "List dialog cancelled" -AdditionalData @{ DialogTitle = $self.Title }
                            return $true
                        }
                    }
                    
                    return $false
                } -Context "Handling list dialog input" -AdditionalData @{ DialogTitle = $self.Title; Key = $Key; SelectedIndex = $self.SelectedIndex }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
    } -Context "Creating list dialog: $Title" -AdditionalData @{ Title = $Title; Prompt = $Prompt; ItemsCount = $Items.Count }
}

#endregion

# Export all public functions
Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-TuiDialog',
    'Close-TuiDialog',
    'Show-ConfirmDialog',
    'Show-AlertDialog',
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Render-Dialogs',
    'Handle-DialogInput',
    'Update-DialogSystem',
    'New-TuiDialog'
)



####\modules\event-system.psm1
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = @()
$script:MaxEventHistory = 100

function global:Initialize-EventSystem {
    <#
    .SYNOPSIS
    Initializes the event system for the application
    #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = @()
        Write-Verbose "Event system initialized"
    }
}

function global:Publish-Event {
    <#
    .SYNOPSIS
    Publishes an event to all registered handlers
    
    .PARAMETER EventName
    The name of the event to publish
    
    .PARAMETER Data
    Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        # Record event in history
        $eventRecord = @{
            EventName = $EventName
            Data = $Data
            Timestamp = Get-Date
        }
        
        $script:EventHistory += $eventRecord
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) {
            $script:EventHistory = $script:EventHistory[-$script:MaxEventHistory..-1]
        }
        
        # Execute handlers
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try { # Internal try/catch for handler execution
                    $eventData = @{
                        EventName = $EventName
                        Data = $Data
                        Timestamp = $eventRecord.Timestamp
                    }
                    
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (Handler ID: $($handler.HandlerId)): $_" -Data @{ EventName = $EventName; HandlerId = $handler.HandlerId; Exception = $_ }
                }
            }
        }
        
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function global:Subscribe-Event {
    <#
    .SYNOPSIS
    Subscribes to an event with a handler
    
    .PARAMETER EventName
    The name of the event to subscribe to
    
    .PARAMETER Handler
    The script block to execute when the event is published
    
    .PARAMETER HandlerId
    Optional unique identifier for the handler
    
    .PARAMETER Source
    Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Handler,
        
        [Parameter()]
        [string]$HandlerId = [Guid]::NewGuid().ToString(),
        
        [Parameter()]
        [string]$Source = $null
    )
    Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers[$EventName] = @()
        }
        
        $handlerInfo = @{
            HandlerId = $HandlerId
            ScriptBlock = $Handler
            SubscribedAt = Get-Date
            Source = $Source
        }
        
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        
        # Only return handler ID, don't print it
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function global:Unsubscribe-Event {
    <#
    .SYNOPSIS
    Unsubscribes from an event
    
    .PARAMETER EventName
    The name of the event to unsubscribe from (optional if HandlerId is provided)
    
    .PARAMETER HandlerId
    The unique identifier of the handler to remove
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            # Fast path when event name is known
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($script:EventHandlers[$EventName].Count -eq 0) {
                    $script:EventHandlers.Remove($EventName)
                }
                
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            # Search all events for the handler ID
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    if ($newHandlers.Count -eq 0) {
                        $script:EventHandlers.Remove($eventKey)
                    } else {
                        $script:EventHandlers[$eventKey] = $newHandlers
                    }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"
                    break
                }
            }
            
            if (-not $found) {
                Write-Warning "Handler ID not found: $HandlerId"
            }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function global:Get-EventHandlers {
    <#
    .SYNOPSIS
    Gets all registered event handlers
    
    .PARAMETER EventName
    Optional event name to filter by
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                return $script:EventHandlers[$EventName]
            } else {
                return @()
            }
        } else {
            return $script:EventHandlers
        }
    } -AdditionalData @{ EventName = $EventName }
}

function global:Clear-EventHandlers {
    <#
    .SYNOPSIS
    Clears all event handlers for a specific event or all events
    
    .PARAMETER EventName
    Optional event name to clear handlers for
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers.Remove($EventName)
                Write-Verbose "Cleared handlers for event: $EventName"
            }
        } else {
            $script:EventHandlers = @{}
            Write-Verbose "Cleared all event handlers"
        }
    } -AdditionalData @{ EventName = $EventName }
}

function global:Get-EventHistory {
    <#
    .SYNOPSIS
    Gets the event history
    
    .PARAMETER EventName
    Optional event name to filter by
    
    .PARAMETER Last
    Number of recent events to return
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter()]
        [int]$Last = 0
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        
        if ($EventName) {
            $history = $history | Where-Object { $_.EventName -eq $EventName }
        }
        
        if ($Last -gt 0) {
            $history = $history | Select-Object -Last $Last
        }
        
        return $history
    } -AdditionalData @{ EventName = $EventName; LastCount = $Last }
}

function global:Remove-ComponentEventHandlers {
    <#
    .SYNOPSIS
    Removes all event handlers associated with a specific component
    
    .PARAMETER ComponentId
    The ID of the component whose handlers should be removed
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ComponentId
    )
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        
        # Iterate through all events and remove handlers with matching component ID
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $handlers = $script:EventHandlers[$eventName]
            $newHandlers = @()
            
            foreach ($handler in $handlers) {
                # Check if handler has Source property matching ComponentId
                if ($handler.Source -ne $ComponentId) {
                    $newHandlers += $handler
                } else {
                    $removedCount++
                }
            }
            
            if ($newHandlers.Count -eq 0) {
                $script:EventHandlers.Remove($eventName)
            } else {
                $script:EventHandlers[$eventName] = $newHandlers
            }
        }
        
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    } -AdditionalData @{ ComponentId = $ComponentId }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-EventSystem',
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Get-EventHandlers',
    'Clear-EventHandlers',
    'Get-EventHistory',
    'Remove-ComponentEventHandlers'
)


####\modules\exceptions.psm1
#
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
# for the PMC Terminal application. This ensures all errors are consistently logged
# with rich contextual information.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# A running history of the most recent errors encountered in the application.
$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100 # Keep a reasonable number of recent errors.

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

# Define custom exception types using C# via Add-Type. This provides strongly-typed
# exceptions that can be caught specifically throughout the application.
try {
    # Only add the type if it doesn't already exist to prevent errors on module re-import.
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            // Base exception for all custom application errors. Inherits from RuntimeException for better PowerShell integration.
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException)
                {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            // Specific exception types for better categorization and targeted catch blocks.
            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
        # This log message will only appear if the logger is already imported and the log level is appropriate.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Custom Helios exception types compiled successfully."
        }
    }
} catch {
    # If Add-Type fails, this is a critical environment issue. Log it prominently.
    # The application will fall back to using standard RuntimeExceptions.
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}


# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Identifies the component/module where an error originated based on the call stack.
function _Identify-HeliosComponent {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName
        if (-not $scriptName) {
            # Walk the call stack to find the first script file.
            $callStack = Get-PSCallStack
            foreach ($frame in $callStack) {
                if ($frame.ScriptName) {
                    $scriptName = $frame.ScriptName
                    break
                }
            }
        }

        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        # Map filenames to logical application components according to the new file structure.
        $componentMap = @{
            'tui-engine'        = 'TUI Engine'
            'navigation'        = 'Navigation Service'
            'keybindings'       = 'Keybinding Service'
            'task-service'      = 'Task Service'
            'helios-components' = 'Helios UI Components'
            'helios-panels'     = 'Helios UI Panels'
            'dashboard-screen'  = 'Dashboard Screen'
            'task-screen'       = 'Task Screen'
            'exceptions'        = 'Exception Module'
            'logger'            = 'Logger Module'
            'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") {
                return $componentMap[$pattern]
            }
        }

        return "Unknown ($fileName)"

    } catch {
        return "Component Identification Failed"
    }
}

# Gathers extensive details about an error for logging and debugging.
function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp         = Get-Date -Format "o"
            Summary           = $ErrorRecord.Exception.Message
            Type              = $ErrorRecord.Exception.GetType().FullName
            Category          = $ErrorRecord.CategoryInfo.Category.ToString()
            TargetObject      = $ErrorRecord.TargetObject
            ScriptName        = $ErrorRecord.InvocationInfo.ScriptName
            LineNumber        = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line              = $ErrorRecord.InvocationInfo.Line
            PositionMessage   = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace        = $ErrorRecord.Exception.StackTrace
            InnerExceptions   = @()
            AdditionalContext = $AdditionalContext
            SystemContext     = @{
                ProcessId         = $PID
                ThreadId          = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                OS                = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{
                Message    = $innerEx.Message
                Type       = $innerEx.GetType().FullName
                StackTrace = $innerEx.StackTrace
            }
            $innerEx = $innerEx.InnerException
        }

        return $errorInfo

    } catch {
        # Fallback if the error analysis itself fails.
        return [PSCustomObject]@{
            Timestamp     = Get-Date -Format "o"
            Summary       = "CRITICAL: Error analysis failed."
            OriginalError = $ErrorRecord.Exception.Message
            AnalysisError = $_.Exception.Message
            Type          = "ErrorAnalysisFailure"
        }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        [Parameter(Mandatory)]
        [string]$Component,
        [Parameter(Mandatory)]
        [string]$Context, # A simple string describing the operation, e.g., "Loading tasks from disk".
        [hashtable]$AdditionalData = @{}
    )

    # Defensive checks
    if ($null -eq $ScriptBlock) {
        # This is a programming error, so we throw directly.
        throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null."
    }
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown Component"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown Operation"
    }

    try {
        # Execute the provided scriptblock.
        return (& $ScriptBlock)
    }
    catch {
        # This block catches any terminating error from the ScriptBlock.
        $originalErrorRecord = $_

        # 1. Identify the component where the error occurred.
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = if ($Component -ne "Unknown Component") { $Component } else { $identifiedComponent }

        # 2. Gather all possible details about the error.
        $errorContext = @{
            Operation = $Context
        }
        # Merge additional data provided by the caller.
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        # 3. Log the error using the logger module.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        # 4. Add the detailed error to the in-memory history for debugging.
        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) {
            $script:ErrorHistory.RemoveAt(0)
        }

        # 5. Create a new, rich, strongly-typed exception and throw it.
        # This allows upstream code to catch '[Helios.HeliosException]' specifically.
        # Convert PSCustomObject to Hashtable for the constructor
        $contextHashtable = @{}
        $detailedError.PSObject.Properties | ForEach-Object {
            $contextHashtable[$_.Name] = $_.Value
        }
        
        $heliosException = New-Object Helios.HeliosException(
            $originalErrorRecord.Exception.Message,
            $finalComponent,
            $contextHashtable,
            $originalErrorRecord.Exception
        )
        
        # Re-throw the rich exception to allow for top-level handling.
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param(
        [int]$Count = 25
    )
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) {
        return $script:ErrorHistory
    }

    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}


Export-ModuleMember -Function @(
    'Invoke-WithErrorHandling',
    'Get-ErrorHistory'
)

# NOTE: Custom types defined with Add-Type are automatically available to the session
# after the module is imported. They do not need to be explicitly exported.



####\modules\logger.psm1
#
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# NOTE: The use of '$script:' scope is intentional and correct for managing state
# internal to this module. It does not violate the project's scope purity rules,
# which are designed to prevent state sharing *between* modules.

$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new() # Use a generic list for better performance over @()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Internal helper to safely serialize objects for logging, preventing circular references or errors.
function ConvertTo-SerializableObject {
    param([object]$Object)

    if ($null -eq $Object) { return $null }

    # Use a set to track visited objects to prevent infinite recursion
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'

    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)

        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        
        # For non-collection reference types, add to visited set
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) {
            [void]$visited.Add($InputObject)
        }

        switch ($InputObject.GetType().Name) {
            'Hashtable' {
                $result = @{}
                foreach ($key in $InputObject.Keys) {
                    try {
                        $result[$key] = Convert-Internal -InputObject $InputObject[$key] -Depth ($Depth + 1)
                    } catch {
                        $result[$key] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'PSCustomObject' {
                $result = @{}
                foreach ($prop in $InputObject.PSObject.Properties) {
                    try {
                        # Avoid serializing script methods
                        if ($prop.MemberType -ne 'ScriptMethod') {
                           $result[$prop.Name] = Convert-Internal -InputObject $prop.Value -Depth ($Depth + 1)
                        }
                    } catch {
                        $result[$prop.Name] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'Object[]' {
                $result = @()
                # Limit array size for performance
                for ($i = 0; $i -lt [Math]::Min($InputObject.Count, 10); $i++) {
                    try {
                        $result += Convert-Internal -InputObject $InputObject[$i] -Depth ($Depth + 1)
                    } catch {
                        $result += "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                if ($InputObject.Count -gt 10) {
                    $result += "<... $($InputObject.Count - 10) more items>"
                }
                return $result
            }
            default {
                try {
                    # For simple types, return as-is or convert to string
                    if ($InputObject -is [string] -or $InputObject -is [int] -or $InputObject -is [bool] -or $InputObject -is [double] -or $InputObject -is [datetime] -or $InputObject -is [decimal]) {
                        return $InputObject
                    } else {
                        return $InputObject.ToString()
                    }
                } catch {
                    return "<ToString failed: $($_.Exception.Message)>"
                }
            }
        }
    }

    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )

    # Defensive checks
    if ([string]::IsNullOrWhiteSpace($LogDirectory)) {
        Write-Warning "Initialize-Logger: LogDirectory parameter cannot be null or empty."
        return
    }
    if ([string]::IsNullOrWhiteSpace($LogFileName)) {
        Write-Warning "Initialize-Logger: LogFileName parameter cannot be null or empty."
        return
    }

    try {
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null
        }

        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true

        Write-Log -Level Info -Message "Logger initialized" -Data @{
            LogPath           = $script:LogPath
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            OS                = $PSVersionTable.OS
            ProcessId         = $PID
            InitializedAt     = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        } -Force # Force this initial message to be written

    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data,
        [switch]$Force # Force logging even if level is below threshold
    )

    if (-not $script:LogInitialized -and -not $Force) { return }

    $levelPriority = @{
        Debug   = 0
        Trace   = 0
        Verbose = 1
        Info    = 2
        Warning = 3
        Error   = 4
        Fatal   = 5
    }

    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }

    try {
        $callStack = Get-PSCallStack
        $caller = if ($callStack.Count -gt 1) { $callStack[1] } else { $callStack[0] }

        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId

        $logContext = @{
            Timestamp     = $timestamp
            Level         = $Level
            ThreadId      = $threadId
            CallDepth     = $script:CallDepth
            Message       = $Message
            Caller        = @{
                Command      = $caller.Command
                Location     = $caller.Location
                ScriptName   = $caller.ScriptName
                LineNumber   = $caller.ScriptLineNumber
            }
        }

        if ($PSBoundParameters.ContainsKey('Data')) {
            $logContext.UserData = if ($Data -is [Exception]) {
                @{
                    Type           = "Exception"
                    Message        = $Data.Message
                    StackTrace     = $Data.StackTrace
                    InnerException = if ($Data.InnerException) { $Data.InnerException.Message } else { $null }
                }
            } else {
                ConvertTo-SerializableObject -Object $Data
            }
        }

        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) {
            "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)"
        } else {
            $caller.Command
        }

        $logEntry = "$timestamp [$($Level.PadRight(7))] $indent [$callerInfo] $Message"

        if ($PSBoundParameters.ContainsKey('Data')) {
            $dataStr = if ($Data -is [Exception]) {
                "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)"
            } else {
                try {
                    $json = ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue
                    "`n${indent}  Data: $json"
                } catch {
                    "`n${indent}  Data: $($Data.ToString())"
                }
            }
            $logEntry += $dataStr
        }

        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) {
            $script:LogQueue.RemoveRange(0, $script:LogQueue.Count - 2000)
        }

        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                    $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                    Move-Item $script:LogPath $archivePath -Force
                }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch {
                Write-Host "LOG WRITE FAILED: $logEntry" -ForegroundColor Yellow
                Write-Host "Error: $_" -ForegroundColor Red
            }
        }

        if ($Level -in @('Error', 'Fatal', 'Warning')) {
            $color = if ($Level -in @('Error', 'Fatal')) { 'Red' } else { 'Yellow' }
            Write-Host $logEntry -ForegroundColor $color
        }

    } catch {
        try {
            $errorEntry = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff') [LOGGER ERROR] Failed to log message '$Message': $_"
            if ($script:LogPath) {
                Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8
            }
            Write-Host $errorEntry -ForegroundColor Red
        } catch {
            Write-Host "CRITICAL: Logger completely failed: $_" -ForegroundColor Red
        }
    }
}

function Trace-FunctionEntry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$Parameters
    )
    if (-not $script:TraceAllCalls) { return }
    $script:CallDepth++
    Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{
        Parameters = $Parameters
        Action     = "FunctionEntry"
    }
}

function Trace-FunctionExit {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$ReturnValue,
        [switch]$WithError
    )
    if (-not $script:TraceAllCalls) { return }
    Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{
        ReturnValue = $ReturnValue
        Action      = if ($WithError) { "FunctionExitWithError" } else { "FunctionExit" }
        HasError    = $WithError.IsPresent
    }
    $script:CallDepth--
    if ($script:CallDepth -lt 0) { $script:CallDepth = 0 }
}

function Trace-Step {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StepName,
        [object]$StepData,
        [string]$Module
    )
    $caller = (Get-PSCallStack)[1]
    $moduleInfo = if ($Module) { $Module } elseif ($caller.ScriptName) { [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) } else { "Unknown" }

    Write-Log -Level Debug -Message "STEP: $StepName" -Data @{
        StepData = $StepData
        Module   = $moduleInfo
        Action   = "Step"
    }
}

function Trace-StateChange {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StateType,
        [object]$OldValue,
        [object]$NewValue,
        [string]$PropertyPath
    )
    Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{
        StateType    = $StateType
        PropertyPath = $PropertyPath
        OldValue     = $OldValue
        NewValue     = $NewValue
        Action       = "StateChange"
    }
}

function Trace-ComponentLifecycle {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ComponentType,
        [Parameter(Mandatory)]
        [string]$ComponentId,
        [Parameter(Mandatory)]
        [ValidateSet('Create', 'Initialize', 'Render', 'Update', 'Destroy')]
        [string]$Phase,
        [object]$ComponentData
    )
    Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{
        ComponentType = $ComponentType
        ComponentId   = $ComponentId
        Phase         = $Phase
        ComponentData = $ComponentData
        Action        = "ComponentLifecycle"
    }
}

function Trace-ServiceCall {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ServiceName,
        [Parameter(Mandatory)]
        [string]$MethodName,
        [object]$Parameters,
        [object]$Result,
        [switch]$IsError
    )
    $action = if ($IsError) { "ServiceCallError" } else { "ServiceCall" }
    Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{
        ServiceName = $ServiceName
        MethodName  = $MethodName
        Parameters  = $Parameters
        Result      = $Result
        Action      = $action
        IsError     = $IsError.IsPresent
    }
}

function Get-LogEntries {
    [CmdletBinding()]
    param(
        [int]$Count = 100,
        [string]$Level,
        [string]$Module,
        [string]$Action
    )
    try {
        $entries = $script:LogQueue.ToArray() # Work on a copy

        if ($Level) {
            $entries = $entries | Where-Object { $_.Level -eq $Level }
        }
        if ($Module) {
            $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") }
        }
        if ($Action) {
            $entries = $entries | Where-Object { $_.UserData.Action -eq $Action }
        }

        return $entries | Select-Object -Last $Count
    } catch {
        Write-Warning "Error getting log entries: $_"
        return @()
    }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)

    try {
        $callStack = Get-PSCallStack
        $trace = @()

        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { # Skip self
            $call = $callStack[$i]
            $trace += @{
                Level      = $i - 1
                Command    = $call.Command
                Location   = $call.Location
                ScriptName = $call.ScriptName
                LineNumber = $call.ScriptLineNumber
            }
        }
        return $trace
    } catch {
        Write-Warning "Error getting call trace: $_"
        return @()
    }
}

function Clear-LogQueue {
    param()
    try {
        $script:LogQueue.Clear()
        Write-Log -Level Info -Message "In-memory log queue cleared"
    } catch {
        Write-Warning "Error clearing log queue: $_"
    }
}

function Set-LogLevel {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level
    )
    try {
        $oldLevel = $script:LogLevel
        $script:LogLevel = $Level
        Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force
    } catch {
        Write-Warning "Error setting log level to '$Level': $_"
    }
}

function Enable-CallTracing {
    param()
    $script:TraceAllCalls = $true
    Write-Log -Level Info -Message "Call tracing enabled" -Force
}

function Disable-CallTracing {
    param()
    $script:TraceAllCalls = $false
    Write-Log -Level Info -Message "Call tracing disabled" -Force
}

function Get-LogPath {
    param()
    return $script:LogPath
}

function Get-LogStatistics {
    param()
    try {
        $stats = [PSCustomObject]@{
            TotalEntries       = $script:LogQueue.Count
            LogPath            = $script:LogPath
            LogLevel           = $script:LogLevel
            CallTracingEnabled = $script:TraceAllCalls
            LogFileSize        = if ($script:LogPath -and (Test-Path $script:LogPath)) { (Get-Item $script:LogPath).Length } else { 0 }
            EntriesByLevel     = @{}
            EntriesByModule    = @{}
            EntriesByAction    = @{}
        }

        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level
            if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level] = 0 }
            $stats.EntriesByLevel[$level]++

            if ($entry.Caller.ScriptName) {
                $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName)
                if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module] = 0 }
                $stats.EntriesByModule[$module]++
            }

            if ($entry.UserData -and $entry.UserData.Action) {
                $action = $entry.UserData.Action
                if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action] = 0 }
                $stats.EntriesByAction[$action]++
            }
        }

        return $stats
    } catch {
        Write-Warning "Error getting log statistics: $_"
        return [PSCustomObject]@{}
    }
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Trace-FunctionEntry',
    'Trace-FunctionExit',
    'Trace-Step',
    'Trace-StateChange',
    'Trace-ComponentLifecycle',
    'Trace-ServiceCall',
    'Get-LogEntries',
    'Get-CallTrace',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Enable-CallTracing',
    'Disable-CallTracing',
    'Get-LogPath',
    'Get-LogStatistics'
)


####\modules\models.psm1
#Requires -Version 5.1
<#
.SYNOPSIS
    Data model definitions for the PMC application
    
.DESCRIPTION
    This module defines all core data classes and enums used throughout the application.
    It is self-contained with no dependencies on other modules.
    
.NOTES
    AI: This module replaces the previous implicit data structures with strongly-typed classes
    AI: Using PowerShell native enum syntax for better compatibility
#>

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Enums - Define first for class dependencies

# AI: Using PowerShell native enum syntax instead of Add-Type for better reliability
enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

#endregion

#region Classes

class PmcTask {
    # Core properties
    [string]$Id
    [string]$Title
    [string]$Description
    [TaskStatus]$Status
    [TaskPriority]$Priority
    [string]$ProjectKey
    [string]$Category  # AI: Maintained for backward compatibility
    [datetime]$CreatedAt
    [datetime]$UpdatedAt
    
    # Optional properties
    [Nullable[datetime]]$DueDate
    [string[]]$Tags
    [int]$Progress  # AI: Progress percentage (0-100)
    
    # Legacy support
    [bool]$Completed  # AI: Computed property for backward compatibility
    
    # Default constructor
    PmcTask() {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = ""
        $this.Description = ""
        $this.Status = [TaskStatus]::Pending
        $this.Priority = [TaskPriority]::Medium
        $this.ProjectKey = "General"
        $this.Category = "General"
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.DueDate = $null
        $this.Tags = @()
        $this.Progress = 0
        $this.Completed = $false
    }
    
    # Constructor with title
    PmcTask([string]$title) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = $title
        $this.Description = ""
        $this.Status = [TaskStatus]::Pending
        $this.Priority = [TaskPriority]::Medium
        $this.ProjectKey = "General"
        $this.Category = "General"
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.DueDate = $null
        $this.Tags = @()
        $this.Progress = 0
        $this.Completed = $false
    }
    
    # Full constructor
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.Title = $title
        $this.Description = $description
        $this.Status = [TaskStatus]::Pending
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey  # AI: Set for backward compatibility
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.DueDate = $null
        $this.Tags = @()
        $this.Progress = 0
        $this.Completed = $false
    }
    
    # Methods
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Completed = $true
        $this.Progress = 100
        $this.UpdatedAt = [datetime]::Now
    }
    
    [void] UpdateProgress([int]$progress) {
        if ($progress -lt 0 -or $progress -gt 100) {
            throw "Progress must be between 0 and 100"
        }
        
        $this.Progress = $progress
        
        # AI: Auto-update status based on progress
        if ($progress -eq 0) {
            $this.Status = [TaskStatus]::Pending
            $this.Completed = $false
        }
        elseif ($progress -gt 0 -and $progress -lt 100) {
            $this.Status = [TaskStatus]::InProgress
            $this.Completed = $false
        }
        elseif ($progress -eq 100) {
            $this.Status = [TaskStatus]::Completed
            $this.Completed = $true
        }
        
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() {
        if ($null -eq $this.DueDate) {
            return "N/A"
        }
        return $this.DueDate.ToString("yyyy-MM-dd")
    }
    
    # AI: Helper method for legacy data format conversion
    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id
            title = $this.Title
            description = $this.Description
            completed = $this.Completed
            priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey
            due_date = if ($null -ne $this.DueDate) { $this.GetDueDateString() } else { $null }
            created_at = $this.CreatedAt.ToString("o")
            updated_at = $this.UpdatedAt.ToString("o")
        }
    }
    
    # AI: Static method to create from legacy format
    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        
        if ($legacyData.id) { $task.Id = $legacyData.id }
        if ($legacyData.title) { $task.Title = $legacyData.title }
        if ($legacyData.description) { $task.Description = $legacyData.description }
        
        # Handle priority conversion
        if ($legacyData.priority) {
            switch ($legacyData.priority.ToLower()) {
                "low" { $task.Priority = [TaskPriority]::Low }
                "medium" { $task.Priority = [TaskPriority]::Medium }
                "high" { $task.Priority = [TaskPriority]::High }
                default { $task.Priority = [TaskPriority]::Medium }
            }
        }
        
        # Handle project/category
        if ($legacyData.project) { 
            $task.ProjectKey = $legacyData.project
            $task.Category = $legacyData.project
        }
        elseif ($legacyData.Category) {
            $task.ProjectKey = $legacyData.Category
            $task.Category = $legacyData.Category
        }
        
        # Handle dates
        if ($legacyData.created_at) {
            try {
                $task.CreatedAt = [datetime]::Parse($legacyData.created_at)
            }
            catch {
                $task.CreatedAt = [datetime]::Now
            }
        }
        
        if ($legacyData.updated_at) {
            try {
                $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at)
            }
            catch {
                $task.UpdatedAt = [datetime]::Now
            }
        }
        
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") {
            try {
                $task.DueDate = [datetime]::Parse($legacyData.due_date)
            }
            catch {
                $task.DueDate = $null
            }
        }
        
        # Handle completion status
        if ($legacyData.completed -eq $true) {
            $task.Status = [TaskStatus]::Completed
            $task.Completed = $true
            $task.Progress = 100
        }
        
        return $task
    }
}

class PmcProject {
    # Core properties
    [string]$Key
    [string]$Name
    [string]$Client
    [BillingType]$BillingType
    [double]$Rate
    [double]$Budget
    [bool]$Active
    [datetime]$CreatedAt
    [datetime]$UpdatedAt
    
    # Additional identifiers
    [string]$Id1  # AI: External system ID 1
    [string]$Id2  # AI: External system ID 2
    
    # Computed properties
    [double]$SpentBudget
    [double]$RemainingBudget
    
    # Default constructor
    PmcProject() {
        $this.Key = ""
        $this.Name = ""
        $this.Client = ""
        $this.BillingType = [BillingType]::NonBillable
        $this.Rate = 0.0
        $this.Budget = 0.0
        $this.Active = $true
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.Id1 = ""
        $this.Id2 = ""
        $this.SpentBudget = 0.0
        $this.RemainingBudget = 0.0
    }
    
    # Constructor with key and name
    PmcProject([string]$key, [string]$name) {
        $this.Key = $key
        $this.Name = $name
        $this.Client = ""
        $this.BillingType = [BillingType]::NonBillable
        $this.Rate = 0.0
        $this.Budget = 0.0
        $this.Active = $true
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.Id1 = ""
        $this.Id2 = ""
        $this.SpentBudget = 0.0
        $this.RemainingBudget = 0.0
    }
    
    # Full constructor
    PmcProject([string]$key, [string]$name, [string]$client, [BillingType]$billingType, [double]$rate) {
        $this.Key = $key
        $this.Name = $name
        $this.Client = $client
        $this.BillingType = $billingType
        $this.Rate = $rate
        $this.Budget = 0.0
        $this.Active = $true
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
        $this.Id1 = ""
        $this.Id2 = ""
        $this.SpentBudget = 0.0
        $this.RemainingBudget = 0.0
    }
    
    # Methods
    [void] UpdateBudgetSpent([double]$amount) {
        if ($amount -lt 0) {
            throw "Spent amount cannot be negative"
        }
        
        $this.SpentBudget = $amount
        $this.RemainingBudget = $this.Budget - $amount
        $this.UpdatedAt = [datetime]::Now
    }
    
    [void] Deactivate() {
        $this.Active = $false
        $this.UpdatedAt = [datetime]::Now
    }
    
    [void] Activate() {
        $this.Active = $true
        $this.UpdatedAt = [datetime]::Now
    }
    
    [bool] IsBillable() {
        return $this.BillingType -eq [BillingType]::Billable
    }
    
    [bool] IsOverBudget() {
        return ($this.Budget -gt 0) -and ($this.SpentBudget -gt $this.Budget)
    }
    
    # AI: Helper method for legacy data format conversion
    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key
            Name = $this.Name
            Client = $this.Client
            BillingType = $this.BillingType.ToString()
            Rate = $this.Rate
            Budget = $this.Budget
            Active = $this.Active
            CreatedAt = $this.CreatedAt.ToString("o")
            Id1 = $this.Id1
            Id2 = $this.Id2
        }
    }
    
    # AI: Static method to create from legacy format
    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        
        if ($legacyData.Key) { $project.Key = $legacyData.Key }
        if ($legacyData.Name) { $project.Name = $legacyData.Name }
        if ($legacyData.Client) { $project.Client = $legacyData.Client }
        
        # Handle billing type conversion
        if ($legacyData.BillingType) {
            switch ($legacyData.BillingType) {
                "Billable" { $project.BillingType = [BillingType]::Billable }
                "NonBillable" { $project.BillingType = [BillingType]::NonBillable }
                default { $project.BillingType = [BillingType]::NonBillable }
            }
        }
        
        if ($null -ne $legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($null -ne $legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($null -ne $legacyData.Active) { $project.Active = [bool]$legacyData.Active }
        
        if ($legacyData.CreatedAt) {
            try {
                $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt)
            }
            catch {
                $project.CreatedAt = [datetime]::Now
            }
        }
        
        if ($legacyData.Id1) { $project.Id1 = $legacyData.Id1 }
        if ($legacyData.Id2) { $project.Id2 = $legacyData.Id2 }
        
        # Set UpdatedAt to CreatedAt if not migrating
        $project.UpdatedAt = $project.CreatedAt
        
        return $project
    }
}

#endregion

# Export all public types
# AI: In PowerShell 5.1, enums need to be explicitly made available in global scope
$global:TaskStatus = [TaskStatus]
$global:TaskPriority = [TaskPriority]
$global:BillingType = [BillingType]
$global:PmcTask = [PmcTask]
$global:PmcProject = [PmcProject]

Export-ModuleMember -Function * -Variable * -Alias @(
    'TaskStatus',
    'TaskPriority', 
    'BillingType',
    'PmcTask',
    'PmcProject'
)



####\modules\state-manager.psm1
# State Manager Module
# Simple, practical reactive state management for PowerShell TUI

function global:New-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state object for managing application or screen state
    
    .DESCRIPTION
    This creates a PowerShell object that tracks state changes and notifies
    subscribers when values change. It's designed to be simple and practical.
    
    .PARAMETER InitialState
    Hashtable of initial state values
    
    .PARAMETER Actions
    Hashtable of named actions (methods) that can mutate the state
    
    .EXAMPLE
    $state = New-TuiState -InitialState @{ count = 0; name = "Test" } -Actions @{
        Increment = { $this.count++ }
        SetName = { param($name) $this.name = $name }
    }
    $state.Subscribe('count', { param($new, $old) Write-Host "Count changed from $old to $new" })
    $state.Increment()
    #>
    param(
        [hashtable]$InitialState = @{},
        [hashtable]$Actions = @{}
    )
    
    # Create the state object
    $stateObject = [PSCustomObject]@{
        # Private properties
        _data = $InitialState.Clone()
        _subscribers = @{}
        _suspendNotifications = $false
    }
    
    # Add dynamic properties for each state key
    foreach ($key in $InitialState.Keys) {
        $stateObject | Add-Member -MemberType ScriptProperty -Name $key -Value {
            # Getter
            $this._data[$key]
        }.GetNewClosure() -SecondValue {
            # Setter
            param($value)
            $this.SetValue($key, $value)
        }.GetNewClosure()
    }
    
    # Core methods
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'SetValue' -Value {
        param([string]$key, $value)
        
        $oldValue = $this._data[$key]
        
        # Skip if value hasn't changed
        if ($oldValue -eq $value) { return }
        
        # Update the value
        $this._data[$key] = $value
        
        # Notify subscribers unless suspended
        if (-not $this._suspendNotifications) {
            $this._NotifySubscribers($key, $value, $oldValue)
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetValue' -Value {
        param([string]$key)
        return $this._data[$key]
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Subscribe' -Value {
        param(
            [string]$key,
            [scriptblock]$handler
        )
        
        if (-not $this._subscribers.ContainsKey($key)) {
            $this._subscribers[$key] = @()
        }
        
        # Generate unique ID for this subscription
        $subscriptionId = [Guid]::NewGuid().ToString()
        
        $this._subscribers[$key] += @{
            Id = $subscriptionId
            Handler = $handler
        }
        
        # Call handler immediately with current value
        try {
            & $handler $this._data[$key] $null
        } catch {
            Write-Warning "State subscription handler error: $_"
        }
        
        # Return subscription ID for unsubscribing
        return $subscriptionId
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Unsubscribe' -Value {
        param([string]$subscriptionId)
        
        foreach ($key in $this._subscribers.Keys) {
            $this._subscribers[$key] = @($this._subscribers[$key] | Where-Object { $_.Id -ne $subscriptionId })
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'Update' -Value {
        param([hashtable]$updates)
        
        # Suspend notifications during bulk update
        $this._suspendNotifications = $true
        
        try {
            foreach ($key in $updates.Keys) {
                $this.SetValue($key, $updates[$key])
            }
        } finally {
            $this._suspendNotifications = $false
        }
        
        # Notify all affected keys
        foreach ($key in $updates.Keys) {
            if ($this._data[$key] -ne $this._data[$key]) { # Check if changed
                $this._NotifySubscribers($key, $this._data[$key], $null)
            }
        }
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name 'GetState' -Value {
        # Return a copy of the current state
        return $this._data.Clone()
    }
    
    $stateObject | Add-Member -MemberType ScriptMethod -Name '_NotifySubscribers' -Value {
        param($key, $newValue, $oldValue)
        
        # Notify specific key subscribers
        if ($this._subscribers.ContainsKey($key)) {
            foreach ($subscription in $this._subscribers[$key]) {
                try {
                    & $subscription.Handler $newValue $oldValue
                } catch {
                    Write-Warning "State notification error for key '$key': $_"
                }
            }
        }
        
        # Notify wildcard subscribers
        if ($this._subscribers.ContainsKey('*')) {
            foreach ($subscription in $this._subscribers['*']) {
                try {
                    & $subscription.Handler @{
                        Key = $key
                        NewValue = $newValue
                        OldValue = $oldValue
                    }
                } catch {
                    Write-Warning "Wildcard state notification error: $_"
                }
            }
        }
    }
    
    # Add user-defined actions as methods
    foreach ($actionName in $Actions.Keys) {
        $stateObject | Add-Member -MemberType ScriptMethod -Name $actionName -Value $Actions[$actionName]
    }
    
    return $stateObject
}

function global:New-ComputedState {
    <#
    .SYNOPSIS
    Creates a computed/derived state value that updates automatically
    
    .PARAMETER Source
    The source state object to derive from
    
    .PARAMETER Keys
    Array of state keys to watch for changes
    
    .PARAMETER Compute
    Scriptblock that computes the derived value
    
    .EXAMPLE
    $filtered = New-ComputedState -Source $state -Keys @('tasks', 'filter') -Compute {
        param($state)
        $state.tasks | Where-Object { $_.Status -eq $state.filter }
    }
    #>
    param(
        [PSCustomObject]$Source,
        [string[]]$Keys,
        [scriptblock]$Compute
    )
    
    $computed = [PSCustomObject]@{
        _source = $Source
        _value = $null
        _compute = $Compute
        _subscriptions = @()
    }
    
    # Add Value property
    $computed | Add-Member -MemberType ScriptProperty -Name 'Value' -Value {
        $this._value
    }
    
    # Recompute method
    $computed | Add-Member -MemberType ScriptMethod -Name '_Recompute' -Value {
        try {
            $this._value = & $this._compute $this._source
        } catch {
            Write-Warning "Computed state error: $_"
        }
    }
    
    # Initial computation
    $computed._Recompute()
    
    # Subscribe to changes
    foreach ($key in $Keys) {
        $subId = $Source.Subscribe($key, {
            $computed._Recompute()
        })
        $computed._subscriptions += $subId
    }
    
    # Cleanup method
    $computed | Add-Member -MemberType ScriptMethod -Name 'Dispose' -Value {
        foreach ($subId in $this._subscriptions) {
            $this._source.Unsubscribe($subId)
        }
    }
    
    return $computed
}

# Export functions
Export-ModuleMember -Function @('New-TuiState', 'New-ComputedState')



####\modules\text-resources-FIXED.psm1
# Text Resource Management Module
# Provides centralized text/string management for internationalization

# Script-level variable to store all text resources
$script:TextResources = @{
    # Dashboard screen specific
    Dashboard = @{
        Title = "PMC Terminal v5 - Dashboard"
        Welcome = "Welcome to PMC Terminal"
        QuickActions = "Quick Actions"
        ActiveTimers = "Active Timers"
        TodaysTasks = "Today's Tasks"
        Stats = "Statistics"
        NoTimersActive = "No active timers"
        NoTasksToday = "No tasks for today"
    }
    
    # Task screen specific
    Tasks = @{
        Title = "Task Management"
        AddTask = "Add Task"
        EditTask = "Edit Task"
        DeleteConfirm = "Are you sure you want to delete this task?"
        FilterAll = "All"
        FilterActive = "Active"
        FilterCompleted = "Completed"
        SortByPriority = "Priority"
        SortByDueDate = "Due Date"
        SortByCreated = "Created"
    }
    
    # Timer screen specific
    Timer = @{
        Title = "Timer Management"
        StartTimer = "Start Timer"
        StopTimer = "Stop Timer"
        PauseTimer = "Pause Timer"
        ResumeTimer = "Resume Timer"
        TimerRunning = "Timer Running"
        TimerPaused = "Timer Paused"
        TimerStopped = "Timer Stopped"
        ElapsedTime = "Elapsed Time"
    }
    
    # Settings screen specific
    Settings = @{
        Title = "Settings"
        General = "General Settings"
        Appearance = "Appearance"
        Behavior = "Behavior"
        DataSettings = "Data Settings"
        ImportData = "Import Data"
        ExportData = "Export Data"
        ResetSettings = "Reset to Defaults"
    }
    
    # Common UI elements
    Common = @{
        Save = "Save"
        Cancel = "Cancel"
        Delete = "Delete"
        Edit = "Edit"
        Add = "Add"
        Remove = "Remove"
        Close = "Close"
        Back = "Back"
        Next = "Next"
        Previous = "Previous"
        Yes = "Yes"
        No = "No"
        OK = "OK"
        Error = "Error"
        Warning = "Warning"
        Info = "Info"
        Success = "Success"
    }
    
    # Error messages
    Errors = @{
        FileNotFound = "File not found: {0}"
        AccessDenied = "Access denied to file: {0}"
        InvalidData = "Invalid data format"
        NetworkError = "Network connection error"
        DatabaseError = "Database operation failed"
        UnexpectedError = "An unexpected error occurred"
    }
}

function global:Get-Text {
    <#
    .SYNOPSIS
    Gets a text resource by key path
    
    .PARAMETER Key
    Dot-separated path to the text resource (e.g., "Dashboard.Welcome")
    
    .PARAMETER Format
    Optional format arguments for string formatting
    
    .EXAMPLE
    Get-Text "Dashboard.Welcome"
    
    .EXAMPLE
    Get-Text "Errors.FileNotFound" "myfile.txt"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(ValueFromRemainingArguments=$true)]
        [object[]]$Format
    )
    Invoke-WithErrorHandling -Component "TextResources.GetText" -Context "GetText" -ScriptBlock {
        # Navigate the nested hashtable
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                Write-Warning "Text resource not found: '$Key'"
                return $Key  # Return the key as fallback
            }
        }
        
        # Format the string if arguments provided
        if ($Format -and $Format.Count -gt 0) {
            try {
                return $current -f $Format
            } catch {
                Write-Warning "Failed to format text resource '$Key': $_"
                return $current
            }
        }
        
        return $current
    } -AdditionalData @{ Key = $Key; FormatArgs = $Format }
}

function global:Set-TextResource {
    <#
    .SYNOPSIS
    Sets or updates a text resource
    
    .PARAMETER Key
    Dot-separated path to the text resource
    
    .PARAMETER Value
    The text value to set
    
    .EXAMPLE
    Set-TextResource "Custom.WelcomeMessage" "Welcome to my app!"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(Mandatory=$true)]
        [string]$Value
    )
    Invoke-WithErrorHandling -Component "TextResources.SetTextResource" -Context "SetTextResource" -ScriptBlock {
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        # Navigate to the parent container
        for ($i = 0; $i -lt ($parts.Count - 1); $i++) {
            $part = $parts[$i]
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            }
            $current = $current[$part]
        }
        
        # Set the final value
        $current[$parts[-1]] = $Value
        Write-Verbose "Set text resource '$Key' to '$Value'"
    } -AdditionalData @{ Key = $Key; Value = $Value }
}

function global:Get-TextResources {
    <#
    .SYNOPSIS
    Gets all text resources (useful for export/import)
    #>
    Invoke-WithErrorHandling -Component "TextResources.GetTextResources" -Context "GetAllResources" -ScriptBlock {
        return $script:TextResources.Clone()
    }
}

function global:Import-TextResources {
    <#
    .SYNOPSIS
    Imports text resources from a file
    
    .PARAMETER Path
    Path to JSON file containing text resources
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ImportTextResources" -Context "ImportTextResources" -ScriptBlock {
        if (Test-Path $Path) {
            try {
                $imported = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
                $script:TextResources = $imported
                Write-Host "Text resources imported successfully"
            } catch {
                Write-Log -Level Error -Message "Failed to import text resources from '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
            }
        } else {
            Write-Log -Level Error -Message "File not found: $Path" -Data @{ FilePath = $Path }
        }
    } -AdditionalData @{ FilePath = $Path }
}

function global:Export-TextResources {
    <#
    .SYNOPSIS
    Exports text resources to a file
    
    .PARAMETER Path
    Path to save the JSON file
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ExportTextResources" -Context "ExportTextResources" -ScriptBlock {
        try {
            $script:TextResources | ConvertTo-Json -Depth 10 | Set-Content $Path
            Write-Host "Text resources exported successfully"
        } catch {
            Write-Log -Level Error -Message "Failed to export text resources to '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
        }
    } -AdditionalData @{ FilePath = $Path }
}

# Export functions
Export-ModuleMember -Function @(
    'Get-Text',
    'Set-TextResource',
    'Get-TextResources',
    'Import-TextResources',
    'Export-TextResources'
)


####\modules\text-resources.psm1
# Text Resource Management Module
# Provides centralized text/string management for internationalization

# Script-level variable to store all text resources
$script:TextResources = @{
    # Dashboard screen specific
    Dashboard = @{
        Title = "PMC Terminal v5 - Dashboard"
        Welcome = "Welcome to PMC Terminal"
        QuickActions = "Quick Actions"
        ActiveTimers = "Active Timers"
        TodaysTasks = "Today's Tasks"
        Stats = "Statistics"
        NoTimersActive = "No active timers"
        NoTasksToday = "No tasks for today"
    }
    
    # Task screen specific
    Tasks = @{
        Title = "Task Management"
        AddTask = "Add Task"
        EditTask = "Edit Task"
        DeleteConfirm = "Are you sure you want to delete this task?"
        FilterAll = "All"
        FilterActive = "Active"
        FilterCompleted = "Completed"
        SortByPriority = "Priority"
        SortByDueDate = "Due Date"
        SortByCreated = "Created"
    }
    
    # Timer screen specific
    Timer = @{
        Title = "Timer Management"
        StartTimer = "Start Timer"
        StopTimer = "Stop Timer"
        PauseTimer = "Pause Timer"
        ResumeTimer = "Resume Timer"
        TimerRunning = "Timer Running"
        TimerPaused = "Timer Paused"
        TimerStopped = "Timer Stopped"
        ElapsedTime = "Elapsed Time"
    }
    
    # Settings screen specific
    Settings = @{
        Title = "Settings"
        General = "General Settings"
        Appearance = "Appearance"
        Behavior = "Behavior"
        DataSettings = "Data Settings"
        ImportData = "Import Data"
        ExportData = "Export Data"
        ResetSettings = "Reset to Defaults"
    }
    
    # Common UI elements
    Common = @{
        Save = "Save"
        Cancel = "Cancel"
        Delete = "Delete"
        Edit = "Edit"
        Add = "Add"
        Remove = "Remove"
        Close = "Close"
        Back = "Back"
        Next = "Next"
        Previous = "Previous"
        Yes = "Yes"
        No = "No"
        OK = "OK"
        Error = "Error"
        Warning = "Warning"
        Info = "Info"
        Success = "Success"
    }
    
    # Error messages
    Errors = @{
        FileNotFound = "File not found: {0}"
        AccessDenied = "Access denied to file: {0}"
        InvalidData = "Invalid data format"
        NetworkError = "Network connection error"
        DatabaseError = "Database operation failed"
        UnexpectedError = "An unexpected error occurred"
    }
}

function global:Get-Text {
    <#
    .SYNOPSIS
    Gets a text resource by key path
    
    .PARAMETER Key
    Dot-separated path to the text resource (e.g., "Dashboard.Welcome")
    
    .PARAMETER Format
    Optional format arguments for string formatting
    
    .EXAMPLE
    Get-Text "Dashboard.Welcome"
    
    .EXAMPLE
    Get-Text "Errors.FileNotFound" "myfile.txt"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(ValueFromRemainingArguments=$true)]
        [object[]]$Format
    )
    Invoke-WithErrorHandling -Component "TextResources.GetText" -Context "GetText" -ScriptBlock {
        # Navigate the nested hashtable
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                Write-Warning "Text resource not found: '$Key'"
                return $Key  # Return the key as fallback
            }
        }
        
        # Format the string if arguments provided
        if ($Format -and $Format.Count -gt 0) {
            try {
                return $current -f $Format
            } catch {
                Write-Warning "Failed to format text resource '$Key': $_"
                return $current
            }
        }
        
        return $current
    } -AdditionalData @{ Key = $Key; FormatArgs = $Format }
}

function global:Set-TextResource {
    <#
    .SYNOPSIS
    Sets or updates a text resource
    
    .PARAMETER Key
    Dot-separated path to the text resource
    
    .PARAMETER Value
    The text value to set
    
    .EXAMPLE
    Set-TextResource "Custom.WelcomeMessage" "Welcome to my app!"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Key,
        
        [Parameter(Mandatory=$true)]
        [string]$Value
    )
    Invoke-WithErrorHandling -Component "TextResources.SetTextResource" -Context "SetTextResource" -ScriptBlock {
        $parts = $Key -split '\.'
        $current = $script:TextResources
        
        # Navigate to the parent container
        for ($i = 0; $i -lt ($parts.Count - 1); $i++) {
            $part = $parts[$i]
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            }
            $current = $current[$part]
        }
        
        # Set the final value
        $current[$parts[-1]] = $Value
        Write-Verbose "Set text resource '$Key' to '$Value'"
    } -AdditionalData @{ Key = $Key; Value = $Value }
}

function global:Get-TextResources {
    <#
    .SYNOPSIS
    Gets all text resources (useful for export/import)
    #>
    Invoke-WithErrorHandling -Component "TextResources.GetTextResources" -Context "GetAllResources" -ScriptBlock {
        return $script:TextResources.Clone()
    }
}

function global:Import-TextResources {
    <#
    .SYNOPSIS
    Imports text resources from a file
    
    .PARAMETER Path
    Path to JSON file containing text resources
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ImportTextResources" -Context "ImportTextResources" -ScriptBlock {
        if (Test-Path $Path) {
            try {
                $imported = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
                $script:TextResources = $imported
                Write-Host "Text resources imported successfully"
            } catch {
                Write-Log -Level Error -Message "Failed to import text resources from '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
            }
        } else {
            Write-Log -Level Error -Message "File not found: $Path" -Data @{ FilePath = $Path }
        }
    } -AdditionalData @{ FilePath = $Path }
}

function global:Export-TextResources {
    <#
    .SYNOPSIS
    Exports text resources to a file
    
    .PARAMETER Path
    Path to save the JSON file
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "TextResources.ExportTextResources" -Context "ExportTextResources" -ScriptBlock {
        try {
            $script:TextResources | ConvertTo-Json -Depth 10 | Set-Content $Path
            Write-Host "Text resources exported successfully"
        } catch {
            Write-Log -Level Error -Message "Failed to export text resources to '$Path': $_" -Data @{ FilePath = $Path; Exception = $_ }
        }
    } -AdditionalData @{ FilePath = $Path }
}

# Export functions
Export-ModuleMember -Function @(
    'Get-Text',
    'Set-TextResource',
    'Get-TextResources',
    'Import-TextResources',
    'Export-TextResources'
)



####\modules\theme-manager.psm1
#
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
# AI: This module has been refactored to wrap all public functions in Invoke-WithErrorHandling
#     for consistent, robust error logging and handling, adhering to the project's core principles.
#

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::White
            Primary = [ConsoleColor]::White; Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue; Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan; Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::Blue; String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta; Comment = [ConsoleColor]::DarkGray
        }
    }
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray; Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan; Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow; Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue; Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan; Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue; String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta; Comment = [ConsoleColor]::DarkGray
        }
    }
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White; Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black; Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue; Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray; Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow; Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue; String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta; Comment = [ConsoleColor]::Gray
        }
    }
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green; Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan; Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White; Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow; String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White; Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing the theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme for the application.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName
    )
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            
            # Defensively check if RawUI exists. In some environments (like the VS Code
            # Integrated Console), it can be $null and cause a crash.
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            
            # Publish theme change event if the event system is available.
            if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
            }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    # AI: This function is called frequently during render. The wrapper adds negligible overhead
    # but ensures any unexpected state corruption is handled gracefully.
    Invoke-WithErrorHandling -Component "ThemeManager.GetColor" -Context "Retrieving a theme color" -ScriptBlock {
        if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
            return $script:CurrentTheme.Colors[$ColorName]
        }
        return $Default
    } -Context @{ ColorName = $ColorName } -ErrorHandler {
        param($Exception)
        # Log the error but return the default to prevent a visual crash.
        Write-Log -Level Error -Message "Failed to get theme color '$($Exception.Context.ColorName)': $($Exception.Message)" -Data $Exception.Context
        return $Default
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme object.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving the current theme object" -ScriptBlock {
        return $script:CurrentTheme
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get current TUI Theme: $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets a list of all available theme names.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving all available theme names" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to get available themes: $($Exception.Message)" -Data $Exception.Context
        return @()
    }
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme in memory.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [string]$BaseTheme = "Modern",
        [hashtable]$Colors = @{}
    )
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating a new theme" -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        
        if ($script:Themes.ContainsKey($BaseTheme)) {
            $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone()
        }
        
        foreach ($colorKey in $Colors.Keys) {
            $newTheme.Colors[$colorKey] = $Colors[$colorKey]
        }
        
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    } -Context @{ ThemeName = $Name } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to create new TUI Theme '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to a JSON file.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting a theme to JSON" -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            
            foreach ($colorKey in $theme.Colors.Keys) {
                $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
            }
            
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    } -Context @{ ThemeName = $ThemeName; FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to export TUI Theme '$($Exception.Context.ThemeName)': $($Exception.Message)" -Data $Exception.Context
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from a JSON file.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing a theme from JSON" -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    } -Context @{ FilePath = $Path } -ErrorHandler {
        param($Exception)
        Write-Log -Level Error -Message "Failed to import TUI Theme from '$($Exception.Context.FilePath)': $($Exception.Message)" -Data $Exception.Context
        return $null
    }
}

Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)


####\modules\tui-engine-v2.psm1
# Rock-Solid TUI Engine v4.0 - Performance & Reliability Edition
# Implements all critical fixes from code review



#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = New-Object System.Collections.Stack
    CurrentScreen   = $null
    IsDirty         = $true
    LastActivity    = [DateTime]::Now
    LastRenderTime  = [DateTime]::MinValue
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TotalTime = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    DebugOverlayEnabled = $false
    FocusedComponent = $null
    
    # Thread-safe input queue and runspace management
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    
    # The correct, thread-safe object for signalling shutdown.
    CancellationTokenSource = $null
    
    # Event cleanup tracking
    EventHandlers = @{}
}

# Debug messages removed to prevent screen bleed-through
# Note: Width and Height params are only available inside Initialize-TuiEngine function



# Cell pool to avoid thousands of hashtable allocations
$script:CellPool = @{
    Pool = New-Object System.Collections.Queue
    MaxSize = 1000
}
#endregion

#region Cell Management & Object Pooling

function Get-PooledCell {
    param(
        [char]$Char = ' ',
        [ConsoleColor]$FG = [ConsoleColor]::White,
        [ConsoleColor]$BG = [ConsoleColor]::Black
    )
    
    if ($script:CellPool.Pool.Count -gt 0) {
        $cell = $script:CellPool.Pool.Dequeue()
        $cell.Char = $Char
        $cell.FG = $FG
        $cell.BG = $BG
        return $cell
    }
    
    # Create new cell if pool is empty
    return @{
        Char = $Char
        FG = $FG
        BG = $BG
    }
}

function Return-CellToPool {
    param($Cell)
    if ($script:CellPool.Pool.Count -lt $script:CellPool.MaxSize) {
        $script:CellPool.Pool.Enqueue($Cell)
    }
}

#endregion

#region Engine Lifecycle & Main Loop

function global:Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    # Patch: Always set defaults if not passed in
    if (-not $Width) { $Width = [Console]::WindowWidth }
    if (-not $Height) { $Height = [Console]::WindowHeight - 1 }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    }

   

    
    
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        
        # Create 2D arrays for buffers
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        # Initialize buffers with empty cells
        $emptyCell = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear() # Clear console to remove initialization messages
        
        # Initialize subsystems with error handling
        try { 
            Initialize-LayoutEngines 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Layout engines initialized"
            }
        } catch { 
            Write-Warning "Layout engines init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Layout engines init failed" -Data $_
            }
        }
        try { 
            Initialize-ComponentSystem 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Component system initialized"
            }
        } catch { 
            Write-Warning "Component system init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Component system init failed" -Data $_
            }
        }
        
        # Track event handlers for cleanup (event system should already be initialized)
        $script:TuiState.EventHandlers = @{}
        
        # --- THE FIX: HOOK CTRL+C *BEFORE* STARTING THE INPUT THREAD ---
        # Temporarily disabled due to compatibility issues
        # TODO: Re-enable with proper PowerShell event handling
        try {
            [Console]::TreatControlCAsInput = $false
            # Ctrl+C handler temporarily disabled - will terminate process normally
        } catch {
            Write-Warning "Could not set console input mode: $_"
        }
        
        # Now it is safe to start the input thread.
        Initialize-InputThread
        
        # Publish initialization event
        Safe-PublishEvent -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        
        # Export TuiState for global access
        $global:TuiState = $script:TuiState
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "TUI Engine initialized successfully"
        }
    }
    catch {
        # --- ENHANCED DIAGNOSTIC BLOCK ---
        # This will now clearly print the root cause of any initialization failure.
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        Write-Host "IMMEDIATE, ORIGINAL ERROR DETECTED DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "THE *REAL* PROBLEM IS LIKELY THIS:" -ForegroundColor Yellow
        
        if ($_) {
            Write-Host "MESSAGE: $($_.Exception.Message)" -ForegroundColor White
            
            Write-Host "FULL ERROR:" -ForegroundColor Yellow
            if ($_.Exception) {
                $_.Exception | Format-List * -Force
            } else {
                Write-Host "Error details: $_" -ForegroundColor White
            }
        } else {
            Write-Host "Unknown error occurred" -ForegroundColor White
        }
        
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        
        # Re-throw the exception so the main script's finally block is triggered for cleanup.
        throw "FATAL: TUI Engine initialization failed. See original error details above."
    }
}

function Initialize-InputThread {
    try {
        # Create thread-safe input handling
        $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
        $script:TuiState.InputQueue = New-Object $queueType
    } catch {
        Write-Warning "Failed to create ConcurrentQueue, falling back to ArrayList"
        $script:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
    }
    
    # Create the cancellation token source for thread-safe shutdown.
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    # Create runspace for input handling (fully-qualified .NET types)
    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    # Create a PowerShell instance in that runspace
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    # This script block will run in the background.
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    $keyInfo = [Console]::ReadKey($true)
                    
                    # Handle different queue types
                    if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Enqueue($keyInfo)
                        }
                    } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Add($keyInfo) | Out-Null
                        }
                    }
                }
                else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] {
            return
        }
        catch {
            Write-Warning "Input thread error: $_"
        }
    }) | Out-Null
    
    # Store for cleanup
    $script:TuiState.InputRunspace   = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    # Process all queued input events
    $processedAny = $false
    # Check if the queue exists before trying to use it.
    if (-not $script:TuiState.InputQueue) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Verbose -Message "Processing input queue"
    }

    $keyInfo = $null
    
    # Handle different queue types
    if ($script:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
        $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
        while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
            $processedAny = $true
            $script:TuiState.LastActivity = [DateTime]::Now
            try {
                Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key input" -ScriptBlock {
                    Process-SingleKeyInput -keyInfo $keyInfo
                } -AdditionalData @{ KeyInfo = $keyInfo }
            } catch {
                Write-Log -Level Error -Message "Error processing single key input: $($_.Exception.Message)" -Data $_
                Request-TuiRefresh
            }
        }
    } elseif ($script:TuiState.InputQueue -is [System.Collections.ArrayList]) {
        while ($script:TuiState.InputQueue.Count -gt 0) {
            try {
                $keyInfo = $script:TuiState.InputQueue[0]
                $script:TuiState.InputQueue.RemoveAt(0)
                $processedAny = $true
                $script:TuiState.LastActivity = [DateTime]::Now
                try {
                    Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key input" -ScriptBlock {
                        Process-SingleKeyInput -keyInfo $keyInfo
                    } -AdditionalData @{ KeyInfo = $keyInfo }
                } catch {
                    Write-Log -Level Error -Message "Error processing single key input: $($_.Exception.Message)" -Data $_
                    Request-TuiRefresh
                }
            } catch {
                break
            }
        }
    }
    
    return $processedAny
}

###```focus adddition 
function global:Set-ComponentFocus {
    param(
        [hashtable]$Component
    )
    
    $oldFocusedComponent = $script:TuiState.FocusedComponent
    
    if ($null -ne $oldFocusedComponent -and $oldFocusedComponent -ne $Component) {
        $oldFocusedComponent.IsFocused = $false
        if ($oldFocusedComponent.OnBlur) {
            try { & $oldFocusedComponent.OnBlur -self $oldFocusedComponent }
            catch { Write-Log -Level Warning -Message "OnBlur error: $_" }
        }
    }

    if ($null -eq $Component) {
        $script:TuiState.FocusedComponent = $null
        Request-TuiRefresh
        return
    }

    if ($Component.IsFocusable -ne $true -or $Component.Visible -ne $true) {
        return
    }

    $script:TuiState.FocusedComponent = $Component
    $Component.IsFocused = $true
    
    if ($Component.OnFocus) {
        try { & $Component.OnFocus -self $Component }
        catch { Write-Log -Level Warning -Message "OnFocus error: $_" }
    }
    
    Request-TuiRefresh
}

function global:Handle-TabNavigation {
    param(
        [bool]$Reverse = $false
    )
    
    $currentScreen = $script:TuiState.CurrentScreen
    if (-not $currentScreen) { return }

    $focusable = @()
    $FindFocusableIn = {
        param($component)
        if ($component -and $component.IsFocusable -eq $true -and $component.Visible -eq $true) {
            $script:focusable += $component
        }
        if ($component -and $component.Children) {
            foreach ($child in $component.Children) {
                & $script:FindFocusableIn -component $child
            }
        }
    }
    
    foreach ($compName in $currentScreen.Components.Keys) {
        & $FindFocusableIn -component $currentScreen.Components[$compName]
    }

    if ($focusable.Count -eq 0) { return }

    $sortedFocusable = $focusable | Sort-Object { $_.Y }, { $_.X }

    $currentIndex = [array]::IndexOf($sortedFocusable, $script:TuiState.FocusedComponent)
    
    $nextIndex = 0
    if ($currentIndex -ne -1) {
        $direction = if ($Reverse) { -1 } else { 1 }
        $nextIndex = ($currentIndex + $direction + $sortedFocusable.Count) % $sortedFocusable.Count
    }

    Set-ComponentFocus -Component $sortedFocusable[$nextIndex]
}

function global:Clear-ComponentFocus {
    Set-ComponentFocus -Component $null
}
###```

function Process-SingleKeyInput {
    param($keyInfo)
    
    try {
        # Tab navigation handled by focus manager if available
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            if (Get-Command -Name "Move-Focus" -ErrorAction SilentlyContinue) {
                Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            } else {
                # Fallback to old tab navigation
                Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            }
            return
        }
        
        # Dialog system gets first chance at input
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and (Handle-DialogInput -Key $keyInfo)) {
            return
        }
        
        # Get focused component from focus manager if available
        $focusedComponent = if (Get-Command -Name "Get-FocusedComponent" -ErrorAction SilentlyContinue) {
            Get-FocusedComponent
        } else {
            $script:TuiState.FocusedComponent
        }
        
        # Focused component gets the next chance
        if ($focusedComponent -and $focusedComponent.HandleInput) {
            try {
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) {
                    return
                }
            } catch {
                Write-Warning "Component input handler error: $_"
            }
        }
        
        # Finally, the screen itself gets the key
        $currentScreen = $script:TuiState.CurrentScreen
        if ($currentScreen -and $currentScreen.HandleInput) {
            try {
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { 
                        $script:TuiState.Running = $false
                        if ($script:TuiState.CancellationTokenSource) {
                            $script:TuiState.CancellationTokenSource.Cancel()
                        }
                    }
                }
            } catch {
                Write-Warning "Screen input handler error: $_"
            }
        }
    } catch {
        Write-Warning "Input processing error: $_"
    }
}

function global:Start-TuiLoop {
    param([hashtable]$InitialScreen = $null)

    try {
        # Only initialize if not already initialized
        if (-not $script:TuiState.BufferWidth -or $script:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }
        
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        
        # If no screen is active and no initial screen provided, we can't start
        if (-not $script:TuiState.CurrentScreen -and $script:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display. Push a screen before calling Start-TuiLoop or provide an InitialScreen parameter."
        }

        $script:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            # ==========================================================
            # === BEGIN CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
            try {
                $frameTime.Restart()

                # Process input
                $hadInput = Process-TuiInput
                
                # Update dialog system
                if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) { 
                    try { Update-DialogSystem } catch { Write-Log -Level Warning -Message "Dialog update error: $_" }
                }

                # Render if dirty or had input
                if ($script:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $script:TuiState.IsDirty = $false
                }
                
                # Adaptive frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }
            }
            catch [Helios.HeliosException] {
                # --- This block handles our custom, "recoverable" errors ---
                $exception = $_.Exception
                
                # 1. Log the rich, detailed error for developers
                Write-Log -Level Error -Message "A TUI Exception occurred: $($exception.Message)" -Data $exception.Context
                
                # 2. Show a simple, clean dialog to the user
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($exception.Message)"
                
                # 3. Force a full re-render to clean up any UI artifacts from the failed operation
                $script:TuiState.IsDirty = $true
            }
            catch {
                # --- This block handles unexpected, potentially fatal errors ---
                $exception = $_.Exception
                
                # 1. Log the catastrophic failure
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($exception.Message)" -Data $_
                
                # 2. Inform the user and prepare for shutdown
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                
                # 3. Stop the main loop to exit gracefully
                $script:TuiState.Running = $false
            }
            # ==========================================================
            # === END CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
        }
    }
    finally {
        Cleanup-TuiEngine
    }
}

# ==============================================================================
# === CRITICAL FIX: NEW RENDER-FRAME IMPLEMENTATION ============================
# ==============================================================================
function Render-Frame {
    try {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Verbose -Message "Starting Z-Index frame render"
        }
        
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }
        
        # Always clear the back buffer completely
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # 1. RENDER SCREEN CHROME (Header, Footer, etc.)
        # This is for elements NOT in the component tree. The screen's Render method
        # should ONLY draw these non-component elements.
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Render) {
            try {
            Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).Render" -Context "Rendering screen chrome" -ScriptBlock {
            & $script:TuiState.CurrentScreen.Render -self $script:TuiState.CurrentScreen
            } -AdditionalData @{ ScreenName = $script:TuiState.CurrentScreen.Name }
            } catch {
                Write-Log -Level Error -Message "Screen-level render error: $($_.Exception.Message)" -Data $_
            }
        }

        # 2. COLLECT all visible components from the screen's Children and any active dialogs.
        $renderQueue = [System.Collections.Generic.List[hashtable]]::new()
        
        # Debug: Log screen state
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Render-Frame: CurrentScreen=$($script:TuiState.CurrentScreen.Name), Children count=$($script:TuiState.CurrentScreen.Children.Count)"
        }
        
        # Define collectComponents as a scriptblock variable that can reference itself
        $script:collectComponents = {
            param($component)
            if (-not $component -or $component.Visible -eq $false) { return }
            
            # Add the component itself to the queue
            $renderQueue.Add($component)
            
            # Debug logging
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Collected component: Type=$($component.Type), Name=$($component.Name), Pos=($($component.X),$($component.Y)), ZIndex=$($component.ZIndex), Children=$($component.Children.Count)"
            }
            
            # Process children if any
            if ($component.Children -and $component.Children.Count -gt 0) {
                # A panel must calculate its children's layout before they are collected
                if ($component.CalculateLayout) {
    		  try { 
        		[void](& $component.CalculateLayout -self $component) # FIX: Suppress output
   		  }
    		  catch { 
        		Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" -Data $_ 
    		  }
	    }
                
                # Recursively collect each child
                foreach ($child in $component.Children) {
                    & $script:collectComponents $child
                }
            }
        }

        # Start collection from the screen's children
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Children) {
            foreach ($child in $script:TuiState.CurrentScreen.Children) {
                & $script:collectComponents -component $child
            }
        }

        # Collect from the current dialog (which is a self-contained component tree)
        if ((Get-Command -Name "Get-CurrentDialog" -ErrorAction SilentlyContinue)) {
            $currentDialog = Get-CurrentDialog
            if ($currentDialog) {
                & $script:collectComponents -component $currentDialog
            }
        }
        
        # 3. SORT the render queue by ZIndex
        $sortedQueue = $renderQueue | Sort-Object -Property ZIndex
        
        # 4. DRAW the sorted components
        foreach ($componentToRender in $sortedQueue) {
            if ($componentToRender.Render) {
                try {
                    Invoke-WithErrorHandling -Component "$($componentToRender.Name ?? $componentToRender.Type).Render" -Context "Rendering component" -ScriptBlock {
                        & $componentToRender.Render -self $componentToRender
                    } -AdditionalData @{ ComponentType = $componentToRender.Type; ComponentName = $componentToRender.Name }
                } catch {
                    Write-Log -Level Error -Message "Failed to render component '$($componentToRender.Name ?? $componentToRender.Type)': $($_.Exception.Message)" -Data $_
                    # Continue rendering other components
                }
            }
        }
        
        # 5. FINALIZE the frame
        Render-BufferOptimized
        
        # Force cursor to bottom-right to avoid interference
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
        
    } catch {
        Write-Warning "Fatal Frame render error: $_"
    }
}

function global:Request-TuiRefresh {
    $script:TuiState.IsDirty = $true
}

function Cleanup-TuiEngine {
    try {
        # --- ROBUST CLEANUP ROUTINE ---
        # This sequence is defensive and will not fail even if initialization was partial.
        if ($script:TuiState.CancellationTokenSource) {
            try {
                if (-not $script:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $script:TuiState.CancellationTokenSource.Cancel()
                }
            } catch { 
                # Ignore errors if CancellationTokenSource is in an invalid state
            }
        }

        if ($script:TuiState.InputPowerShell) {
            if ($script:TuiState.InputAsyncResult) {
                try { $script:TuiState.InputPowerShell.EndInvoke($script:TuiState.InputAsyncResult) } catch { }
            }
            try { $script:TuiState.InputPowerShell.Dispose() } catch { }
        }
        
        if ($script:TuiState.InputRunspace) {
            try { $script:TuiState.InputRunspace.Dispose() } catch { }
        }
        
        if ($script:TuiState.CancellationTokenSource) {
            try { $script:TuiState.CancellationTokenSource.Dispose() } catch { }
        }

        # Clean up background jobs
        if (Get-Command -Name "Stop-AllTuiAsyncJobs" -ErrorAction SilentlyContinue) {
            try { Stop-AllTuiAsyncJobs } catch { }
        }

        Cleanup-EventHandlers
        
        # Only try to reset the console if we are in an interactive session
        if (-not $env:CI -and -not $PSScriptRoot) {
            try {
                if ([System.Environment]::UserInteractive) {
                    [Console]::Write("$([char]27)[0m")
                    [Console]::CursorVisible = $true
                    [Console]::Clear()
                    [Console]::ResetColor()
                }
            } catch {
                # This can fail in non-interactive environments, ignore the error.
            }
        }
    } catch {
        Write-Warning "A secondary error occurred during TUI cleanup: $_"
    }
}

function Cleanup-EventHandlers {
    if (-not (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) { return }
    if (-not $script:TuiState.EventHandlers) { return }

    foreach ($handlerId in $script:TuiState.EventHandlers.Values) {
        try { Unsubscribe-Event -HandlerId $handlerId } catch { }
    }
    $script:TuiState.EventHandlers.Clear()
    
    # Clean up any orphaned Ctrl+C event handler if it exists
    try {
        Get-EventSubscriber -SourceIdentifier "TuiCtrlC" -ErrorAction SilentlyContinue | Unregister-Event
    } catch { }
}

function Safe-PublishEvent {
    param($EventName, $Data)
    if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
        try { Publish-Event -EventName $EventName -Data $Data } catch { }
    }
}

#endregion

#region Screen Management

function global:Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                # This is less critical, so a log is acceptable, but we can be more specific.
                Write-Log -Level Warning -Message "Error in OnBlur for component '$($script:TuiState.FocusedComponent.Name)'" -Data $_
            }
        }
        
        if ($script:TuiState.CurrentScreen) {
            if ($script:TuiState.CurrentScreen.OnExit) { 
                try {
                    Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnExit" -Context "Screen exit" -ScriptBlock {
                        & $script:TuiState.CurrentScreen.OnExit -self $script:TuiState.CurrentScreen
                    } -AdditionalData @{ ScreenName = $script:TuiState.CurrentScreen.Name }
                } catch {
                    Write-Warning "Screen exit error: $($_.Exception.Message)"
                }
            }
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        if ($Screen.Init) { 
            try {
                Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock {
                    # AI: Ensure services are passed to screen init
                    # Check for services in multiple locations
                    $services = $null
                    if ($Screen._services) {
                        $services = $Screen._services
                    } elseif ($global:Services) {
                        $services = $global:Services
                    }
                    
                    if ($services) {
                        & $Screen.Init -self $Screen -services $services
                    } else {
                        & $Screen.Init -self $Screen
                    }
                } -AdditionalData @{ ScreenName = $Screen.Name }
            } catch {
                throw "Failed to initialize screen '$($Screen.Name)': $($_.Exception.Message)"
            }
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
        
    } catch {
        Write-Warning "Push screen error: $_"
    }
}

function global:Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Popping screen"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        # Store the screen to exit before changing CurrentScreen
        $screenToExit = $script:TuiState.CurrentScreen
        
        # Pop the new screen from the stack
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        # Call lifecycle hooks in correct order
        if ($screenToExit -and $screenToExit.OnExit) { 
            try {
                Invoke-WithErrorHandling -Component "$($screenToExit.Name).OnExit" -Context "Screen exit" -ScriptBlock {
                    & $screenToExit.OnExit -self $screenToExit
                } -AdditionalData @{ ScreenName = $screenToExit.Name }
            } catch {
                Write-Warning "Screen exit error: $($_.Exception.Message)"
            }
        }
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.OnResume) { 
            try {
                Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnResume" -Context "Screen resume" -ScriptBlock {
                    & $script:TuiState.CurrentScreen.OnResume -self $script:TuiState.CurrentScreen
                } -AdditionalData @{ ScreenName = $script:TuiState.CurrentScreen.Name }
            } catch {
                Write-Warning "Screen resume error: $($_.Exception.Message)"
            }
        }
        
        # Restore focus if the screen tracks it
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        
        return $true
        
    } catch {
        Write-Warning "Pop screen error: $_"
        return $false
    }
}

#endregion

#region Buffer and Rendering

# GetBufferIndex no longer needed - using 2D arrays directly

function global:Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Create a new cell for each position to ensure proper clearing
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function global:Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $script:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Pragmatic check for CJK/wide characters. A full implementation is library-dependent.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            # Also fill the next cell with a space for wide characters to prevent overlap
            if ($currentX -lt $script:TuiState.BufferWidth -and $currentX -gt 0) {
                $script:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function global:Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Top border
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title
    if ($Title) {
        $titleText = " $Title "
        if ($titleText.Length -gt ($Width - 2)) {
            # FIX: Ensure the length for Substring is never negative.
            $maxLength = [Math]::Max(0, $Width - 5)
            $titleText = " $($Title.Substring(0, $maxLength))... "
        }
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
       Write-BufferString -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and Fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function global:Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    # Force full render on first frame or if requested
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    
    try {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            # Position cursor at start of line
            $outputBuilder.Append("$([char]27)[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]
                $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                
                # Skip if cell hasn't changed (unless forcing full render)
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("$([char]27)[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("$([char]27)[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                # Append character
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $script:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting at the end
        $outputBuilder.Append("$([char]27)[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Warning "Render error: $_"
    }
    
    # Update stats
    $stopwatch.Stop()
    $script:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $script:TuiState.RenderStats.FrameCount++
    $script:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Component System

function Initialize-ComponentSystem {
    $script:TuiState.Components = @()
    $script:TuiState.FocusedComponent = $null
}

function global:Register-Component {
    param([hashtable]$Component)
    
    # Add to component registry
    $script:TuiState.Components += $Component
    
    # Initialize component with error handling
    if ($Component.Init) {
        try {
            Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).Init" -Context "Component initialization" -ScriptBlock {
                & $Component.Init -self $Component
            } -AdditionalData @{ ComponentType = $Component.Type; ComponentName = $Component.Name }
        } catch {
            Write-Warning "Component init error: $($_.Exception.Message)"
        }
    }
    
    return $Component
}

function global:Set-ComponentFocus {
    param([hashtable]$Component)
    
    # Don't focus disabled components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) {
        return
    }
    
    # Blur previous component with error handling
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -Context "Component blur" -ScriptBlock {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } -AdditionalData @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name }
        } catch {
            Write-Warning "Component blur error: $($_.Exception.Message)"
        }
    }
    
    # Track focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $Component
    }
    
    # Focus new component with error handling
    $script:TuiState.FocusedComponent = $Component
    if ($Component -and $Component.OnFocus) {
        try {
            Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).OnFocus" -Context "Component focus" -ScriptBlock {
                & $Component.OnFocus -self $Component
            } -AdditionalData @{ ComponentType = $Component.Type; ComponentName = $Component.Name }
        } catch {
            Write-Warning "Component focus error: $($_.Exception.Message)"
        }
    }
    
    Request-TuiRefresh
}

function global:Clear-ComponentFocus {
    <#
    .SYNOPSIS
    Clears focus from the current component
    #>
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -Context "Component blur" -ScriptBlock {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } -AdditionalData @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name }
        } catch {
            Write-Warning "Component blur error: $($_.Exception.Message)"
        }
    }
    
    $script:TuiState.FocusedComponent = $null
    
    # Clear tracked focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $null
    }
    
    Request-TuiRefresh
}

function global:Get-NextFocusableComponent {
    <#
    .SYNOPSIS
    Gets the next focusable component in tab order
    #>
    param(
        [hashtable]$CurrentComponent,
        [bool]$Reverse = $false
    )
    
    if (-not $script:TuiState.CurrentScreen) { return $null }
    
    # Get all focusable components
    $focusableComponents = @()
    
    # Recursive function to find focusable components
    function Find-FocusableComponents {
        param($Component)
        
        # Check using the correct properties that our components actually have
        if ($Component.IsFocusable -eq $true -and 
            $Component.Visible -ne $false) {
            $focusableComponents += $Component
        }
        
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                Find-FocusableComponents -Component $child
            }
        }
    }
    
    # Start from screen components
    if ($script:TuiState.CurrentScreen.Components) {
        if ($script:TuiState.CurrentScreen.Components -is [hashtable]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components.Values) {
                Find-FocusableComponents -Component $comp
            }
        } elseif ($script:TuiState.CurrentScreen.Components -is [array]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components) {
                Find-FocusableComponents -Component $comp
            }
        }
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by TabIndex or position
    $sorted = $focusableComponents | Sort-Object {
        if ($null -ne $_.TabIndex) { $_.TabIndex }
        else { $_.Y * 1000 + $_.X }
    }
    
    if ($Reverse) {
        [Array]::Reverse($sorted)
    }
    
    # Find current index
    $currentIndex = -1
    for ($i = 0; $i -lt $sorted.Count; $i++) {
        if ($sorted[$i] -eq $CurrentComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Get next component
    if ($currentIndex -ge 0) {
        $nextIndex = ($currentIndex + 1) % $sorted.Count
        return $sorted[$nextIndex]
    } else {
        return $sorted[0]
    }
}

function global:Handle-TabNavigation {
    <#
    .SYNOPSIS
    Handles Tab key navigation between components  
    #>
    param([bool]$Reverse = $false)
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Handle-TabNavigation called, Reverse=$Reverse"
    }
    
    $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Setting focus to component: Type=$($next.Type), Name=$($next.Name)"
        }
        Set-ComponentFocus -Component $next
    }
}

function global:New-Component {
    param(
        [string]$Type = "Base",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 1,
        [hashtable]$Props = @{}
    )
    
    $component = @{
        Type = $Type
        X = $X
        Y = $Y
        Width = $Width
        Height = $Height
        Visible = $true
        Focused = $false
        Parent = $null
        Children = @()
        Props = $Props
        State = @{}
        
        # Lifecycle methods
        Init = { param($self) }
        Render = { param($self) }
        HandleInput = { param($self, $Key) return $false }
        OnFocus = { param($self) $self.Focused = $true }
        OnBlur = { param($self) $self.Focused = $false }
        Dispose = { param($self) }
    }
    
    # Merge with type-specific properties
    switch ($Type) {
        "TextInput" { $component = Merge-Hashtables $component (Get-TextInputComponent) }
        "Button" { $component = Merge-Hashtables $component (Get-ButtonComponent) }
        "List" { $component = Merge-Hashtables $component (Get-ListComponent) }
        "Table" { $component = Merge-Hashtables $component (Get-TableComponent) }
    }
    
    return $component
}

function Merge-Hashtables {
    param($Base, $Override)
    $result = $Base.Clone()
    foreach ($key in $Override.Keys) {
        $result[$key] = $Override[$key]
    }
    return $result
}

#endregion

#region Layout Management

function Initialize-LayoutEngines {
    $script:TuiState.Layouts = @{
        Grid = Get-GridLayout
        Stack = Get-StackLayout
        Dock = Get-DockLayout
    }
}

function global:Apply-Layout {
    param(
        [string]$LayoutType,
        [hashtable[]]$Components,
        [hashtable]$Options = @{}
    )
    
    if ($script:TuiState.Layouts.ContainsKey($LayoutType)) {
        $layout = $script:TuiState.Layouts[$LayoutType]
        try {
            Invoke-WithErrorHandling -Component "Layout.$LayoutType" -Context "Applying layout" -ScriptBlock {
                & $layout.Apply -Components $Components -Options $Options
            } -AdditionalData @{ LayoutType = $LayoutType; Options = $Options }
        } catch {
            Write-Warning "Layout error: $($_.Exception.Message)"
        }
    }
}

function Get-GridLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $cols = if ($Options.Columns) { $Options.Columns } else { 2 }
            $rows = [Math]::Ceiling($Components.Count / $cols)
            $cellWidth = [Math]::Floor($script:TuiState.BufferWidth / $cols)
            $cellHeight = [Math]::Floor($script:TuiState.BufferHeight / $rows)
            
            for ($i = 0; $i -lt $Components.Count; $i++) {
                $col = $i % $cols
                $row = [Math]::Floor($i / $cols)
                $Components[$i].X = $col * $cellWidth
                $Components[$i].Y = $row * $cellHeight
                $Components[$i].Width = $cellWidth - 1
                $Components[$i].Height = $cellHeight - 1
            }
        }
    }
}

function Get-StackLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $orientation = if ($Options.Orientation) { $Options.Orientation } else { "Vertical" }
            $spacing = if ($null -ne $Options.Spacing) { $Options.Spacing } else { 1 }
            $x = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $y = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            
            foreach ($component in $Components) {
                $component.X = $x
                $component.Y = $y
                
                if ($orientation -eq "Vertical") {
                    $y += $component.Height + $spacing
                } else {
                    $x += $component.Width + $spacing
                }
            }
        }
    }
}

function Get-DockLayout {
    return @{
        Apply = {
            param($Components, $Options)
            
            # Container bounds
            $containerX = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $containerY = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            $containerWidth = if ($Options.Width) { $Options.Width } else { $script:TuiState.BufferWidth }
            $containerHeight = if ($Options.Height) { $Options.Height } else { $script:TuiState.BufferHeight }
            
            # Current available area
            $availableX = $containerX
            $availableY = $containerY
            $availableWidth = $containerWidth
            $availableHeight = $containerHeight
            
            # Process components by dock position
            $topComponents = $Components | Where-Object { $_.Props.Dock -eq "Top" }
            $bottomComponents = $Components | Where-Object { $_.Props.Dock -eq "Bottom" }
            $leftComponents = $Components | Where-Object { $_.Props.Dock -eq "Left" }
            $rightComponents = $Components | Where-Object { $_.Props.Dock -eq "Right" }
            $fillComponents = $Components | Where-Object { $_.Props.Dock -eq "Fill" -or -not $_.Props.Dock }
            
            # Dock top components
            foreach ($comp in $topComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $availableY += $comp.Height
                $availableHeight -= $comp.Height
            }
            
            # Dock bottom components
            foreach ($comp in $bottomComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY + $availableHeight - $comp.Height
                $comp.Width = $availableWidth
                $availableHeight -= $comp.Height
            }
            
            # Dock left components
            foreach ($comp in $leftComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableX += $comp.Width
                $availableWidth -= $comp.Width
            }
            
            # Dock right components
            foreach ($comp in $rightComponents) {
                $comp.X = $availableX + $availableWidth - $comp.Width
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableWidth -= $comp.Width
            }
            
            # Fill remaining space
            foreach ($comp in $fillComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $comp.Height = $availableHeight
            }
        }
    }
}

#endregion

#region Utility Functions

function global:Get-BorderChars { 
    param([string]$Style) 
    $styles = @{ 
        Single = @{ 
            TopLeft='‚îå'; TopRight='‚îê'; BottomLeft='‚îî'; BottomRight='‚îò'
            Horizontal='‚îÄ'; Vertical='‚îÇ' 
        }
        Double = @{ 
            TopLeft='‚ïî'; TopRight='‚ïó'; BottomLeft='‚ïö'; BottomRight='‚ïù'
            Horizontal='‚ïê'; Vertical='‚ïë' 
        }
        Rounded = @{ 
            TopLeft='‚ï≠'; TopRight='‚ïÆ'; BottomLeft='‚ï∞'; BottomRight='‚ïØ'
            Horizontal='‚îÄ'; Vertical='‚îÇ' 
        } 
    }
    if ($styles.ContainsKey($Style)) { 
        return $styles[$Style] 
    } else { 
        return $styles.Single 
    }
}

function Get-AnsiColorCode { 
    param([ConsoleColor]$Color, [bool]$IsBackground) 
    $map = @{ 
        Black=30; DarkBlue=34; DarkGreen=32; DarkCyan=36
        DarkRed=31; DarkMagenta=35; DarkYellow=33; Gray=37
        DarkGray=90; Blue=94; Green=92; Cyan=96
        Red=91; Magenta=95; Yellow=93; White=97 
    }
    $code = $map[$Color.ToString()]
    if ($IsBackground) { 
        return $code + 10 
    } else { 
        return $code 
    } 
}

function Get-ThemeColorFallback {
    param($ColorName, $Default = [ConsoleColor]::White)
    # This is a fallback function for when theme manager isn't available
    # The theme manager will override this with its own global Get-ThemeColor
    return $Default
}

# Only define global Get-ThemeColor if it doesn't already exist
if (-not (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue)) {
    function global:Get-ThemeColor {
        param($ColorName, $Default = [ConsoleColor]::White)
        return Get-ThemeColorFallback -ColorName $ColorName -Default $Default
    }
}

function global:Write-StatusLine { 
    param(
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = 'White', 
        [ConsoleColor]$BackgroundColor = 'DarkBlue'
    ) 
    try { 
        $y = $script:TuiState.BufferHeight
        [Console]::SetCursorPosition(0, $y)
        [Console]::ForegroundColor = $ForegroundColor
        [Console]::BackgroundColor = $BackgroundColor
        [Console]::Write($Text.PadRight([Console]::WindowWidth))
        [Console]::ResetColor() 
    } catch {
        Write-Warning "Status line error: $_"
    } 
}

function global:Subscribe-TuiEvent {
    param($EventName, $Handler)
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        $handlerId = Subscribe-Event -EventName $EventName -Handler $Handler
        # Track for cleanup
        $script:TuiState.EventHandlers[$EventName] = $handlerId
        return $handlerId
    }
}

#endregion

#region Component Definitions

function Get-TextInputComponent {
    return @{
        # State
        Value = ""
        CursorPosition = 0
        MaxLength = 50
        
        # Methods
        Render = {
            param($self)
            try {
                $borderColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Draw input box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    Write-BufferString -X ($self.X - 1) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    # Right bracket
                    Write-BufferString -X ($self.X + $self.Width) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                }
                
                # Draw text
                $displayText = $self.Value
                if ($displayText.Length > ($self.Width - 3)) {
                    $displayText = $displayText.Substring($displayText.Length - ($self.Width - 3))
                }
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text $displayText
                
                # Draw cursor if focused
                if ($self.Focused -and $self.CursorPosition -lt ($self.Width - 3)) {
                    Write-BufferString -X ($self.X + 1 + $self.CursorPosition) -Y ($self.Y + 1) `
                        -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
                }
            } catch {
                Write-Warning "TextInput render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) {
                        if ($self.Value.Length -gt 0 -and $self.CursorPosition -gt 0) {
                            $self.Value = $self.Value.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.Value = $self.Value.Remove($self.CursorPosition, 1)
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.CursorPosition++
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.Value.Length
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and 
                            $self.Value.Length -lt $self.MaxLength) {
                            $self.Value = $self.Value.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            return $true
                        }
                    }
                }
            } catch {
                Write-Warning "TextInput input error: $_"
            }
            return $false
        }
    }
}

function Get-ButtonComponent {
    return @{
        # State
        Text = "Button"
        
        # Methods
        Render = {
            param($self)
            try {
                $bgColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::DarkCyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::DarkGray)
                }
                
                $text = " $($self.Text) "
                if ($text.Length > $self.Width) {
                    $text = $text.Substring(0, $self.Width)
                }
                
                $x = $self.X + [Math]::Floor(($self.Width - $text.Length) / 2)
                Write-BufferString -X $x -Y $self.Y -Text $text `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor $bgColor
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    if ($x -gt 0) {
                        Write-BufferString -X ($x - 1) -Y $self.Y `
                            -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                    # Right bracket
                    if (($x + $text.Length) -lt $script:TuiState.BufferWidth) {
                        Write-BufferString -X ($x + $text.Length) -Y $self.Y `
                            -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                }
            } catch {
                Write-Warning "Button render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                    if ($self.OnClick) {
                        & $self.OnClick -self $self
                    }
                    return $true
                }
            } catch {
                Write-Warning "Button input error: $_"
            }
            return $false
        }
    }
}

function Get-TableComponent {
    return @{
        # State
        Data = @()
        Columns = @()
        SelectedRow = 0
        ScrollOffset = 0
        
        # Methods
        Render = {
            param($self)
            try {
                # Simplified table rendering
                $y = $self.Y
                
                # Header
                $headerText = ""
                foreach ($col in $self.Columns) {
                    $headerText += $col.Name.PadRight($col.Width)
                }
                Write-BufferString -X $self.X -Y $y -Text $headerText `
                    -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                $y++
                
                # Data rows
                $visibleRows = $self.Data | Select-Object -Skip $self.ScrollOffset -First ($self.Height - 1)
                $rowIndex = $self.ScrollOffset
                foreach ($row in $visibleRows) {
                    $rowText = ""
                    foreach ($col in $self.Columns) {
                        $value = if ($row.($col.Property)) { $row.($col.Property) } else { "" }
                        $rowText += $value.ToString().PadRight($col.Width)
                    }
                    
                    $fg = if ($rowIndex -eq $self.SelectedRow) {
                        Get-ThemeColor "Selection" -Default ([ConsoleColor]::Yellow)
                    } else {
                        Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                    }
                    
                    Write-BufferString -X $self.X -Y $y -Text $rowText -ForegroundColor $fg
                    $y++
                    $rowIndex++
                }
            } catch {
                Write-Warning "Table render error: $_"
            }
        }
    }
}

#endregion

#region Word Wrap Helper
function global:Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    $words = $Text -split '\s+'
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}
#endregion

function global:Stop-TuiEngine {
    <#
    .SYNOPSIS
    Stops the TUI engine and exits the application gracefully
    #>
    param()
    
    Write-Log -Level Info -Message "Stop-TuiEngine called - shutting down application" -Data @{ Component = "TuiEngine" }
    
    # Set the running flag to false to exit the main loop
    $script:TuiState.Running = $false
    
    # Cancel the input thread if available
    if ($script:TuiState.CancellationTokenSource) {
        try {
            $script:TuiState.CancellationTokenSource.Cancel()
        }
        catch {
            Write-Warning "Failed to cancel input thread: $_"
        }
    }
    
    # Publish shutdown event
    Safe-PublishEvent -EventName "System.Shutdown" -Data @{ Reason = "User requested" }
}

# Build export list dynamically
$exportFunctions = @(
    'Start-TuiLoop', 'Request-TuiRefresh', 'Push-Screen', 'Pop-Screen',
    'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer',
    'Write-StatusLine', 'Get-BorderChars',
    'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 
    'Get-NextFocusableComponent', 'Handle-TabNavigation', 
    'New-Component', 'Apply-Layout',
    'Get-WordWrappedLines', 'Subscribe-TuiEvent',
    'Render-Frame', 'Initialize-TuiEngine', 'Stop-TuiEngine'
)

# Only export Get-ThemeColor if we defined it
if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue | Where-Object { $_.Source -eq "tui-engine-v2" }) {
    $exportFunctions += 'Get-ThemeColor'
}

Export-ModuleMember -Function $exportFunctions -Variable @('TuiState')


####\modules\tui-framework.psm1
# TUI Framework Integration Module - FIXED VERSION
# Contains fixed utility functions with resolved parameter binding issues.

$script:TuiAsyncJobs = @()

function global:Invoke-TuiMethod {
    <#
    .SYNOPSIS
    Safely invokes a method on a TUI component.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Component,

        [Parameter(Mandatory = $true)]
        [string]$MethodName,

        [Parameter()]
        [hashtable]$Arguments = @{}
    )

    # AI: Defensive check for null component to prevent errors.
    if ($null -eq $Component) { return }
    
    # AI: Check if the method key exists and is a scriptblock before attempting invocation.
    # This prevents "The term '...' is not recognized" errors for optional methods.
    if (-not $Component.ContainsKey($MethodName)) { return }
    $method = $Component[$MethodName]
    if ($null -eq $method -or $method -isnot [scriptblock]) {
        return
    }

    # Add the component itself as the 'self' parameter for convenience within the method.
    $Arguments['self'] = $Component

    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock {
        # Use splatting with the @ operator for robust parameter passing.
        & $method @Arguments
    } -AdditionalData @{ Component = $Component.Name; Method = $MethodName } -ErrorHandler {
        param($Exception)
        # Log the error but do not re-throw, allowing the UI to remain responsive.
        Write-Log -Level Error -Message "Error invoking method '$($Exception.Context.Method)' on component '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        Request-TuiRefresh
    }
}

function global:Initialize-TuiFramework {
    <#
    .SYNOPSIS
    Initializes the TUI framework.
    #>
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        # Ensure engine is initialized before the framework.
        if (-not $global:TuiState) {
            throw "TUI Engine must be initialized before the TUI Framework."
        }
        Write-Log -Level Info -Message "TUI Framework initialized." -Data @{ Component = "TuiFramework.Initialize" }
    }
}

function global:Invoke-TuiAsync {
    <#
    .SYNOPSIS
    Executes a script block asynchronously with proper job management.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        
        [Parameter()]
        [hashtable]$ArgumentList = @{}
    )
    
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        # Start the job
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        
        # Track the job
        $script:TuiAsyncJobs += $job
        
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ 
            Component = "TuiFramework.Async"; 
            JobId = $job.Id; 
            JobName = $JobName 
        }
        
        return $job
    }
}

function global:Get-TuiAsyncResults {
    <#
    .SYNOPSIS
    Checks for completed async jobs and returns their results.
    #>
    param(
        [Parameter()]
        [switch]$RemoveCompleted = $true
    )
    
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = @()
        
        foreach ($job in $script:TuiAsyncJobs) {
            if ($job.State -in @('Completed', 'Failed', 'Stopped')) {
                $result = @{
                    JobId = $job.Id
                    JobName = $job.Name
                    State = $job.State
                    Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                    Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
                }
                
                $results += $result
                $completedJobs += $job
                
                Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ 
                    Component = "TuiFramework.AsyncResults"; 
                    JobId = $job.Id; 
                    State = $job.State 
                }
            }
        }
        
        # Remove completed jobs if requested
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        
        return $results
    }
}

function global:Stop-AllTuiAsyncJobs {
    <#
    .SYNOPSIS
    Stops and removes all running TUI async jobs.
    #>
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)" -Data @{ 
                    Component = "TuiFramework.StopAsync"; 
                    JobId = $job.Id 
                }
            }
            catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_" -Data @{ 
                    Component = "TuiFramework.StopAsync"; 
                    JobId = $job.Id; 
                    Error = $_.Exception.Message 
                }
            }
        }
        
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped" -Data @{ Component = "TuiFramework.StopAsync" }
    }
}

function global:Request-TuiRefresh {
    <#
    .SYNOPSIS
    Requests a UI refresh to update the display.
    #>
    if ($global:TuiState -and $global:TuiState.RequestRefresh) {
        & $global:TuiState.RequestRefresh
    }
    else {
        # Publish event as fallback
        Publish-Event -EventName "TUI.RefreshRequested" -Data @{ Timestamp = Get-Date }
    }
}

function global:Get-TuiState {
    <#
    .SYNOPSIS
    Gets the current TUI state object.
    #>
    return $global:TuiState
}

# AI: Helper function to safely validate TUI state
function global:Test-TuiState {
    <#
    .SYNOPSIS
    Validates that the TUI state is properly initialized.
    #>
    param(
        [Parameter()]
        [switch]$ThrowOnError
    )
    
    $isValid = $null -ne $global:TuiState -and 
               $null -ne $global:TuiState.IsRunning -and
               $null -ne $global:TuiState.CurrentScreen
    
    if (-not $isValid -and $ThrowOnError) {
        throw "TUI state is not properly initialized. Call Initialize-TuiEngine first."
    }
    
    return $isValid
}

# Export public functions
Export-ModuleMember -Function @(
    'Invoke-TuiMethod',
    'Initialize-TuiFramework', 
    'Invoke-TuiAsync',
    'Get-TuiAsyncResults',
    'Stop-AllTuiAsyncJobs',
    'Request-TuiRefresh',
    'Get-TuiState',
    'Test-TuiState'
)


####\screens\dashboard\dashboard-screen-class.psm1
# Dashboard Screen Class Implementation
# Fixes Context parameter binding issues and initialization problems

using namespace System.Collections.Generic

# Import base classes
using module ..\..\components\ui-classes.psm1
using module ..\..\components\panel-classes.psm1

# Import utilities
Import-Module "$PSScriptRoot\..\..\utilities\error-handling.psm1" -Force
Import-Module "$PSScriptRoot\..\..\utilities\event-system.psm1" -Force

class DashboardScreen : Screen {
    # UI Components
    [BorderPanel] $MainPanel
    [ContentPanel] $SummaryPanel
    [ContentPanel] $TaskPanel
    [BorderPanel] $NavigationPanel
    
    # State
    [object[]] $Tasks = @()
    [int] $SelectedTaskIndex = 0
    
    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) {
        Write-Log -Level Info -Message "Creating DashboardScreen instance"
    }
    
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            Write-Log -Level Info -Message "Initializing DashboardScreen"
            
            # Create main container panel
            $this.MainPanel = [BorderPanel]::new("DashboardMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "PMC Terminal v5 - Dashboard"
            $this.MainPanel.BorderStyle = "Double"
            $this.AddPanel($this.MainPanel)
            
            # Create summary panel (left side)
            $this.SummaryPanel = [ContentPanel]::new("DashboardSummary", 2, 2, 40, 10)
            $this.MainPanel.AddChild($this.SummaryPanel)
            
            # Create task panel (right side)
            $this.TaskPanel = [ContentPanel]::new("DashboardTasks", 44, 2, 74, 20)
            $this.MainPanel.AddChild($this.TaskPanel)
            
            # Create navigation panel (bottom)
            $this.NavigationPanel = [BorderPanel]::new("DashboardNav", 2, 23, 116, 6)
            $this.NavigationPanel.Title = "Navigation"
            $this.NavigationPanel.BorderStyle = "Single"
            $this.MainPanel.AddChild($this.NavigationPanel)
            
            # Initialize navigation content
            $this.InitializeNavigation()
            
            # Subscribe to events
            $this.SubscribeToEvents()
            
            # Load initial data
            $this.RefreshData()
            
            # Mark as initialized
            $this.IsInitialized = $true
            Write-Log -Level Info -Message "DashboardScreen initialized successfully"
        }
    }
    
    hidden [void] InitializeNavigation() {
        $navContent = @(
            "[N] New Task    [E] Edit Task    [D] Delete Task    [Space] Toggle Complete",
            "[P] Projects    [T] Tags         [F] Filter        [S] Settings",
            "[‚Üë‚Üì] Navigate   [Enter] Select   [Esc] Back        [Q] Quit"
        )
        
        $navPanel = [ContentPanel]::new("NavContent", 3, 24, 114, 4)
        $navPanel.SetContent($navContent)
        $this.NavigationPanel.AddChild($navPanel)
    }
    
    hidden [void] SubscribeToEvents() {
        # Subscribe to task changes
        $this.SubscribeToEvent("Tasks.Changed", {
            param($eventArgs)
            $this.RefreshData()
        })
        
        # Subscribe to project changes
        $this.SubscribeToEvent("Projects.Changed", {
            param($eventArgs)
            $this.RefreshData()
        })
        
        Write-Log -Level Debug -Message "DashboardScreen subscribed to events"
    }
    
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            Write-Log -Level Debug -Message "Refreshing dashboard data"
            
            # Get data from services
            if ($null -ne $this.Services -and $null -ne $this.Services.DataManager) {
                $this.Tasks = @($this.Services.DataManager.GetTasks())
                
                # Update summary
                $this.UpdateSummary()
                
                # Update task list
                $this.UpdateTaskList()
            } else {
                Write-Log -Level Warning -Message "DataManager service not available"
            }
        }
    }
    
    hidden [void] UpdateSummary() {
        $totalTasks = $this.Tasks.Count
        $completedTasks = @($this.Tasks | Where-Object { $_.Status -eq "Completed" }).Count
        $todayTasks = @($this.Tasks | Where-Object { 
            $_.DueDate -and ([DateTime]$_.DueDate).Date -eq (Get-Date).Date 
        }).Count
        
        $summaryContent = @(
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
            "         Task Summary",
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
            "",
            "  Total Tasks:      $totalTasks",
            "  Completed:        $completedTasks",
            "  Due Today:        $todayTasks",
            "",
            "  Completion Rate:  $(if ($totalTasks -gt 0) { "{0:P0}" -f ($completedTasks / $totalTasks) } else { "N/A" })"
        )
        
        $this.SummaryPanel.SetContent($summaryContent)
    }
    
    hidden [void] UpdateTaskList() {
        $taskContent = @("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        $taskContent += "  #  Task Title                          Status       Priority   Due Date"
        $taskContent += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        for ($i = 0; $i -lt $this.Tasks.Count; $i++) {
            $task = $this.Tasks[$i]
            $isSelected = $i -eq $this.SelectedTaskIndex
            $prefix = if ($isSelected) { "‚Üí" } else { " " }
            
            $title = if ($task.Title.Length -gt 35) { 
                $task.Title.Substring(0, 32) + "..." 
            } else { 
                $task.Title.PadRight(35) 
            }
            
            $status = ($task.Status ?? "Pending").PadRight(12)
            $priority = ($task.Priority ?? "Normal").PadRight(10)
            $dueDate = if ($task.DueDate) { 
                ([DateTime]$task.DueDate).ToString("MM/dd/yyyy") 
            } else { 
                "          " 
            }
            
            $line = "$prefix $("{0,2}" -f ($i + 1))  $title  $status $priority $dueDate"
            $taskContent += $line
        }
        
        if ($this.Tasks.Count -eq 0) {
            $taskContent += ""
            $taskContent += "                    No tasks found. Press [N] to create a new task."
        }
        
        $this.TaskPanel.SetContent($taskContent)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        if (-not $this.IsInitialized) {
            Write-Log -Level Warning -Message "HandleInput called on uninitialized screen"
            return
        }
        
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.SelectedTaskIndex -gt 0) {
                        $this.SelectedTaskIndex--
                        $this.UpdateTaskList()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.SelectedTaskIndex -lt ($this.Tasks.Count - 1)) {
                        $this.SelectedTaskIndex++
                        $this.UpdateTaskList()
                    }
                }
                ([ConsoleKey]::Enter) {
                    if ($this.Tasks.Count -gt 0 -and $this.SelectedTaskIndex -ge 0) {
                        $selectedTask = $this.Tasks[$this.SelectedTaskIndex]
                        $this.Services.Navigation.PushScreen("TaskDetailScreen", @{TaskId = $selectedTask.Id})
                    }
                }
                ([ConsoleKey]::Escape) {
                    # Already at top level, could show exit confirmation
                }
                default {
                    # Handle character keys
                    $char = [char]$key.KeyChar
                    switch ($char.ToString().ToUpper()) {
                        'N' { $this.Services.Navigation.PushScreen("NewTaskScreen") }
                        'E' { 
                            if ($this.Tasks.Count -gt 0) {
                                $selectedTask = $this.Tasks[$this.SelectedTaskIndex]
                                $this.Services.Navigation.PushScreen("EditTaskScreen", @{TaskId = $selectedTask.Id})
                            }
                        }
                        'D' { 
                            if ($this.Tasks.Count -gt 0) {
                                $selectedTask = $this.Tasks[$this.SelectedTaskIndex]
                                $this.Services.DataManager.DeleteTask($selectedTask.Id)
                            }
                        }
                        'P' { $this.Services.Navigation.PushScreen("ProjectListScreen") }
                        'T' { $this.Services.Navigation.PushScreen("TaskListScreen") }
                        'Q' { 
                            # Exit is handled by main loop
                            # Could show exit confirmation here if needed
                        }
                    }
                }
            }
        }
    }
    
    [void] Cleanup() {
        Write-Log -Level Info -Message "Cleaning up DashboardScreen"
        
        # Call base cleanup (which handles event unsubscription)
        ([Screen]$this).Cleanup()
    }
}

# Export the class
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\screens\dashboard-screen-class.psm1
# Dashboard Screen - Fixed Parameter Binding Issues
# Displays dynamic data and uses direct service calls and eventing.

using module '..\modules\models.psm1'
using module '..\modules\exceptions.psm1'
using module '..\modules\logger.psm1'
using module '..\modules\event-system.psm1'
using module '..\modules\theme-manager.psm1'
using module '..\utilities\focus-manager.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\components\tui-components.psm1'
using module '..\layout\panels.psm1'

function Get-DashboardScreen {
    param([hashtable]$Services)
    
    $screen = @{
        Name = "DashboardScreen"
        Components = @{}
        Children = @()
        _subscriptions = @()
        _focusIndex = 0
        _services = $null
        Visible = $true
        ZIndex = 0
        
        Init = {
            param($self, $services)
            
            Invoke-WithErrorHandling -ScriptBlock {
                # AI: Simplified and robust services validation
                if (-not $services) {
                    throw "Services parameter is required for dashboard initialization"
                }
                
                # Store services on screen instance
                $self._services = $services
                
                # Validate critical services exist with detailed error reporting
                if (-not $services.Navigation) {
                    $availableServices = ($services.Keys | Sort-Object) -join ", "
                    throw "Navigation service is missing. Available services: $availableServices"
                }
                
                # AI: Fixed Write-Log call - use -Data instead of -Component
                Write-Log -Level Info -Message "Dashboard Init: Services validated successfully" -Data @{ Component = "Dashboard"; Context = "Init" }
                
                # Create simple root panel
                $rootPanel = New-TuiStackPanel -Props @{
                    X = 2
                    Y = 2
                    Width = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                    Height = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                    ShowBorder = $true
                    Title = " PMC Terminal v5 - Main Menu "
                    Orientation = "Vertical"
                    Spacing = 1
                    Padding = 2
                }
                
                # Store reference and add to children
                $self.Components.rootPanel = $rootPanel
                $self.Children = @($rootPanel)
                
                # Add instruction label
                $instructionLabel = New-TuiLabel -Props @{
                    Text = "Select an option using number keys (1-4) or use arrow keys and Enter"
                    X = 1
                    Y = 1
                    Width = 50
                    Height = 1
                    Name = "InstructionLabel"
                }
                $rootPanel.AddChild($instructionLabel)
                
                # Create main navigation menu items
                $menuItems = @(
                    @{ Index = "1"; Action = "Task Management"; Path = "/tasks" }
                    @{ Index = "2"; Action = "Project Management"; Path = "/projects" }
                    @{ Index = "3"; Action = "Settings"; Path = "/settings" }
                    @{ Index = "4"; Action = "Reports"; Path = "/reports" }
                    @{ Index = "0"; Action = "Exit Application"; Path = "/exit" }
                )
                
                # AI: Capture services for closure scope
                $capturedServices = $services
                
                # Create navigation menu component
                $navigationMenu = New-TuiDataTable -Props @{
                    Name = "NavigationMenu"
                    IsFocusable = $true
                    ShowBorder = $true
                    BorderStyle = "Double"
                    Title = " Main Menu "
                    Height = [Math]::Min(15, $menuItems.Count + 4)
                    Width = 50
                    Columns = @(
                        @{ Name = "Index"; Width = 5; Align = "Center" }
                        @{ Name = "Action"; Width = 40; Align = "Left" }
                    )
                    Data = $menuItems
                    OnRowSelect = {
                        param($SelectedData, $SelectedIndex)
                        
                        Invoke-WithErrorHandling -ScriptBlock {
                            # AI: Robust parameter validation
                            if (-not $SelectedData) {
                                Write-Log -Level Warning -Message "Dashboard: OnRowSelect called with null data" -Data @{ Component = "Dashboard.OnRowSelect" }
                                return
                            }
                            
                            $path = $SelectedData.Path
                            if ([string]::IsNullOrWhiteSpace($path)) {
                                Write-Log -Level Warning -Message "Dashboard: No path in selected data" -Data @{ Component = "Dashboard.OnRowSelect" }
                                return
                            }
                            
                            Write-Log -Level Info -Message "Dashboard: Navigating to $path" -Data @{ Component = "Dashboard.OnRowSelect"; Path = $path }
                            
                            if ($path -eq "/exit") {
                                Stop-TuiEngine
                                return
                            }
                            
                            # AI: Simplified services validation
                            if (-not $capturedServices -or -not $capturedServices.Navigation -or -not $capturedServices.Navigation.GoTo) {
                                $errorMsg = "Navigation service not properly initialized"
                                Write-Log -Level Error -Message $errorMsg -Data @{ Component = "Dashboard.OnRowSelect" }
                                throw $errorMsg
                            }
                            
                            # Navigate to selected screen
                            & $capturedServices.Navigation.GoTo -self $capturedServices.Navigation -Path $path -Services $capturedServices
                        } -Component "Dashboard.OnRowSelect" -Context "Navigation"
                    }
                }
                
                # Add navigation menu to root panel
                $rootPanel.AddChild($navigationMenu)
                $self._navigationMenu = $navigationMenu
                
                # Add stats display
                $statsLabel = New-TuiLabel -Props @{
                    Text = "Loading statistics..."
                    X = 1
                    Y = 20
                    Width = 50
                    Height = 1
                    Name = "StatsLabel"
                    ForegroundColor = "Gray"
                }
                
                $rootPanel.AddChild($statsLabel)
                $self.Components.statsLabel = $statsLabel
                
                # Create refresh function
                $self.RefreshDashboardStats = {
                    param($self)
                    
                    Invoke-WithErrorHandling -ScriptBlock {
                        # AI: Robust data access with null checks
                        $openTasks = 0
                        if ($global:Data -and $global:Data.Tasks) {
                            $openTasks = ($global:Data.Tasks.Where({ -not $_.Completed })).Count
                        }
                        
                        if ($self.Components -and $self.Components.statsLabel) {
                            $self.Components.statsLabel.Text = "Open Tasks: $openTasks"
                        }
                        else {
                            Write-Log -Level Warning -Message "Dashboard RefreshStats: statsLabel component not available" -Data @{ Component = "Dashboard.RefreshStats" }
                        }
                        
                        Request-TuiRefresh
                    } -Component "Dashboard.RefreshStats" -Context "RefreshStats"
                }
                
                # Subscribe to data changes to keep the dashboard live
                $subscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler {
                    Write-Log -Level Debug -Message "Dashboard received Tasks.Changed event" -Data @{ Component = "Dashboard" }
                    & $self.RefreshDashboardStats -self $self
                } -Source "DashboardScreen"
                $self._subscriptions += $subscriptionId
                
                # Initial data load
                & $self.RefreshDashboardStats -self $self
                
                # Set initial focus
                Request-Focus -Component $navigationMenu
                
                Write-Log -Level Info -Message "Dashboard Init: Completed successfully" -Data @{ Component = "Dashboard.Init" }
            } -Component "Dashboard" -Context "Init"
        }
        
        HandleInput = {
            param($self, $key)
            
            if (-not $key) { return $false }
            
            Invoke-WithErrorHandling -ScriptBlock {
                if (-not $self._navigationMenu) {
                    # AI: Fixed Write-Log call - use -Data instead of -Component
                    Write-Log -Level Warning -Message "Dashboard HandleInput: Navigation menu not available" -Data @{ Component = "Dashboard"; Context = "HandleInput" }
                    return $false
                }
                
                # Handle number key shortcuts for quick navigation
                if ($key.KeyChar -match '[0-4]') {
                    $index = [int]$key.KeyChar
                    
                    # Get menu data for selection
                    $menuData = @($self._navigationMenu.Data)
                    
                    if ($index -eq 0) {
                        Write-Log -Level Info -Message "Dashboard: Exit via hotkey" -Data @{ Component = "Dashboard.HandleInput" }
                        Stop-TuiEngine
                        return $true
                    }
                    
                    # Find and select the item with matching index
                    $selectedItem = $menuData | Where-Object { $_.Index -eq $index.ToString() }
                    if ($selectedItem -and $self._services -and $self._services.Navigation) {
                        & $self._services.Navigation.GoTo -self $self._services -Path $selectedItem.Path -Services $self._services
                        return $true
                    }
                }
                
                # Pass other keys to the menu
                if ($self._navigationMenu.HandleInput) {
                    return & $self._navigationMenu.HandleInput -self $self._navigationMenu -key $key
                }
                
                return $false
            } -Component "Dashboard" -Context "HandleInput"
        }
        
        OnEnter = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnEnter" -Data @{ Component = "Dashboard.OnEnter" }
            
            # Ensure focus on menu and refresh stats in case data changed while away
            if ($self._navigationMenu) {
                Request-Focus -Component $self._navigationMenu
            }
            if ($self.RefreshDashboardStats) {
                & $self.RefreshDashboardStats -self $self
            }
            Request-TuiRefresh
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnExit: Cleaning up" -Data @{ Component = "Dashboard.OnExit" }
            
            Invoke-WithErrorHandling -ScriptBlock {
                # AI: Safe event cleanup with proper error handling
                if ($self._subscriptions -and @($self._subscriptions).Count -gt 0) {
                    foreach ($subId in $self._subscriptions) {
                        if ($subId) {
                            try {
                                Unsubscribe-Event -HandlerId $subId
                                Write-Log -Level Debug -Message "Dashboard unsubscribed from event: $subId" -Data @{ Component = "Dashboard.OnExit"; SubscriptionId = $subId }
                            }
                            catch {
                                Write-Log -Level Warning -Message "Dashboard failed to unsubscribe from event $subId : $_" -Data @{ Component = "Dashboard.OnExit"; SubscriptionId = $subId; Error = $_ }
                            }
                        }
                    }
                    $self._subscriptions = @()
                }
            } -Component "Dashboard.OnExit" -Context "Cleanup"
        }
        
        Render = {
            param($self)
            # The panel and components handle their own rendering
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen


####\screens\dashboard-screen-fixed.psm1
# Dashboard Screen - Fixed Parameter Binding Issues
# Displays dynamic data and uses direct service calls and eventing.

using module '..\modules\models.psm1'
using module '..\modules\exceptions.psm1'
using module '..\modules\logger.psm1'
using module '..\modules\event-system.psm1'
using module '..\modules\theme-manager.psm1'
using module '..\utilities\focus-manager.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\components\tui-components.psm1'
using module '..\layout\panels.psm1'

function Get-DashboardScreen {
    param([hashtable]$Services)
    
    $screen = @{
        Name = "DashboardScreen"
        Components = @{}
        Children = @()
        _subscriptions = @()
        _focusIndex = 0
        _services = $null
        Visible = $true
        ZIndex = 0
        
        Init = {
            param($self, $services)
            
            Invoke-WithErrorHandling -ScriptBlock {
                # AI: Simplified and robust services validation
                if (-not $services) {
                    throw "Services parameter is required for dashboard initialization"
                }
                
                # Store services on screen instance
                $self._services = $services
                
                # Validate critical services exist with detailed error reporting
                if (-not $services.Navigation) {
                    $availableServices = ($services.Keys | Sort-Object) -join ", "
                    throw "Navigation service is missing. Available services: $availableServices"
                }
                
                # AI: Fixed Write-Log call - use -Data instead of -Component
                Write-Log -Level Info -Message "Dashboard Init: Services validated successfully" -Data @{ Component = "Dashboard"; Context = "Init" }
                
                # Create simple root panel
                $rootPanel = New-TuiStackPanel -Props @{
                    X = 2
                    Y = 2
                    Width = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                    Height = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                    ShowBorder = $true
                    Title = " PMC Terminal v5 - Main Menu "
                    Orientation = "Vertical"
                    Spacing = 1
                    Padding = 2
                }
                
                # Store reference and add to children
                $self.Components.rootPanel = $rootPanel
                $self.Children = @($rootPanel)
                
                # Add instruction label
                $instructionLabel = New-TuiLabel -Props @{
                    Text = "Select an option using number keys (1-4) or use arrow keys and Enter"
                    X = 1
                    Y = 1
                    Width = 50
                    Height = 1
                    Name = "InstructionLabel"
                }
                $rootPanel.AddChild($instructionLabel)
                
                # Create main navigation menu items
                $menuItems = @(
                    @{ Index = "1"; Action = "Task Management"; Path = "/tasks" }
                    @{ Index = "2"; Action = "Project Management"; Path = "/projects" }
                    @{ Index = "3"; Action = "Settings"; Path = "/settings" }
                    @{ Index = "4"; Action = "Reports"; Path = "/reports" }
                    @{ Index = "0"; Action = "Exit Application"; Path = "/exit" }
                )
                
                # AI: Capture services for closure scope
                $capturedServices = $services
                
                # Create navigation menu component
                $navigationMenu = New-TuiDataTable -Props @{
                    Name = "NavigationMenu"
                    IsFocusable = $true
                    ShowBorder = $true
                    BorderStyle = "Double"
                    Title = " Main Menu "
                    Height = [Math]::Min(15, $menuItems.Count + 4)
                    Width = 50
                    Columns = @(
                        @{ Name = "Index"; Width = 5; Align = "Center" }
                        @{ Name = "Action"; Width = 40; Align = "Left" }
                    )
                    Data = $menuItems
                    OnRowSelect = {
                        param($SelectedData, $SelectedIndex)
                        
                        Invoke-WithErrorHandling -ScriptBlock {
                            # AI: Robust parameter validation
                            if (-not $SelectedData) {
                                Write-Log -Level Warning -Message "Dashboard: OnRowSelect called with null data" -Data @{ Component = "Dashboard.OnRowSelect" }
                                return
                            }
                            
                            $path = $SelectedData.Path
                            if ([string]::IsNullOrWhiteSpace($path)) {
                                Write-Log -Level Warning -Message "Dashboard: No path in selected data" -Data @{ Component = "Dashboard.OnRowSelect" }
                                return
                            }
                            
                            Write-Log -Level Info -Message "Dashboard: Navigating to $path" -Data @{ Component = "Dashboard.OnRowSelect"; Path = $path }
                            
                            if ($path -eq "/exit") {
                                Stop-TuiEngine
                                return
                            }
                            
                            # AI: Simplified services validation
                            if (-not $capturedServices -or -not $capturedServices.Navigation -or -not $capturedServices.Navigation.GoTo) {
                                $errorMsg = "Navigation service not properly initialized"
                                Write-Log -Level Error -Message $errorMsg -Data @{ Component = "Dashboard.OnRowSelect" }
                                throw $errorMsg
                            }
                            
                            # Navigate to selected screen
                            & $capturedServices.Navigation.GoTo -self $capturedServices.Navigation -Path $path -Services $capturedServices
                        } -Component "Dashboard.OnRowSelect" -Context "Navigation"
                    }
                }
                
                # Add navigation menu to root panel
                $rootPanel.AddChild($navigationMenu)
                $self._navigationMenu = $navigationMenu
                
                # Add stats display
                $statsLabel = New-TuiLabel -Props @{
                    Text = "Loading statistics..."
                    X = 1
                    Y = 20
                    Width = 50
                    Height = 1
                    Name = "StatsLabel"
                    ForegroundColor = "Gray"
                }
                
                $rootPanel.AddChild($statsLabel)
                $self.Components.statsLabel = $statsLabel
                
                # Create refresh function
                $self.RefreshDashboardStats = {
                    param($self)
                    
                    Invoke-WithErrorHandling -ScriptBlock {
                        # AI: Robust data access with null checks
                        $openTasks = 0
                        if ($global:Data -and $global:Data.Tasks) {
                            $openTasks = ($global:Data.Tasks.Where({ -not $_.Completed })).Count
                        }
                        
                        if ($self.Components -and $self.Components.statsLabel) {
                            $self.Components.statsLabel.Text = "Open Tasks: $openTasks"
                        }
                        else {
                            Write-Log -Level Warning -Message "Dashboard RefreshStats: statsLabel component not available" -Data @{ Component = "Dashboard.RefreshStats" }
                        }
                        
                        Request-TuiRefresh
                    } -Component "Dashboard.RefreshStats" -Context "RefreshStats"
                }
                
                # Subscribe to data changes to keep the dashboard live
                $subscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler {
                    Write-Log -Level Debug -Message "Dashboard received Tasks.Changed event" -Data @{ Component = "Dashboard" }
                    & $self.RefreshDashboardStats -self $self
                } -Source "DashboardScreen"
                $self._subscriptions += $subscriptionId
                
                # Initial data load
                & $self.RefreshDashboardStats -self $self
                
                # Set initial focus
                Request-Focus -Component $navigationMenu
                
                Write-Log -Level Info -Message "Dashboard Init: Completed successfully" -Data @{ Component = "Dashboard.Init" }
            } -Component "Dashboard" -Context "Init"
        }
        
        HandleInput = {
            param($self, $key)
            
            if (-not $key) { return $false }
            
            Invoke-WithErrorHandling -ScriptBlock {
                if (-not $self._navigationMenu) {
                    # AI: Fixed Write-Log call - use -Data instead of -Component
                    Write-Log -Level Warning -Message "Dashboard HandleInput: Navigation menu not available" -Data @{ Component = "Dashboard"; Context = "HandleInput" }
                    return $false
                }
                
                # Handle number key shortcuts for quick navigation
                if ($key.KeyChar -match '[0-4]') {
                    $index = [int]$key.KeyChar
                    
                    # Get menu data for selection
                    $menuData = @($self._navigationMenu.Data)
                    
                    if ($index -eq 0) {
                        Write-Log -Level Info -Message "Dashboard: Exit via hotkey" -Data @{ Component = "Dashboard.HandleInput" }
                        Stop-TuiEngine
                        return $true
                    }
                    
                    # Find and select the item with matching index
                    $selectedItem = $menuData | Where-Object { $_.Index -eq $index.ToString() }
                    if ($selectedItem -and $self._services -and $self._services.Navigation) {
                        & $self._services.Navigation.GoTo -self $self._services -Path $selectedItem.Path -Services $self._services
                        return $true
                    }
                }
                
                # Pass other keys to the menu
                if ($self._navigationMenu.HandleInput) {
                    return & $self._navigationMenu.HandleInput -self $self._navigationMenu -key $key
                }
                
                return $false
            } -Component "Dashboard" -Context "HandleInput"
        }
        
        OnEnter = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnEnter" -Data @{ Component = "Dashboard.OnEnter" }
            
            # Ensure focus on menu and refresh stats in case data changed while away
            if ($self._navigationMenu) {
                Request-Focus -Component $self._navigationMenu
            }
            if ($self.RefreshDashboardStats) {
                & $self.RefreshDashboardStats -self $self
            }
            Request-TuiRefresh
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnExit: Cleaning up" -Data @{ Component = "Dashboard.OnExit" }
            
            Invoke-WithErrorHandling -ScriptBlock {
                # AI: Safe event cleanup with proper error handling
                if ($self._subscriptions -and @($self._subscriptions).Count -gt 0) {
                    foreach ($subId in $self._subscriptions) {
                        if ($subId) {
                            try {
                                Unsubscribe-Event -HandlerId $subId
                                Write-Log -Level Debug -Message "Dashboard unsubscribed from event: $subId" -Data @{ Component = "Dashboard.OnExit"; SubscriptionId = $subId }
                            }
                            catch {
                                Write-Log -Level Warning -Message "Dashboard failed to unsubscribe from event $subId : $_" -Data @{ Component = "Dashboard.OnExit"; SubscriptionId = $subId; Error = $_ }
                            }
                        }
                    }
                    $self._subscriptions = @()
                }
            } -Component "Dashboard.OnExit" -Context "Cleanup"
        }
        
        Render = {
            param($self)
            # The panel and components handle their own rendering
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen


####\screens\dashboard-screen-helios.psm1
# Dashboard Screen - Fixed Parameter Binding Issues
# Displays dynamic data and uses direct service calls and eventing.

using module '..\modules\models.psm1'
using module '..\modules\exceptions.psm1'
using module '..\modules\logger.psm1'
using module '..\modules\event-system.psm1'
using module '..\modules\theme-manager.psm1'
using module '..\utilities\focus-manager.psm1'
using module '..\components\advanced-data-components.psm1'
using module '..\components\tui-components.psm1'
using module '..\layout\panels.psm1'

function Get-DashboardScreen {
    param([hashtable]$Services)
    
    # AI: Ensure services are stored on the screen object
    if (-not $Services -and $global:Services) {
        $Services = $global:Services
    }
    
    $screen = @{
        Name = "DashboardScreen"
        Components = @{}
        Children = @()
        _subscriptions = @()
        _focusIndex = 0
        _services = $null
        Visible = $true
        ZIndex = 0
        
        Init = {
            param($self, $services)
            
            # AI: Ensure services are available even if not passed directly
            if (-not $services -and $self._services) {
                $services = $self._services
            }
            
            Invoke-WithErrorHandling -ScriptBlock {
                # AI: Simplified and robust services validation
                if (-not $services) {
                    throw "Services parameter is required for dashboard initialization"
                }
                
                # Store services on screen instance
                $self._services = $services
                
                # Validate critical services exist with detailed error reporting
                if (-not $services.Navigation) {
                    $availableServices = ($services.Keys | Sort-Object) -join ", "
                    throw "Navigation service is missing. Available services: $availableServices"
                }
                
                # AI: Fixed Write-Log call - removed Context from Data to avoid duplication
                Write-Log -Level Info -Message "Dashboard Init: Services validated successfully" -Data @{ Component = "Dashboard"; Operation = "Init" }
                
                # Create simple root panel
                $rootPanel = New-TuiStackPanel -Props @{
                    X = 2
                    Y = 2
                    Width = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                    Height = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                    ShowBorder = $true
                    Title = " PMC Terminal v5 - Main Menu "
                    Orientation = "Vertical"
                    Spacing = 1
                    Padding = 2
                }
                
                # Store reference and add to children
                $self.Components.rootPanel = $rootPanel
                $self.Children = @($rootPanel)
                
                # Add instruction label
                $instructionLabel = New-TuiLabel -Props @{
                    Text = "Select an option using number keys (1-4) or use arrow keys and Enter"
                    X = 1
                    Y = 1
                    Width = 50
                    Height = 1
                    Name = "InstructionLabel"
                }
                & $rootPanel.AddChild -self $rootPanel -Child $instructionLabel
                
                # Create main navigation menu items
                $menuItems = @(
                    @{ Index = "1"; Action = "Task Management"; Path = "/tasks" }
                    @{ Index = "2"; Action = "Project Management"; Path = "/projects" }
                    @{ Index = "3"; Action = "Settings"; Path = "/settings" }
                    @{ Index = "4"; Action = "Reports"; Path = "/reports" }
                    @{ Index = "0"; Action = "Exit Application"; Path = "/exit" }
                )
                
                # AI: Capture services for closure scope
                $capturedServices = $services
                
                # Create navigation menu component
                $navigationMenu = New-TuiDataTable -Props @{
                    Name = "NavigationMenu"
                    IsFocusable = $true
                    ShowBorder = $true
                    BorderStyle = "Double"
                    Title = " Main Menu "
                    Height = [Math]::Min(15, $menuItems.Count + 4)
                    Width = 50
                    Columns = @(
                        @{ Name = "Index"; Width = 5; Align = "Center" }
                        @{ Name = "Action"; Width = 40; Align = "Left" }
                    )
                    Data = $menuItems
                    OnRowSelect = {
                        param($SelectedData, $SelectedIndex)
                        
                        Invoke-WithErrorHandling -ScriptBlock {
                            # AI: Robust parameter validation
                            if (-not $SelectedData) {
                                Write-Log -Level Warning -Message "Dashboard: OnRowSelect called with null data" -Data @{ Component = "Dashboard.OnRowSelect" }
                                return
                            }
                            
                            $path = $SelectedData.Path
                            if ([string]::IsNullOrWhiteSpace($path)) {
                                Write-Log -Level Warning -Message "Dashboard: No path in selected data" -Data @{ Component = "Dashboard.OnRowSelect" }
                                return
                            }
                            
                            Write-Log -Level Info -Message "Dashboard: Navigating to $path" -Data @{ Component = "Dashboard.OnRowSelect"; Path = $path }
                            
                            if ($path -eq "/exit") {
                                Stop-TuiEngine
                                return
                            }
                            
                            # AI: Fixed navigation service call for class-based implementation
                            if (-not $capturedServices -or -not $capturedServices.Navigation) {
                                $errorMsg = "Navigation service not properly initialized"
                                Write-Log -Level Error -Message $errorMsg -Data @{ Component = "Dashboard.OnRowSelect" }
                                throw $errorMsg
                            }
                            
                            # Navigate to selected screen using proper class method call
                            try {
                                # For class-based navigation service
                                if ($capturedServices.Navigation.GetType().Name -eq 'NavigationService') {
                                    [void]$capturedServices.Navigation.GoTo($path, @{})
                                }
                                # For scriptblock-based navigation (fallback)
                                elseif ($capturedServices.Navigation.GoTo -is [scriptblock]) {
                                    & $capturedServices.Navigation.GoTo -self $capturedServices.Navigation -Path $path
                                }
                                else {
                                    throw "Navigation service GoTo method not found or incompatible"
                                }
                            }
                            catch {
                                Write-Log -Level Error -Message "Navigation failed: $_" -Data @{ Component = "Dashboard.OnRowSelect"; Path = $path }
                                throw
                            }
                        } -Component "Dashboard.OnRowSelect" -Context "Navigation"
                    }
                }
                
                # Add navigation menu to root panel
                & $rootPanel.AddChild -self $rootPanel -Child $navigationMenu
                $self._navigationMenu = $navigationMenu
                
                # Add stats display
                $statsLabel = New-TuiLabel -Props @{
                    Text = "Loading statistics..."
                    X = 1
                    Y = 20
                    Width = 50
                    Height = 1
                    Name = "StatsLabel"
                    ForegroundColor = "Gray"
                }
                
                & $rootPanel.AddChild -self $rootPanel -Child $statsLabel
                $self.Components.statsLabel = $statsLabel
                
                # Create refresh function
                $self.RefreshDashboardStats = {
                    param($self)
                    
                    Invoke-WithErrorHandling -ScriptBlock {
                        # AI: Robust data access with null checks
                        $openTasks = 0
                        if ($global:Data -and $global:Data.Tasks) {
                            $openTasks = ($global:Data.Tasks.Where({ -not $_.Completed })).Count
                        }
                        
                        if ($self.Components -and $self.Components.statsLabel) {
                            $self.Components.statsLabel.Text = "Open Tasks: $openTasks"
                        }
                        else {
                            Write-Log -Level Warning -Message "Dashboard RefreshStats: statsLabel component not available" -Data @{ Component = "Dashboard.RefreshStats" }
                        }
                        
                        Request-TuiRefresh
                    } -Component "Dashboard.RefreshStats" -Context "RefreshStats"
                }
                
                # Subscribe to data changes to keep the dashboard live
                $subscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler {
                    Write-Log -Level Debug -Message "Dashboard received Tasks.Changed event" -Data @{ Component = "Dashboard" }
                    & $self.RefreshDashboardStats -self $self
                } -Source "DashboardScreen"
                $self._subscriptions += $subscriptionId
                
                # Initial data load
                & $self.RefreshDashboardStats -self $self
                
                # Set initial focus
                Request-Focus -Component $navigationMenu
                
                Write-Log -Level Info -Message "Dashboard Init: Completed successfully" -Data @{ Component = "Dashboard"; Operation = "Init.Complete" }
            } -Component "Dashboard" -Context "Init"
        }
        
        HandleInput = {
            param($self, $key)
            
            if (-not $key) { return $false }
            
            Invoke-WithErrorHandling -ScriptBlock {
                if (-not $self._navigationMenu) {
                    # AI: Fixed Write-Log call - removed Context from Data to avoid duplication
                    Write-Log -Level Warning -Message "Dashboard HandleInput: Navigation menu not available" -Data @{ Component = "Dashboard"; Operation = "HandleInput" }
                    return $false
                }
                
                # Handle number key shortcuts for quick navigation
                if ($key.KeyChar -match '[0-4]') {
                    $index = [int]$key.KeyChar
                    
                    # Get menu data for selection
                    $menuData = @($self._navigationMenu.Data)
                    
                    if ($index -eq 0) {
                        Write-Log -Level Info -Message "Dashboard: Exit via hotkey" -Data @{ Component = "Dashboard.HandleInput" }
                        Stop-TuiEngine
                        return $true
                    }
                    
                    # Find and select the item with matching index
                    $selectedItem = $menuData | Where-Object { $_.Index -eq $index.ToString() }
                    if ($selectedItem -and $self._services -and $self._services.Navigation) {
                        # AI: Use proper navigation call based on service type
                        try {
                            if ($self._services.Navigation.GetType().Name -eq 'NavigationService') {
                                [void]$self._services.Navigation.GoTo($selectedItem.Path, @{})
                            }
                            elseif ($self._services.Navigation.GoTo -is [scriptblock]) {
                                & $self._services.Navigation.GoTo -self $self._services.Navigation -Path $selectedItem.Path
                            }
                            return $true
                        }
                        catch {
                            Write-Log -Level Error -Message "Hotkey navigation failed: $_" -Data @{ Component = "Dashboard.HandleInput"; Path = $selectedItem.Path }
                        }
                    }
                }
                
                # Pass other keys to the menu
                if ($self._navigationMenu.HandleInput) {
                    return & $self._navigationMenu.HandleInput -self $self._navigationMenu -key $key
                }
                
                return $false
            } -Component "Dashboard" -Context "HandleInput"
        }
        
        OnEnter = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnEnter" -Data @{ Component = "Dashboard.OnEnter" }
            
            # Ensure focus on menu and refresh stats in case data changed while away
            if ($self._navigationMenu) {
                Request-Focus -Component $self._navigationMenu
            }
            if ($self.RefreshDashboardStats) {
                & $self.RefreshDashboardStats -self $self
            }
            Request-TuiRefresh
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Info -Message "Dashboard OnExit: Cleaning up" -Data @{ Component = "Dashboard.OnExit" }
            
            Invoke-WithErrorHandling -ScriptBlock {
                # AI: Safe event cleanup with proper error handling
                if ($self._subscriptions -and @($self._subscriptions).Count -gt 0) {
                    foreach ($subId in $self._subscriptions) {
                        if ($subId) {
                            try {
                                Unsubscribe-Event -HandlerId $subId
                                Write-Log -Level Debug -Message "Dashboard unsubscribed from event: $subId" -Data @{ Component = "Dashboard.OnExit"; SubscriptionId = $subId }
                            }
                            catch {
                                Write-Log -Level Warning -Message "Dashboard failed to unsubscribe from event $subId : $_" -Data @{ Component = "Dashboard.OnExit"; SubscriptionId = $subId; Error = $_ }
                            }
                        }
                    }
                    $self._subscriptions = @()
                }
            } -Component "Dashboard.OnExit" -Context "Cleanup"
        }
        
        Render = {
            param($self)
            # The panel and components handle their own rendering
        }
    }
    
    # AI: Attach services to screen object for later use
    if ($Services) {
        $screen._services = $Services
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen


####\screens\new-task-screen-class.psm1
# New Task Screen Class Implementation
# Provides interface for creating new tasks
# AI: MVP implementation for new task screen following class-based architecture

using namespace System.Collections.Generic

# Import base classes
using module ..\components\ui-classes.psm1
using module ..\components\panel-classes.psm1
using module ..\models.psm1

# Import utilities
Import-Module "$PSScriptRoot\..\utilities\error-handling.psm1" -Force
Import-Module "$PSScriptRoot\..\utilities\event-system.psm1" -Force

class NewTaskScreen : Screen {
    # UI Components
    [BorderPanel] $MainPanel
    [ContentPanel] $FormPanel
    [BorderPanel] $NavigationPanel
    
    # Form Fields
    [string] $TaskTitle = ""
    [string] $TaskDescription = ""
    [TaskPriority] $TaskPriority = [TaskPriority]::Medium
    [string] $TaskDueDate = ""
    [string] $ProjectId = ""
    [int] $CurrentField = 0
    [int] $TotalFields = 5
    [bool] $EditingField = $false
    
    NewTaskScreen([hashtable]$services) : base("NewTaskScreen", $services) {
        Write-Log -Level Info -Message "Creating NewTaskScreen instance" -Component "NewTaskScreen"
    }
    
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "NewTaskScreen" -Context "Initialize" -ScriptBlock {
            Write-Log -Level Info -Message "Initializing NewTaskScreen" -Component "NewTaskScreen"
            
            # Create main container panel
            $this.MainPanel = [BorderPanel]::new("NewTaskMain", 20, 5, 80, 20)
            $this.MainPanel.Title = "Create New Task"
            $this.MainPanel.BorderStyle = "Double"
            $this.AddPanel($this.MainPanel)
            
            # Create form panel
            $this.FormPanel = [ContentPanel]::new("NewTaskForm", 22, 7, 76, 10)
            $this.MainPanel.AddChild($this.FormPanel)
            
            # Create navigation panel
            $this.NavigationPanel = [BorderPanel]::new("NewTaskNav", 22, 18, 76, 4)
            $this.NavigationPanel.Title = "Actions"
            $this.NavigationPanel.BorderStyle = "Single"
            $this.MainPanel.AddChild($this.NavigationPanel)
            
            # Initialize navigation content
            $this.InitializeNavigation()
            
            # Update form display
            $this.UpdateFormDisplay()
            
            Write-Log -Level Info -Message "NewTaskScreen initialized successfully" -Component "NewTaskScreen"
        }
    }
    
    hidden [void] InitializeNavigation() {
        $navContent = @(
            "[‚Üë‚Üì] Navigate Fields    [Enter] Edit Field    [Tab] Next Field",
            "[S] Save Task          [Esc] Cancel         [C] Clear Form"
        )
        
        $navPanel = [ContentPanel]::new("NavContent", 23, 19, 74, 2)
        $navPanel.SetContent($navContent)
        $this.NavigationPanel.AddChild($navPanel)
    }
    
    hidden [void] UpdateFormDisplay() {
        $formContent = @()
        
        # Title field
        $titleIndicator = if ($this.CurrentField -eq 0) { "‚Üí" } else { " " }
        $titleValue = if ($this.EditingField -and $this.CurrentField -eq 0) { 
            $this.TaskTitle + "_" 
        } else { 
            if ([string]::IsNullOrWhiteSpace($this.TaskTitle)) { "<Enter task title>" } else { $this.TaskTitle }
        }
        $formContent += "$titleIndicator Title:       $titleValue"
        
        # Description field
        $descIndicator = if ($this.CurrentField -eq 1) { "‚Üí" } else { " " }
        $descValue = if ($this.EditingField -and $this.CurrentField -eq 1) { 
            $this.TaskDescription + "_" 
        } else { 
            if ([string]::IsNullOrWhiteSpace($this.TaskDescription)) { "<Enter description>" } else { $this.TaskDescription }
        }
        $formContent += "$descIndicator Description: $descValue"
        
        # Priority field
        $priorityIndicator = if ($this.CurrentField -eq 2) { "‚Üí" } else { " " }
        $formContent += "$priorityIndicator Priority:    $($this.TaskPriority)"
        
        # Due date field
        $dueDateIndicator = if ($this.CurrentField -eq 3) { "‚Üí" } else { " " }
        $dueDateValue = if ($this.EditingField -and $this.CurrentField -eq 3) { 
            $this.TaskDueDate + "_" 
        } else { 
            if ([string]::IsNullOrWhiteSpace($this.TaskDueDate)) { "<YYYY-MM-DD>" } else { $this.TaskDueDate }
        }
        $formContent += "$dueDateIndicator Due Date:    $dueDateValue"
        
        # Project field
        $projectIndicator = if ($this.CurrentField -eq 4) { "‚Üí" } else { " " }
        $projects = @($this.Services.DataManager.GetProjects())
        $projectDisplay = if ($this.ProjectId) {
            $proj = $projects | Where-Object { $_.Id -eq $this.ProjectId } | Select-Object -First 1
            if ($proj) { $proj.Name } else { "<None>" }
        } else { "<None>" }
        $formContent += "$projectIndicator Project:     $projectDisplay"
        
        # Add some spacing
        $formContent += ""
        $formContent += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        # Validation messages
        if (-not [string]::IsNullOrWhiteSpace($this.TaskTitle)) {
            $formContent += "‚úì Title is valid"
        } else {
            $formContent += "! Title is required"
        }
        
        $this.FormPanel.SetContent($formContent)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "NewTaskScreen" -Context "HandleInput" -ScriptBlock {
            if ($this.EditingField) {
                # Handle text input for current field
                $this.HandleFieldInput($key)
            } else {
                # Handle navigation
                switch ($key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($this.CurrentField -gt 0) {
                            $this.CurrentField--
                            $this.UpdateFormDisplay()
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($this.CurrentField -lt ($this.TotalFields - 1)) {
                            $this.CurrentField++
                            $this.UpdateFormDisplay()
                        }
                    }
                    ([ConsoleKey]::Tab) {
                        $this.CurrentField = ($this.CurrentField + 1) % $this.TotalFields
                        $this.UpdateFormDisplay()
                    }
                    ([ConsoleKey]::Enter) {
                        if ($this.CurrentField -eq 2) {
                            # Cycle priority
                            $this.CyclePriority()
                        } elseif ($this.CurrentField -eq 4) {
                            # Cycle project
                            $this.CycleProject()
                        } else {
                            # Start editing text field
                            $this.EditingField = $true
                        }
                        $this.UpdateFormDisplay()
                    }
                    ([ConsoleKey]::Escape) {
                        # Cancel and go back
                        $this.Services.Navigation.PopScreen()
                    }
                    default {
                        # Handle character keys
                        $char = [char]$key.KeyChar
                        switch ($char.ToString().ToUpper()) {
                            'S' { 
                                # Save task
                                $this.SaveTask()
                            }
                            'C' {
                                # Clear form
                                $this.ClearForm()
                                $this.UpdateFormDisplay()
                            }
                        }
                    }
                }
            }
        }
    }
    
    hidden [void] HandleFieldInput([ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([ConsoleKey]::Enter) {
                # Stop editing
                $this.EditingField = $false
            }
            ([ConsoleKey]::Escape) {
                # Cancel editing
                $this.EditingField = $false
            }
            ([ConsoleKey]::Backspace) {
                # Remove last character
                switch ($this.CurrentField) {
                    0 { # Title
                        if ($this.TaskTitle.Length -gt 0) {
                            $this.TaskTitle = $this.TaskTitle.Substring(0, $this.TaskTitle.Length - 1)
                        }
                    }
                    1 { # Description
                        if ($this.TaskDescription.Length -gt 0) {
                            $this.TaskDescription = $this.TaskDescription.Substring(0, $this.TaskDescription.Length - 1)
                        }
                    }
                    3 { # Due date
                        if ($this.TaskDueDate.Length -gt 0) {
                            $this.TaskDueDate = $this.TaskDueDate.Substring(0, $this.TaskDueDate.Length - 1)
                        }
                    }
                }
            }
            default {
                # Add character
                if ($key.KeyChar -ge 32 -and $key.KeyChar -le 126) {
                    switch ($this.CurrentField) {
                        0 { # Title
                            if ($this.TaskTitle.Length -lt 100) {
                                $this.TaskTitle += $key.KeyChar
                            }
                        }
                        1 { # Description
                            if ($this.TaskDescription.Length -lt 500) {
                                $this.TaskDescription += $key.KeyChar
                            }
                        }
                        3 { # Due date
                            if ($this.TaskDueDate.Length -lt 10) {
                                $this.TaskDueDate += $key.KeyChar
                            }
                        }
                    }
                }
            }
        }
        
        $this.UpdateFormDisplay()
    }
    
    hidden [void] CyclePriority() {
        switch ($this.TaskPriority) {
            ([TaskPriority]::Low) { $this.TaskPriority = [TaskPriority]::Medium }
            ([TaskPriority]::Medium) { $this.TaskPriority = [TaskPriority]::High }
            ([TaskPriority]::High) { $this.TaskPriority = [TaskPriority]::Critical }
            ([TaskPriority]::Critical) { $this.TaskPriority = [TaskPriority]::Low }
        }
    }
    
    hidden [void] CycleProject() {
        $projects = @($this.Services.DataManager.GetProjects())
        if ($projects.Count -eq 0) {
            $this.ProjectId = ""
            return
        }
        
        if ([string]::IsNullOrWhiteSpace($this.ProjectId)) {
            $this.ProjectId = $projects[0].Id
        } else {
            $currentIndex = -1
            for ($i = 0; $i -lt $projects.Count; $i++) {
                if ($projects[$i].Id -eq $this.ProjectId) {
                    $currentIndex = $i
                    break
                }
            }
            
            if ($currentIndex -eq -1 -or $currentIndex -eq ($projects.Count - 1)) {
                $this.ProjectId = ""
            } else {
                $this.ProjectId = $projects[$currentIndex + 1].Id
            }
        }
    }
    
    hidden [void] SaveTask() {
        # Validate required fields
        if ([string]::IsNullOrWhiteSpace($this.TaskTitle)) {
            Write-Log -Level Warning -Message "Cannot save task without title" -Component "NewTaskScreen"
            return
        }
        
        try {
            # Create new task
            $task = [Task]::new($this.TaskTitle, $this.TaskDescription)
            $task.Priority = $this.TaskPriority
            
            # Parse and set due date
            if (-not [string]::IsNullOrWhiteSpace($this.TaskDueDate)) {
                try {
                    $task.DueDate = [DateTime]::ParseExact($this.TaskDueDate, "yyyy-MM-dd", $null)
                } catch {
                    Write-Log -Level Warning -Message "Invalid date format: $($this.TaskDueDate)" -Component "NewTaskScreen"
                }
            }
            
            # Set project
            if (-not [string]::IsNullOrWhiteSpace($this.ProjectId)) {
                $task.ProjectId = $this.ProjectId
            }
            
            # Save task
            $this.Services.DataManager.AddTask($task)
            
            Write-Log -Level Info -Message "Task created successfully: $($task.Title)" -Component "NewTaskScreen"
            
            # Navigate back
            $this.Services.Navigation.PopScreen()
        }
        catch {
            Write-Log -Level Error -Message "Failed to create task: $_" -Component "NewTaskScreen"
        }
    }
    
    hidden [void] ClearForm() {
        $this.TaskTitle = ""
        $this.TaskDescription = ""
        $this.TaskPriority = [TaskPriority]::Medium
        $this.TaskDueDate = ""
        $this.ProjectId = ""
        $this.CurrentField = 0
        $this.EditingField = $false
    }
    
    [void] Cleanup() {
        Write-Log -Level Info -Message "Cleaning up NewTaskScreen" -Component "NewTaskScreen"
        
        # Call base cleanup
        ([Screen]$this).Cleanup()
    }
}

# Export the class
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *



####\screens\simple-test-screen.psm1
# Simple Test Screen - Basic test screen for development and debugging
# Provides a minimal screen implementation for testing the TUI framework

using module '..\modules\models.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Get-SimpleTestScreen {
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Services
    )
    
    Invoke-WithErrorHandling -Component "SimpleTestScreen.Factory" -Context "Creating Simple Test Screen" -ScriptBlock {
        # Validate services parameter
        if (-not $Services) {
            throw "Services parameter is required for simple test screen"
        }
        
        $screen = @{
            Name = "SimpleTestScreen"
            Components = @{}
            Children = @()
            _services = $Services
            Visible = $true
            ZIndex = 0
            
            Init = {
                param($self)
                
                Invoke-WithErrorHandling -Component "SimpleTestScreen.Init" -Context "Initializing Simple Test Screen" -ScriptBlock {
                    Write-Log -Level Info -Message "Simple Test Screen Init: Starting initialization"
                    
                    # Create root panel
                    $rootPanel = New-TuiStackPanel -Props @{
                        Name = "SimpleTestRoot"
                        X = 2
                        Y = 2
                        Width = [Math]::Max(60, ($global:TuiState.BufferWidth - 4))
                        Height = [Math]::Max(20, ($global:TuiState.BufferHeight - 4))
                        ShowBorder = $true
                        Title = " Simple Test Screen "
                        Orientation = "Vertical"
                        Spacing = 1
                        Padding = 2
                    }
                    
                    # Add test content
                    $welcomeLabel = New-TuiTextBlock -Props @{
                        Text = "This is a simple test screen for verifying the TUI framework."
                        Width = "100%"
                    }
                    
                    $instructionLabel = New-TuiTextBlock -Props @{
                        Text = "Press ESC to return to the main menu."
                        Width = "100%"
                        Margin = @{ Top = 2 }
                    }
                    
                    $statusLabel = New-TuiTextBlock -Props @{
                        Text = "Screen loaded successfully!"
                        Width = "100%"
                        Margin = @{ Top = 1 }
                    }
                    
                    & $rootPanel.AddChild -self $rootPanel -Child $welcomeLabel
                    & $rootPanel.AddChild -self $rootPanel -Child $instructionLabel
                    & $rootPanel.AddChild -self $rootPanel -Child $statusLabel
                    
                    # Store references
                    $self.Components.rootPanel = $rootPanel
                    $self.Children = @($rootPanel)
                    
                    Write-Log -Level Info -Message "Simple Test Screen Init: Completed successfully"
                }
            }
            
            HandleInput = {
                param($self, $key)
                
                if (-not $key) { return $false }
                
                Invoke-WithErrorHandling -Component "SimpleTestScreen.HandleInput" -Context "Handling user input" -ScriptBlock {
                    if ($key.Key -eq "Escape") {
                        & $self._services.Navigation.GoTo -self $self._services.Navigation -Path "/dashboard" -Services $self._services
                        return $true
                    }
                    
                    return $false
                }
            }
            
            OnEnter = {
                param($self)
                Write-Log -Level Info -Message "Simple Test Screen OnEnter"
                Request-TuiRefresh
            }
            
            OnExit = {
                param($self)
                Write-Log -Level Info -Message "Simple Test Screen OnExit: Cleaning up"
            }
            
            Render = {
                param($self)
                # The panel handles its own rendering
            }
        }
        
        return $screen
    }
}

Export-ModuleMember -Function Get-SimpleTestScreen


####\screens\task-list-screen-class.psm1
# Task List Screen Class Implementation
# Provides task listing and management functionality
# AI: MVP implementation for task list screen following class-based architecture

using namespace System.Collections.Generic

# Import base classes
using module ..\components\ui-classes.psm1
using module ..\components\panel-classes.psm1
using module ..\components\table-class.psm1

# Import utilities
Import-Module "$PSScriptRoot\..\utilities\error-handling.psm1" -Force
Import-Module "$PSScriptRoot\..\utilities\event-system.psm1" -Force

class TaskListScreen : Screen {
    # UI Components
    [BorderPanel] $MainPanel
    [ContentPanel] $HeaderPanel
    [Table] $TaskTable
    [BorderPanel] $NavigationPanel
    
    # State
    [object[]] $Tasks = @()
    [string] $FilterStatus = "All"  # All, Active, Completed
    
    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) {
        Write-Log -Level Info -Message "Creating TaskListScreen instance" -Component "TaskListScreen"
    }
    
    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            Write-Log -Level Info -Message "Initializing TaskListScreen" -Component "TaskListScreen"
            
            # Create main container panel
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.MainPanel.BorderStyle = "Double"
            $this.AddPanel($this.MainPanel)
            
            # Create header panel
            $this.HeaderPanel = [ContentPanel]::new("TaskListHeader", 2, 2, 116, 3)
            $this.MainPanel.AddChild($this.HeaderPanel)
            
            # Create task table
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15),
                [TableColumn]::new("Project", "Project", 20)
            ))
            
            # Position table panel
            $tablePanel = [ContentPanel]::new("TableContainer", 2, 6, 116, 18)
            $this.MainPanel.AddChild($tablePanel)
            
            # Create navigation panel
            $this.NavigationPanel = [BorderPanel]::new("TaskListNav", 2, 25, 116, 4)
            $this.NavigationPanel.Title = "Actions"
            $this.NavigationPanel.BorderStyle = "Single"
            $this.MainPanel.AddChild($this.NavigationPanel)
            
            # Initialize navigation content
            $this.InitializeNavigation()
            
            # Subscribe to events
            $this.SubscribeToEvents()
            
            # Load initial data
            $this.RefreshData()
            
            Write-Log -Level Info -Message "TaskListScreen initialized successfully" -Component "TaskListScreen"
        }
    }
    
    hidden [void] InitializeNavigation() {
        $navContent = @(
            "[N] New Task    [E] Edit Task    [D] Delete Task    [Space] Toggle Complete",
            "[F] Filter: $($this.FilterStatus)    [S] Sort    [R] Refresh    [Esc] Back to Dashboard"
        )
        
        $navPanel = [ContentPanel]::new("NavContent", 3, 26, 114, 2)
        $navPanel.SetContent($navContent)
        $this.NavigationPanel.AddChild($navPanel)
    }
    
    hidden [void] SubscribeToEvents() {
        # Subscribe to task changes
        $this.SubscribeToEvent("Tasks.Changed", {
            param($eventArgs)
            $this.RefreshData()
        })
        
        Write-Log -Level Debug -Message "TaskListScreen subscribed to events" -Component "TaskListScreen"
    }
    
    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            Write-Log -Level Debug -Message "Refreshing task list data" -Component "TaskListScreen"
            
            # Get data from services
            if ($null -ne $this.Services -and $null -ne $this.Services.DataManager) {
                $allTasks = @($this.Services.DataManager.GetTasks())
                
                # Apply filter
                switch ($this.FilterStatus) {
                    "Active" {
                        $this.Tasks = @($allTasks | Where-Object { $_.Status -eq "Active" })
                    }
                    "Completed" {
                        $this.Tasks = @($allTasks | Where-Object { $_.Status -eq "Completed" })
                    }
                    default {
                        $this.Tasks = $allTasks
                    }
                }
                
                # Update header
                $this.UpdateHeader()
                
                # Update table data
                $this.UpdateTaskTable()
                
                # Update navigation
                $this.InitializeNavigation()
            } else {
                Write-Log -Level Warning -Message "DataManager service not available" -Component "TaskListScreen"
            }
        }
    }
    
    hidden [void] UpdateHeader() {
        $totalCount = $this.Tasks.Count
        $activeCount = @($this.Tasks | Where-Object { $_.Status -eq "Active" }).Count
        
        $headerContent = @(
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
            "  Showing: $($this.FilterStatus) Tasks  |  Total: $totalCount  |  Active: $activeCount  |  Completed: $($totalCount - $activeCount)",
            "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
        
        $this.HeaderPanel.SetContent($headerContent)
    }
    
    hidden [void] UpdateTaskTable() {
        # Prepare data for table
        $tableData = @()
        
        foreach ($task in $this.Tasks) {
            $project = if ($task.ProjectId) {
                $proj = $this.Services.DataManager.GetProject($task.ProjectId)
                if ($proj) { $proj.Name } else { "" }
            } else { "" }
            
            $tableData += @{
                Title = $task.Title
                Status = $task.Status
                Priority = $task.Priority
                DueDate = if ($task.DueDate) { $task.DueDate.ToString("yyyy-MM-dd") } else { "" }
                Project = $project
                _Task = $task  # Store reference to original task
            }
        }
        
        $this.TaskTable.SetData($tableData)
    }
    
    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($this.TaskTable.SelectedIndex -gt 0) {
                        $this.TaskTable.SelectedIndex--
                        $this.UpdateTaskTable()
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($this.TaskTable.SelectedIndex -lt ($this.TaskTable.Data.Count - 1)) {
                        $this.TaskTable.SelectedIndex++
                        $this.UpdateTaskTable()
                    }
                }
                ([ConsoleKey]::Spacebar) {
                    # Toggle task complete
                    if ($this.TaskTable.Data.Count -gt 0 -and $this.TaskTable.SelectedIndex -ge 0) {
                        $selectedData = $this.TaskTable.Data[$this.TaskTable.SelectedIndex]
                        $task = $selectedData._Task
                        
                        if ($task.Status -eq "Completed") {
                            $task.Status = "Active"
                            $task.CompletedDate = $null
                        } else {
                            $task.Complete()
                        }
                        
                        $this.Services.DataManager.UpdateTask($task)
                    }
                }
                ([ConsoleKey]::Escape) {
                    # Go back to dashboard
                    $this.Services.Navigation.PopScreen()
                }
                default {
                    # Handle character keys
                    $char = [char]$key.KeyChar
                    switch ($char.ToString().ToUpper()) {
                        'N' { 
                            # Navigate to new task screen
                            $this.Services.Navigation.PushScreen("NewTaskScreen") 
                        }
                        'E' { 
                            # Edit selected task
                            if ($this.TaskTable.Data.Count -gt 0 -and $this.TaskTable.SelectedIndex -ge 0) {
                                $selectedData = $this.TaskTable.Data[$this.TaskTable.SelectedIndex]
                                $task = $selectedData._Task
                                $this.Services.Navigation.PushScreen("EditTaskScreen", @{TaskId = $task.Id})
                            }
                        }
                        'D' { 
                            # Delete selected task
                            if ($this.TaskTable.Data.Count -gt 0 -and $this.TaskTable.SelectedIndex -ge 0) {
                                $selectedData = $this.TaskTable.Data[$this.TaskTable.SelectedIndex]
                                $task = $selectedData._Task
                                $this.Services.DataManager.DeleteTask($task.Id)
                            }
                        }
                        'F' {
                            # Cycle through filters
                            switch ($this.FilterStatus) {
                                "All" { $this.FilterStatus = "Active" }
                                "Active" { $this.FilterStatus = "Completed" }
                                "Completed" { $this.FilterStatus = "All" }
                            }
                            $this.RefreshData()
                        }
                        'R' { 
                            # Refresh
                            $this.RefreshData() 
                        }
                    }
                }
            }
        }
    }
    
    [void] Cleanup() {
        Write-Log -Level Info -Message "Cleaning up TaskListScreen" -Component "TaskListScreen"
        
        # Call base cleanup
        ([Screen]$this).Cleanup()
    }
}

# Export the class
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *



####\screens\task-screen.psm1
#
# FILE: screens/task-screen.psm1
# PURPOSE: Task Screen Module - Refactored for Service-Oriented Architecture
# AI: This file has been corrected to use the proper DataTable component and its corresponding methods.
#

using module '..\modules\models.psm1'
using module '..\components\advanced-data-components.psm1' # AI: Added required module for New-TuiDataTable

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Get-TaskManagementScreen {
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Services
    )
    
    Invoke-WithErrorHandling -ScriptBlock {
        # Validate services parameter
        if (-not $Services) {
            throw "Services parameter is required for task management screen"
        }
        
        if (-not $Services.DataManager) {
            throw "DataManager service is required but not found in services"
        }
        
        $screen = @{
            Name = "TaskManagementScreen"
            Components = @{}
            Children = @()
            _subscriptions = @()
            _services = $Services
            _formMode = $null  # null = list view, "create" = new task, "edit" = edit task
            _selectedTask = $null
            _focusIndex = 0
            _formFocusableComponents = @()
            Visible = $true
            ZIndex = 0
            
            Init = {
                param($self)
                
                Invoke-WithErrorHandling -ScriptBlock {
                    $services = $self._services
                    Write-Log -Level Info -Message "Task Screen Init: Starting initialization" -Data @{ Component = "TaskScreen.Init" }
                    
                    # Create root panel
                    $rootPanel = New-TuiStackPanel -Props @{
                        Name = "TaskScreenRoot"
                        Orientation = "Vertical"
                        Width = $global:TuiState.BufferWidth
                        Height = $global:TuiState.BufferHeight
                    }
                    
                    # Create list view panel
                    $listPanel = New-TuiStackPanel -Props @{
                        Name = "TaskListView"
                        Orientation = "Vertical"
                        Width = "100%"
                        Height = "100%"
                        Visible = $true
                    }
                    
                    # Create header for list view
                    $headerPanel = New-TuiStackPanel -Props @{
                        Orientation = "Horizontal"
                        Width = "100%"
                        Height = 3
                        Padding = 1
                    }
                    
                    $titleLabel = New-TuiLabel -Props @{
                        Text = " Task Management "
                    }
                    
                    $actionsLabel = New-TuiLabel -Props @{
                        Text = "[N]ew  [E]dit  [D]elete  [Space]Toggle  [Esc]Back"
                    }
                    
                    & $headerPanel.AddChild -self $headerPanel -Child $titleLabel
                    & $headerPanel.AddChild -self $headerPanel -Child $actionsLabel
                    & $listPanel.AddChild -self $listPanel -Child $headerPanel
                    
                    # AI: Corrected to use New-TuiDataTable and fixed column definitions
                    $taskTable = New-TuiDataTable -Props @{
                        Name = "TaskTable"
                        Width = "100%"
                        Height = $global:TuiState.BufferHeight - 5
                        Columns = @(
                            @{ Header = "‚úì"; Name = "Status"; Width = 3; Align = "Center"; Format = { param($value, $row) if ($row.Completed) { "‚úì" } else { "‚óã" } } }
                            @{ Header = "Title"; Name = "Title"; Width = 40 }
                            @{ Header = "Priority"; Name = "Priority"; Width = 10 }
                            @{ Header = "Category"; Name = "Category"; Width = 20 }
                            @{ Header = "Due Date"; Name = "DueDate"; Width = 12; Format = { param($value) if ($value) { $value.ToString("yyyy-MM-dd") } else { "N/A" } } }
                        )
                        Data = @()
                        ShowHeader = $true
                        IsFocusable = $true
                    }
                    
                    & $listPanel.AddChild -self $listPanel -Child $taskTable
                    & $rootPanel.AddChild -self $rootPanel -Child $listPanel
                    
                    # Create form view panel (initially hidden)
                    $formPanel = New-TuiStackPanel -Props @{
                        Name = "TaskFormView"
                        Orientation = "Vertical"
                        Width = "100%"
                        Height = "100%"
                        Visible = $false
                        Padding = 2
                        ShowBorder = $true
                    }
                    
                    # Form title is set dynamically
                    
                    # Create form fields
                    $titleInput = New-TuiTextBox -Props @{ Name = "TitleInput"; Width = 50; IsFocusable = $true }
                    $descInput = New-TuiTextArea -Props @{ Name = "DescInput"; Width = 50; Height = 5; IsFocusable = $true }
                    $priorityDropdown = New-TuiDropdown -Props @{ Name = "PriorityDropdown"; Width = 20; Options = @(@{Display="Low";Value="low"},@{Display="Medium";Value="medium"},@{Display="High";Value="high"}); Value = "medium"; IsFocusable = $true }
                    $categoryInput = New-TuiTextBox -Props @{ Name = "CategoryInput"; Width = 50; Text = "General"; IsFocusable = $true }
                    $dueDateInput = New-TuiTextBox -Props @{ Name = "DueDateInput"; Width = 20; Placeholder = "yyyy-MM-dd"; IsFocusable = $true }
                    
                    # Form buttons
                    $buttonPanel = New-TuiStackPanel -Props @{ Orientation = "Horizontal"; Width = "100%"; Height = 3; Spacing = 2; Margin = 1 }
                    
                    $capturedSelf = $self
                    
                    $saveButton = New-TuiButton -Props @{ Text = "[S]ave"; IsFocusable = $true; OnClick = { & $capturedSelf.SaveTask -self $capturedSelf } }
                    $cancelButton = New-TuiButton -Props @{ Text = "[C]ancel"; IsFocusable = $true; OnClick = { & $capturedSelf.ShowListView -self $capturedSelf } }
                    
                    & $buttonPanel.AddChild -self $buttonPanel -Child $saveButton
                    & $buttonPanel.AddChild -self $buttonPanel -Child $cancelButton
                    
                    # Add all form fields to form panel
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Title:" })
                    & $formPanel.AddChild -self $formPanel -Child $titleInput
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Description:" })
                    & $formPanel.AddChild -self $formPanel -Child $descInput
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Priority:" })
                    & $formPanel.AddChild -self $formPanel -Child $priorityDropdown
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Category:" })
                    & $formPanel.AddChild -self $formPanel -Child $categoryInput
                    & $formPanel.AddChild -self $formPanel -Child (New-TuiLabel -Props @{ Text = "Due Date:" })
                    & $formPanel.AddChild -self $formPanel -Child $dueDateInput
                    & $formPanel.AddChild -self $formPanel -Child $buttonPanel
                    
                    & $rootPanel.AddChild -self $rootPanel -Child $formPanel
                    
                    # Store component references
                    $self.Components.rootPanel = $rootPanel
                    $self.Components.listPanel = $listPanel
                    $self.Components.formPanel = $formPanel
                    $self.Components.taskTable = $taskTable
                    $self.Components.titleInput = $titleInput
                    $self.Components.descInput = $descInput
                    $self.Components.priorityDropdown = $priorityDropdown
                    $self.Components.categoryInput = $categoryInput
                    $self.Components.dueDateInput = $dueDateInput
                    $self.Components.saveButton = $saveButton
                    $self.Components.cancelButton = $cancelButton
                    
                    $self._formFocusableComponents = @($titleInput, $descInput, $priorityDropdown, $categoryInput, $dueDateInput, $saveButton, $cancelButton)
                    
                    # Helper functions
                    $self.ShowListView = {
                        param($self)
                        $self._formMode = $null
                        $self._selectedTask = $null
                        $self._focusIndex = 0
                        $self.Components.listPanel.Visible = $true
                        $self.Components.formPanel.Visible = $false
                        Request-Focus -Component $self.Components.taskTable
                        Request-TuiRefresh
                    }
                    
                    $self.ShowFormView = {
                        param($self, $mode, $task)
                        $self._formMode = $mode
                        $self._selectedTask = $task
                        $self._focusIndex = 0
                        
                        $self.Components.formPanel.Title = if ($mode -eq "create") { " New Task " } else { " Edit Task " }
                        
                        if ($mode -eq "create") {
                            $self.Components.titleInput.Text = ""
                            $self.Components.descInput.Text = ""
                            $self.Components.priorityDropdown.Value = "medium"
                            $self.Components.categoryInput.Text = "General"
                            $self.Components.dueDateInput.Text = ""
                        } elseif ($task) {
                            $self.Components.titleInput.Text = $task.Title
                            $self.Components.descInput.Text = $task.Description
                            $self.Components.priorityDropdown.Value = $task.Priority.ToString().ToLower()
                            $self.Components.categoryInput.Text = $task.Category
                            $self.Components.dueDateInput.Text = if ($task.DueDate) { $task.DueDate.ToString('yyyy-MM-dd') } else { '' }
                        }
                        
                        $self.Components.listPanel.Visible = $false
                        $self.Components.formPanel.Visible = $true
                        Request-Focus -Component $self.Components.titleInput
                        Request-TuiRefresh
                    }
                    
                    $self.SaveTask = {
                        param($self)
                        Invoke-WithErrorHandling -ScriptBlock {
                            $title = $self.Components.titleInput.Text
                            if ([string]::IsNullOrWhiteSpace($title)) {
                                Show-AlertDialog -Title "Validation Error" -Message "Title is required"
                                return
                            }
                            
                            $taskData = @{
                                Title = $title.Trim()
                                Description = $self.Components.descInput.Text
                                Priority = $self.Components.priorityDropdown.Value
                                Category = $self.Components.categoryInput.Text
                                DueDate = $self.Components.dueDateInput.Text
                            }
                            
                            if ($self._formMode -eq "create") {
                                & $self._services.DataManager.AddTask @taskData
                            } elseif ($self._formMode -eq "edit" -and $self._selectedTask) {
                                & $self._services.DataManager.UpdateTask -Task $self._selectedTask @taskData
                            }
                            
                            & $self.ShowListView -self $self
                        } -Component "TaskScreen.SaveTask" -Context "Saving task data"
                    }
                    
                    $self.RefreshTaskList = {
                        param($self)
                        Invoke-WithErrorHandling -ScriptBlock {
                            $tasks = if ($global:Data -and $global:Data.Tasks) { $global:Data.Tasks } else { @() }
                            $self.Components.taskTable.Data = $tasks
                            & $self.Components.taskTable.ProcessData -self $self.Components.taskTable
                            Request-TuiRefresh
                        } -Component "TaskScreen.RefreshTaskList" -Context "Refreshing task list from global data"
                    }
                    
                    $subscriptionId = Subscribe-Event -EventName "Tasks.Changed" -Handler { & $self.RefreshTaskList -self $self } -Source "TaskManagementScreen"
                    $self._subscriptions += $subscriptionId
                    
                    & $self.RefreshTaskList -self $self
                    $self.Children = @($rootPanel)
                    Request-Focus -Component $taskTable
                } -Component "TaskScreen.Init" -Context "Initializing Task Screen"
            }
            
            HandleInput = {
                param($self, $key)
                
                if (-not $key) { return $false }
                
                Invoke-WithErrorHandling -ScriptBlock {
                    if ($self._formMode) {
                        # AI: Form input handling
                        if ($key.Key -eq "Tab") {
                            $direction = if ($key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                            $self._focusIndex = ($self._focusIndex + $direction + $self._formFocusableComponents.Count) % $self._formFocusableComponents.Count
                            Request-Focus -Component $self._formFocusableComponents[$self._focusIndex]
                            return $true
                        }
                        
                        $focusedComponent = $self._formFocusableComponents[$self._focusIndex]
                        if ($focusedComponent.HandleInput) {
                            return & $focusedComponent.HandleInput -self $focusedComponent -key $key
                        }
                    }
                    else {
                        # AI: List view input handling, simplified with a switch
                        switch -CaseSensitive ($key.KeyChar) {
                            'n' { & $self.ShowFormView -self $self -mode "create"; return $true }
                            'e' {
                                # AI: Corrected way to get selected data
                                $table = $self.Components.taskTable
                                $selectedTask = if ($table.ProcessedData.Count -gt 0) { $table.ProcessedData[$table.SelectedRow] } else { $null }
                                if ($selectedTask) { & $self.ShowFormView -self $self -mode "edit" -task $selectedTask }
                                return $true
                            }
                            'd' {
                                $table = $self.Components.taskTable
                                $selectedTask = if ($table.ProcessedData.Count -gt 0) { $table.ProcessedData[$table.SelectedRow] } else { $null }
                                if ($selectedTask) { & $self._services.DataManager.RemoveTask -Task $selectedTask }
                                return $true
                            }
                        }

                        if ($key.Key -eq "Spacebar") {
                            $table = $self.Components.taskTable
                            $selectedTask = if ($table.ProcessedData.Count -gt 0) { $table.ProcessedData[$table.SelectedRow] } else { $null }
                            if ($selectedTask) {
                                & $self._services.DataManager.UpdateTask -Task $selectedTask -Completed (-not $selectedTask.Completed)
                            }
                            return $true
                        }
                        
                        if ($key.Key -eq "Escape") {
                            & $self._services.Navigation.GoTo -self $self._services.Navigation -Path "/dashboard" -Services $self._services
                            return $true
                        }
                        
                        # Pass other keys to the task table
                        if ($self.Components.taskTable.HandleInput) {
                            return & $self.Components.taskTable.HandleInput -self $self.Components.taskTable -key $key
                        }
                    }
                    
                    return $false
                } -Component "TaskScreen.HandleInput" -Context "Handling user input"
            }
            
            OnExit = {
                param($self)
                Invoke-WithErrorHandling -ScriptBlock {
                    foreach ($subId in $self._subscriptions) {
                        if ($subId) { Unsubscribe-Event -HandlerId $subId }
                    }
                    $self._subscriptions = @()
                    $self.Components = @{}
                    $self._formFocusableComponents = @()
                    Write-Log -Level Info -Message "Task Screen cleanup completed" -Data @{ Component = "TaskScreen.OnExit" }
                } -Component "TaskScreen.OnExit" -Context "Cleaning up Task Screen"
            }
        }
        
        return $screen
    } -Component "TaskScreen.Factory" -Context "Creating Task Management Screen"
}

# Alias for backward compatibility if needed
function Get-TaskScreen {
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Services
    )
    return Get-TaskManagementScreen -Services $Services
}

Export-ModuleMember -Function @('Get-TaskManagementScreen', 'Get-TaskScreen')


####\services\app-store.psm1
# FILE: services/app-store.psm1
# PURPOSE: Provides a single, reactive source of truth for all shared application state using a Redux-like pattern.

function Initialize-AppStore {
    param(
        [hashtable]$InitialData = @{},
        [bool]$EnableDebugLogging = $false
    )
    
    # Initialize state structure properly
    $stateData = if ($InitialData) { $InitialData.Clone() } else { @{} }
    
    $store = @{
        _state = @{
            _data = $stateData
            _subscribers = @{}
            _changeQueue = @()
        }
        _actions = @{}
        _middleware = @()
        _history = @()  # For time-travel debugging
        _enableDebugLogging = $EnableDebugLogging
        
        GetState = { 
            param($self, [string]$path = $null) 
            if ([string]::IsNullOrEmpty($path)) {
                # Directly access state data
                return $self._state._data
            }
            # Navigate path manually
            $parts = $path -split '\.'
            $current = $self._state._data
            foreach ($part in $parts) {
                if ($null -eq $current) { return $null }
                $current = $current[$part]
            }
            return $current
        }
        
        Subscribe = { 
            param($self, [string]$path, [scriptblock]$handler, [bool]$DeferInitialCall = $false) 
            if (-not $handler) { throw "Handler scriptblock is required for Subscribe" }
            
            # Manually implement subscribe to avoid $this issues
            $state = $self._state
            $subId = [Guid]::NewGuid().ToString()
            
            if (-not $state._subscribers) { $state._subscribers = @{} }
            if (-not $state._subscribers.ContainsKey($path)) {
                $state._subscribers[$path] = @()
            }
            
            $state._subscribers[$path] += @{
                Id = $subId
                Handler = $handler
            }
            
            # Call handler with current value unless deferred
            if (-not $DeferInitialCall) {
                $currentValue = & $self.GetState -self $self -path $path
                try {
                    & $handler @{ NewValue = $currentValue; OldValue = $null; Path = $path }
                } catch {
                    Write-Warning "State subscriber error: $_"
                }
            }
            
            return $subId
        }
        
        Unsubscribe = { 
            param($self, $subId) 
            if ($subId -and $self._state._subscribers) {
                # Manually remove subscription
                foreach ($path in @($self._state._subscribers.Keys)) {
                    $self._state._subscribers[$path] = @($self._state._subscribers[$path] | Where-Object { $_.Id -ne $subId })
                    if ($self._state._subscribers[$path].Count -eq 0) {
                        $self._state._subscribers.Remove($path)
                    }
                }
            }
        }
        
        RegisterAction = { 
            param($self, [string]$actionName, [scriptblock]$scriptBlock) 
            if ([string]::IsNullOrWhiteSpace($actionName)) { throw "Action name cannot be empty" }
            if (-not $scriptBlock) { throw "Script block is required for action '$actionName'" }
            $self._actions[$actionName] = $scriptBlock 
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Registered action: $actionName" }
        }
        
        AddMiddleware = {
            param($self, [scriptblock]$middleware)
            $self._middleware += $middleware
        }
        
        Dispatch = {
            param($self, [string]$actionName, $payload = $null)
            
            if ([string]::IsNullOrWhiteSpace($actionName)) { return @{ Success = $false; Error = "Action name cannot be empty" } }
            
            $action = @{ Type = $actionName; Payload = $payload; Timestamp = [DateTime]::UtcNow }
            
            foreach ($mw in $self._middleware) {
                if ($null -ne $mw) {
                    $action = & $mw -Action $action -Store $self
                    if (-not $action) { return @{ Success = $false; Error = "Action cancelled by middleware" } }
                }
            }
            
            if (-not $self._actions.ContainsKey($actionName)) {
                if ($self._enableDebugLogging) { Write-Log -Level Warning -Message "Action '$actionName' not found." }
                return @{ Success = $false; Error = "Action '$actionName' not registered." }
            }
            
            if ($self._enableDebugLogging) { Write-Log -Level Debug -Message "Dispatching action '$actionName'" -Data $payload }
            
            try {
                $previousState = & $self.GetState -self $self
                
                # Create action context with fixed UpdateState
                $storeInstance = $self
                $actionContext = @{
                    GetState = { 
                        param($path = $null) 
                        $store = $storeInstance
                        if ($path) {
                            return & $store.GetState -self $store -path $path
                        } else {
                            return & $store.GetState -self $store
                        }
                    }.GetNewClosure()
                    
                    UpdateState = { 
                        param($updates) 
                        $store = $storeInstance
                        if (-not $updates -or $updates.Count -eq 0) { 
                            Write-Log -Level Debug -Message "UpdateState called with empty updates"
                            return 
                        }
                        
                        Write-Log -Level Debug -Message "UpdateState called with keys: $($updates.Keys -join ', ')"
                        
                        # Use direct update method that handles all the complexity
                        try {
                            & $store._directUpdateState -self $store -updates $updates
                            Write-Log -Level Debug -Message "UpdateState: Successfully updated state"
                        } catch {
                            Write-Log -Level Error -Message "UpdateState failed: $_"
                            throw
                        }
                    }.GetNewClosure()
                    
                    Dispatch = { 
                        param($name, $p = $null) 
                        $store = $storeInstance
                        return & $store.Dispatch -self $store -actionName $name -payload $p
                    }.GetNewClosure()
                }
                
                # Execute the action
                & $self._actions[$actionName] -Context $actionContext -Payload $payload
                
                # Update history
                if ($self._history.Count -gt 100) { $self._history = $self._history[-100..-1] }
                $self._history += @{ Action = $action; PreviousState = $previousState; NextState = (& $self.GetState -self $self) }
                
                return @{ Success = $true }
            } 
            catch {
                # Use PowerShell RuntimeException with attached context data to avoid type dependency issues
                $contextData = @{
                    ActionName = $actionName
                    Payload = $payload
                    OriginalException = $_.Exception.Message
                    Component = "AppStore"
                    OperationName = "Dispatch"
                    Timestamp = [DateTime]::UtcNow
                }
                
                $runtimeException = New-Object System.Management.Automation.RuntimeException("Error executing action '$actionName': $($_.Exception.Message)")
                $runtimeException.Data.Add("HeliosException", $contextData)
                
                if ($self._enableDebugLogging) { 
                    Write-Log -Level Error -Message "Action dispatch failed" -Data $contextData 
                }
                
                throw $runtimeException
            }
        }
        
        _updateState = { 
            param($self, [hashtable]$updates)
            if ($updates -and $self._state) {
                # Direct update implementation
                $state = $self._state
                foreach ($key in $updates.Keys) {
                    $oldValue = $state._data[$key]
                    $state._data[$key] = $updates[$key]
                    
                    if ($oldValue -ne $updates[$key] -and $state._subscribers -and $state._subscribers.ContainsKey($key)) {
                        foreach ($sub in $state._subscribers[$key]) {
                            try {
                                & $sub.Handler @{ NewValue = $updates[$key]; OldValue = $oldValue; Path = $key }
                            } catch {
                                Write-Warning "State notification error: $_"
                            }
                        }
                    }
                }
            }
        }
        
        _directUpdateState = {
            param($self, [hashtable]$updates)
            if (-not $updates -or $updates.Count -eq 0) { return }
            
            Write-Log -Level Debug -Message "_directUpdateState called with $($updates.Count) updates"
            
            # Ensure state structure exists
            $state = $self._state
            if (-not $state._data) { $state._data = @{} }
            
            # Helper function to set nested paths
            $setNestedValue = {
                param($obj, $path, $value)
                $parts = $path -split '\.'
                $current = $obj
                for ($i = 0; $i -lt $parts.Count - 1; $i++) {
                    if (-not $current.ContainsKey($parts[$i])) {
                        $current[$parts[$i]] = @{}
                    }
                    $current = $current[$parts[$i]]
                }
                $current[$parts[-1]] = $value
            }
            
            # Process updates
            foreach ($key in $updates.Keys) {
                $newValue = $updates[$key]
                
                if ($key.Contains('.')) {
                    # Handle nested paths like "stats.todayHours"
                    $oldValue = & $self.GetState -self $self -path $key
                    & $setNestedValue -obj $state._data -path $key -value $newValue
                } else {
                    # Handle simple keys
                    $oldValue = $state._data[$key]
                    $state._data[$key] = $newValue
                }
                
                # Notify subscribers for exact path
                if ($state._subscribers -and $state._subscribers.ContainsKey($key)) {
                    foreach ($sub in $state._subscribers[$key]) {
                        try {
                            & $sub.Handler @{ NewValue = $newValue; OldValue = $oldValue; Path = $key }
                        } catch {
                            Write-Warning "Subscriber notification error for '$key': $_"
                        }
                    }
                }
                
                # Also notify parent path subscribers for nested updates
                if ($key.Contains('.')) {
                    $parts = $key -split '\.'
                    $parentPath = $parts[0]
                    if ($state._subscribers -and $state._subscribers.ContainsKey($parentPath)) {
                        $parentValue = $state._data[$parentPath]
                        foreach ($sub in $state._subscribers[$parentPath]) {
                            try {
                                & $sub.Handler @{ NewValue = $parentValue; OldValue = $parentValue; Path = $parentPath }
                            } catch {
                                Write-Warning "Parent subscriber notification error for '$parentPath': $_"
                            }
                        }
                    }
                }
            }
        }
        
        GetHistory = { param($self) ; return $self._history }
        
        RestoreState = {
            param($self, [int]$stepsBack = 1)
            if ($stepsBack -gt $self._history.Count) { throw "Cannot go back $stepsBack steps. Only $($self._history.Count) actions in history." }
            $targetState = $self._history[-$stepsBack].PreviousState
            & $self._updateState -self $self -updates $targetState
        }
    }
    
    # Register built-in actions
    & $store.RegisterAction -self $store -actionName "RESET_STATE" -scriptBlock {
        param($Context, $Payload)
        & $Context.UpdateState $InitialData
    }
    
    & $store.RegisterAction -self $store -actionName "UPDATE_STATE" -scriptBlock {
        param($Context, $Payload)
        if ($Payload -is [hashtable]) {
            & $Context.UpdateState $Payload
        }
    }
    
    return $store
}

Export-ModuleMember -Function "Initialize-AppStore"


####\services\data-manager.psm1
# Data Manager Service Module for PMC Terminal v5
# Manages global data state and provides CRUD operations
# AI: Implements the single source of truth for application data ($global:Data)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import dependencies
using module '..\models.psm1'
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force
Import-Module -Name "$PSScriptRoot\..\utilities\event-system.psm1" -Force

# DataManager Class - Central data management service
class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    hidden [System.Timers.Timer] $AutoSaveTimer
    
    # Constructor
    DataManager() {
        $this.InitializeDataStore()
        $this.DataFilePath = Join-Path -Path $env:APPDATA -ChildPath "PMCTerminal\data.json"
        
        Write-Log -Level Info -Message "DataManager initialized" -Component "DataManager"
    }
    
    # Initialize the global data store
    hidden [void] InitializeDataStore() {
        # AI: Using $global:Data as specified in architectural principles
        if ($null -eq $global:Data) {
            $global:Data = @{
                Tasks = @{}
                Projects = @{}
                Settings = [Settings]::new()
                Metadata = @{
                    Version = "5.0.0"
                    LastSaved = [DateTime]::Now
                    DataFormatVersion = 1
                }
            }
            Write-Log -Level Info -Message "Initialized global data store" -Component "DataManager"
        }
        
        $this.DataStore = $global:Data
    }
    
    # Get all tasks
    [Task[]] GetTasks() {
        return Invoke-WithErrorHandling -Component "DataManager" -Context "GetTasks" -ScriptBlock {
            $tasks = @()
            foreach ($taskId in $this.DataStore.Tasks.Keys) {
                $tasks += $this.DataStore.Tasks[$taskId]
            }
            return $tasks | Sort-Object -Property CreatedDate
        }
    }
    
    # Get tasks by project
    [Task[]] GetTasksByProject([string]$projectId) {
        if ([string]::IsNullOrWhiteSpace($projectId)) {
            throw [System.ArgumentException]::new("Project ID cannot be null or empty")
        }
        
        return $this.GetTasks() | Where-Object { $_.ProjectId -eq $projectId }
    }
    
    # Get task by ID
    [Task] GetTask([string]$taskId) {
        if ([string]::IsNullOrWhiteSpace($taskId)) {
            throw [System.ArgumentException]::new("Task ID cannot be null or empty")
        }
        
        if ($this.DataStore.Tasks.ContainsKey($taskId)) {
            return $this.DataStore.Tasks[$taskId]
        }
        
        return $null
    }
    
    # Add a new task
    [Task] AddTask([Task]$task) {
        return Invoke-WithErrorHandling -Component "DataManager" -Context "AddTask" -ScriptBlock {
            if ($null -eq $task) {
                throw [System.ArgumentNullException]::new("task", "Task cannot be null")
            }
            
            # Validate task
            if (-not $task.Validate()) {
                throw [System.InvalidOperationException]::new("Task validation failed")
            }
            
            # Check for duplicate ID
            if ($this.DataStore.Tasks.ContainsKey($task.Id)) {
                throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' already exists")
            }
            
            # Add to store
            $this.DataStore.Tasks[$task.Id] = $task
            
            # Update project statistics if task belongs to a project
            if (-not [string]::IsNullOrWhiteSpace($task.ProjectId)) {
                $this.UpdateProjectStatistics($task.ProjectId)
            }
            
            Write-Log -Level Info -Message "Added task: $($task.Title)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Add"
                TaskId = $task.Id
                Task = $task
            }
            
            # Trigger auto-save
            $this.ScheduleAutoSave()
            
            return $task
        }
    }
    
    # Update an existing task
    [Task] UpdateTask([Task]$task) {
        return Invoke-WithErrorHandling -Component "DataManager" -Context "UpdateTask" -ScriptBlock {
            if ($null -eq $task) {
                throw [System.ArgumentNullException]::new("task", "Task cannot be null")
            }
            
            # Check if task exists
            if (-not $this.DataStore.Tasks.ContainsKey($task.Id)) {
                throw [System.InvalidOperationException]::new("Task with ID '$($task.Id)' not found")
            }
            
            # Validate task
            if (-not $task.Validate()) {
                throw [System.InvalidOperationException]::new("Task validation failed")
            }
            
            # Get old task for comparison
            $oldTask = $this.DataStore.Tasks[$task.Id]
            $oldProjectId = $oldTask.ProjectId
            
            # Update task
            $task.ModifiedDate = [DateTime]::Now
            $this.DataStore.Tasks[$task.Id] = $task
            
            # Update project statistics
            if ($oldProjectId -ne $task.ProjectId) {
                # Task moved between projects
                if (-not [string]::IsNullOrWhiteSpace($oldProjectId)) {
                    $this.UpdateProjectStatistics($oldProjectId)
                }
                if (-not [string]::IsNullOrWhiteSpace($task.ProjectId)) {
                    $this.UpdateProjectStatistics($task.ProjectId)
                }
            }
            elseif (-not [string]::IsNullOrWhiteSpace($task.ProjectId)) {
                # Task status might have changed
                $this.UpdateProjectStatistics($task.ProjectId)
            }
            
            Write-Log -Level Info -Message "Updated task: $($task.Title)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Update"
                TaskId = $task.Id
                Task = $task
                OldTask = $oldTask
            }
            
            # Trigger auto-save
            $this.ScheduleAutoSave()
            
            return $task
        }
    }
    
    # Delete a task
    [void] DeleteTask([string]$taskId) {
        Invoke-WithErrorHandling -Component "DataManager" -Context "DeleteTask" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($taskId)) {
                throw [System.ArgumentException]::new("Task ID cannot be null or empty")
            }
            
            # Check if task exists
            if (-not $this.DataStore.Tasks.ContainsKey($taskId)) {
                throw [System.InvalidOperationException]::new("Task with ID '$taskId' not found")
            }
            
            # Get task for event data
            $task = $this.DataStore.Tasks[$taskId]
            $projectId = $task.ProjectId
            
            # Remove task
            $this.DataStore.Tasks.Remove($taskId)
            
            # Update project statistics
            if (-not [string]::IsNullOrWhiteSpace($projectId)) {
                $this.UpdateProjectStatistics($projectId)
            }
            
            Write-Log -Level Info -Message "Deleted task: $($task.Title)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Delete"
                TaskId = $taskId
                Task = $task
            }
            
            # Trigger auto-save
            $this.ScheduleAutoSave()
        }
    }
    
    # Get all projects
    [Project[]] GetProjects() {
        return Invoke-WithErrorHandling -Component "DataManager" -Context "GetProjects" -ScriptBlock {
            $projects = @()
            foreach ($projectId in $this.DataStore.Projects.Keys) {
                $projects += $this.DataStore.Projects[$projectId]
            }
            return $projects | Sort-Object -Property Name
        }
    }
    
    # Get project by ID
    [Project] GetProject([string]$projectId) {
        if ([string]::IsNullOrWhiteSpace($projectId)) {
            throw [System.ArgumentException]::new("Project ID cannot be null or empty")
        }
        
        if ($this.DataStore.Projects.ContainsKey($projectId)) {
            return $this.DataStore.Projects[$projectId]
        }
        
        return $null
    }
    
    # Add a new project
    [Project] AddProject([Project]$project) {
        return Invoke-WithErrorHandling -Component "DataManager" -Context "AddProject" -ScriptBlock {
            if ($null -eq $project) {
                throw [System.ArgumentNullException]::new("project", "Project cannot be null")
            }
            
            # Validate project
            if (-not $project.Validate()) {
                throw [System.InvalidOperationException]::new("Project validation failed")
            }
            
            # Check for duplicate ID
            if ($this.DataStore.Projects.ContainsKey($project.Id)) {
                throw [System.InvalidOperationException]::new("Project with ID '$($project.Id)' already exists")
            }
            
            # Add to store
            $this.DataStore.Projects[$project.Id] = $project
            
            Write-Log -Level Info -Message "Added project: $($project.Name)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Projects.Changed" -Data @{
                Action = "Add"
                ProjectId = $project.Id
                Project = $project
            }
            
            # Trigger auto-save
            $this.ScheduleAutoSave()
            
            return $project
        }
    }
    
    # Update an existing project
    [Project] UpdateProject([Project]$project) {
        return Invoke-WithErrorHandling -Component "DataManager" -Context "UpdateProject" -ScriptBlock {
            if ($null -eq $project) {
                throw [System.ArgumentNullException]::new("project", "Project cannot be null")
            }
            
            # Check if project exists
            if (-not $this.DataStore.Projects.ContainsKey($project.Id)) {
                throw [System.InvalidOperationException]::new("Project with ID '$($project.Id)' not found")
            }
            
            # Validate project
            if (-not $project.Validate()) {
                throw [System.InvalidOperationException]::new("Project validation failed")
            }
            
            # Get old project for comparison
            $oldProject = $this.DataStore.Projects[$project.Id]
            
            # Update project
            $project.ModifiedDate = [DateTime]::Now
            $this.DataStore.Projects[$project.Id] = $project
            
            Write-Log -Level Info -Message "Updated project: $($project.Name)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Projects.Changed" -Data @{
                Action = "Update"
                ProjectId = $project.Id
                Project = $project
                OldProject = $oldProject
            }
            
            # Trigger auto-save
            $this.ScheduleAutoSave()
            
            return $project
        }
    }
    
    # Delete a project
    [void] DeleteProject([string]$projectId) {
        Invoke-WithErrorHandling -Component "DataManager" -Context "DeleteProject" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($projectId)) {
                throw [System.ArgumentException]::new("Project ID cannot be null or empty")
            }
            
            # Check if project exists
            if (-not $this.DataStore.Projects.ContainsKey($projectId)) {
                throw [System.InvalidOperationException]::new("Project with ID '$projectId' not found")
            }
            
            # Check for tasks in project
            $projectTasks = $this.GetTasksByProject($projectId)
            if ($projectTasks.Count -gt 0) {
                throw [System.InvalidOperationException]::new(
                    "Cannot delete project with $($projectTasks.Count) tasks. Delete or reassign tasks first."
                )
            }
            
            # Get project for event data
            $project = $this.DataStore.Projects[$projectId]
            
            # Remove project
            $this.DataStore.Projects.Remove($projectId)
            
            Write-Log -Level Info -Message "Deleted project: $($project.Name)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Projects.Changed" -Data @{
                Action = "Delete"
                ProjectId = $projectId
                Project = $project
            }
            
            # Trigger auto-save
            $this.ScheduleAutoSave()
        }
    }
    
    # Get application settings
    [Settings] GetSettings() {
        return $this.DataStore.Settings
    }
    
    # Update application settings
    [void] UpdateSettings([Settings]$settings) {
        if ($null -eq $settings) {
            throw [System.ArgumentNullException]::new("settings", "Settings cannot be null")
        }
        
        # Validate settings
        if (-not $settings.Validate()) {
            throw [System.InvalidOperationException]::new("Settings validation failed")
        }
        
        $this.DataStore.Settings = $settings
        
        Write-Log -Level Info -Message "Updated application settings" -Component "DataManager"
        
        # Publish event
        Publish-Event -EventName "Settings.Changed" -Data @{
            Settings = $settings
        }
        
        # Trigger auto-save
        $this.ScheduleAutoSave()
    }
    
    # Update project statistics
    hidden [void] UpdateProjectStatistics([string]$projectId) {
        if ([string]::IsNullOrWhiteSpace($projectId)) {
            return
        }
        
        $project = $this.GetProject($projectId)
        if ($null -eq $project) {
            return
        }
        
        $tasks = $this.GetTasksByProject($projectId)
        $completedTasks = $tasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }
        
        $project.UpdateTaskStatistics($tasks.Count, $completedTasks.Count)
    }
    
    # Save data to file
    [void] SaveData() {
        Invoke-WithErrorHandling -Component "DataManager" -Context "SaveData" -ScriptBlock {
            # Ensure directory exists
            $directory = Split-Path -Path $this.DataFilePath -Parent
            if (-not (Test-Path $directory)) {
                New-Item -ItemType Directory -Path $directory -Force | Out-Null
            }
            
            # Update metadata
            $this.DataStore.Metadata.LastSaved = [DateTime]::Now
            
            # Convert to JSON
            $json = $this.DataStore | ConvertTo-Json -Depth 10 -Compress
            
            # Save to file
            Set-Content -Path $this.DataFilePath -Value $json -Encoding UTF8
            
            Write-Log -Level Info -Message "Data saved to: $($this.DataFilePath)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Data.Saved"
        }
    }
    
    # Load data from file
    [void] LoadData() {
        Invoke-WithErrorHandling -Component "DataManager" -Context "LoadData" -ScriptBlock {
            if (-not (Test-Path $this.DataFilePath)) {
                Write-Log -Level Info -Message "No data file found. Starting with empty data." -Component "DataManager"
                return
            }
            
            # Read and parse JSON
            $json = Get-Content -Path $this.DataFilePath -Raw -Encoding UTF8
            $loadedData = $json | ConvertFrom-Json -AsHashtable
            
            # Validate data format version
            if ($loadedData.Metadata.DataFormatVersion -ne $this.DataStore.Metadata.DataFormatVersion) {
                Write-Log -Level Warning -Message "Data format version mismatch. Migration may be needed." -Component "DataManager"
            }
            
            # Restore data
            $global:Data = $loadedData
            $this.DataStore = $global:Data
            
            # Convert PSCustomObjects back to proper classes
            $this.ConvertLoadedData()
            
            Write-Log -Level Info -Message "Data loaded from: $($this.DataFilePath)" -Component "DataManager"
            
            # Publish event
            Publish-Event -EventName "Data.Loaded"
        }
    }
    
    # Convert loaded JSON data back to proper classes
    hidden [void] ConvertLoadedData() {
        # Convert tasks
        $convertedTasks = @{}
        foreach ($taskId in $this.DataStore.Tasks.Keys) {
            $taskData = $this.DataStore.Tasks[$taskId]
            $task = [Task]::new()
            
            # Copy properties
            foreach ($prop in $taskData.PSObject.Properties) {
                if ($null -ne $task.PSObject.Properties[$prop.Name]) {
                    $task.($prop.Name) = $prop.Value
                }
            }
            
            $convertedTasks[$taskId] = $task
        }
        $this.DataStore.Tasks = $convertedTasks
        
        # Convert projects
        $convertedProjects = @{}
        foreach ($projectId in $this.DataStore.Projects.Keys) {
            $projectData = $this.DataStore.Projects[$projectId]
            $project = [Project]::new()
            
            # Copy properties
            foreach ($prop in $projectData.PSObject.Properties) {
                if ($null -ne $project.PSObject.Properties[$prop.Name]) {
                    $project.($prop.Name) = $prop.Value
                }
            }
            
            $convertedProjects[$projectId] = $project
        }
        $this.DataStore.Projects = $convertedProjects
        
        # Convert settings
        $settingsData = $this.DataStore.Settings
        $settings = [Settings]::new()
        
        foreach ($prop in $settingsData.PSObject.Properties) {
            if ($null -ne $settings.PSObject.Properties[$prop.Name]) {
                $settings.($prop.Name) = $prop.Value
            }
        }
        
        $this.DataStore.Settings = $settings
    }
    
    # Schedule auto-save
    hidden [void] ScheduleAutoSave() {
        if (-not $this.AutoSaveEnabled) {
            return
        }
        
        # Cancel existing timer if any
        if ($null -ne $this.AutoSaveTimer) {
            $this.AutoSaveTimer.Stop()
            $this.AutoSaveTimer.Dispose()
        }
        
        # Create new timer for 5 seconds
        $this.AutoSaveTimer = [System.Timers.Timer]::new(5000)
        $this.AutoSaveTimer.AutoReset = $false
        
        Register-ObjectEvent -InputObject $this.AutoSaveTimer -EventName Elapsed -Action {
            $dataManager = $Event.MessageData
            $dataManager.SaveData()
        } -MessageData $this | Out-Null
        
        $this.AutoSaveTimer.Start()
    }
    
    # Enable auto-save
    [void] EnableAutoSave() {
        $this.AutoSaveEnabled = $true
        Write-Log -Level Info -Message "Auto-save enabled" -Component "DataManager"
    }
    
    # Disable auto-save
    [void] DisableAutoSave() {
        $this.AutoSaveEnabled = $false
        
        if ($null -ne $this.AutoSaveTimer) {
            $this.AutoSaveTimer.Stop()
            $this.AutoSaveTimer.Dispose()
            $this.AutoSaveTimer = $null
        }
        
        Write-Log -Level Info -Message "Auto-save disabled" -Component "DataManager"
    }
    
    # Get data statistics
    [hashtable] GetStatistics() {
        $stats = @{
            TotalTasks = $this.DataStore.Tasks.Count
            ActiveTasks = ($this.GetTasks() | Where-Object { $_.Status -eq [TaskStatus]::Active }).Count
            CompletedTasks = ($this.GetTasks() | Where-Object { $_.Status -eq [TaskStatus]::Completed }).Count
            OverdueTasks = ($this.GetTasks() | Where-Object { $_.IsOverdue() }).Count
            TotalProjects = $this.DataStore.Projects.Count
            ActiveProjects = ($this.GetProjects() | Where-Object { $_.Status -eq [ProjectStatus]::Active }).Count
            LastSaved = $this.DataStore.Metadata.LastSaved
        }
        
        return $stats
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\services\keybindings.psm1
# FILE: services/keybindings.psm1
# PURPOSE: Centralizes keybinding logic to make them configurable and declarative.

function Initialize-KeybindingService {
    param(
        [hashtable]$CustomBindings = @{},
        [bool]$EnableChords = $false  # For future multi-key sequences
    )
    Invoke-WithErrorHandling -Component "KeybindingService.Initialize" -Context "Keybinding service initialization" -ScriptBlock {
        # Default keybindings - can be overridden
        $defaultKeyMap = @{
            # Application-level
            "App.Quit" = @{ Key = 'Q'; Modifiers = @() }
            "App.ForceQuit" = @{ Key = 'Q'; Modifiers = @('Ctrl') }
            "App.Back" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
            "App.Refresh" = @{ Key = 'R'; Modifiers = @() }
            "App.DebugLog" = @{ Key = [ConsoleKey]::F12; Modifiers = @() }
            "App.Help" = @{ Key = [ConsoleKey]::F1; Modifiers = @() }
            
            # List operations
            "List.New" = @{ Key = 'N'; Modifiers = @() }
            "List.Edit" = @{ Key = 'E'; Modifiers = @() }
            "List.Delete" = @{ Key = 'D'; Modifiers = @() }
            "List.Toggle" = @{ Key = [ConsoleKey]::Spacebar; Modifiers = @() }
            "List.SelectAll" = @{ Key = 'A'; Modifiers = @('Ctrl') }
            
            # Navigation
            "Nav.Up" = @{ Key = [ConsoleKey]::UpArrow; Modifiers = @() }
            "Nav.Down" = @{ Key = [ConsoleKey]::DownArrow; Modifiers = @() }
            "Nav.Left" = @{ Key = [ConsoleKey]::LeftArrow; Modifiers = @() }
            "Nav.Right" = @{ Key = [ConsoleKey]::RightArrow; Modifiers = @() }
            "Nav.PageUp" = @{ Key = [ConsoleKey]::PageUp; Modifiers = @() }
            "Nav.PageDown" = @{ Key = [ConsoleKey]::PageDown; Modifiers = @() }
            "Nav.Home" = @{ Key = [ConsoleKey]::Home; Modifiers = @() }
            "Nav.End" = @{ Key = [ConsoleKey]::End; Modifiers = @() }
            
            # Quick navigation (number keys)
            "QuickNav.1" = @{ Key = '1'; Modifiers = @() }
            "QuickNav.2" = @{ Key = '2'; Modifiers = @() }
            "QuickNav.3" = @{ Key = '3'; Modifiers = @() }
            "QuickNav.4" = @{ Key = '4'; Modifiers = @() }
            "QuickNav.5" = @{ Key = '5'; Modifiers = @() }
            "QuickNav.6" = @{ Key = '6'; Modifiers = @() }
            "QuickNav.7" = @{ Key = '7'; Modifiers = @() }
            "QuickNav.8" = @{ Key = '8'; Modifiers = @() }
            "QuickNav.9" = @{ Key = '9'; Modifiers = @() }
            
            # Form operations
            "Form.Submit" = @{ Key = [ConsoleKey]::Enter; Modifiers = @('Ctrl') }
            "Form.Cancel" = @{ Key = [ConsoleKey]::Escape; Modifiers = @() }
            "Form.Clear" = @{ Key = 'C'; Modifiers = @('Ctrl', 'Shift') }
            
            # Text editing
            "Edit.Cut" = @{ Key = 'X'; Modifiers = @('Ctrl') }
            "Edit.Copy" = @{ Key = 'C'; Modifiers = @('Ctrl') }
            "Edit.Paste" = @{ Key = 'V'; Modifiers = @('Ctrl') }
            "Edit.Undo" = @{ Key = 'Z'; Modifiers = @('Ctrl') }
            "Edit.Redo" = @{ Key = 'Y'; Modifiers = @('Ctrl') }
        }
        
        # Merge custom bindings
        $keyMap = $defaultKeyMap
        foreach ($action in $CustomBindings.Keys) {
            $keyMap[$action] = $CustomBindings[$action]
        }
        
        $service = @{
            _keyMap = $keyMap
            _enableChords = $EnableChords
            _chordBuffer = @()
            _chordTimeout = 1000  # milliseconds
            _lastKeyTime = [DateTime]::MinValue
            _contextStack = @()  # For context-specific bindings
            _globalHandlers = @{}  # Action name -> handler scriptblock
            
            IsAction = {
                param(
                    $self,
                    [string]$ActionName, 
                    [System.ConsoleKeyInfo]$KeyInfo,
                    [string]$Context = $null
                )
                Invoke-WithErrorHandling -Component "KeybindingService.IsAction" -Context "Check if key matches action" -ScriptBlock {
                    if ([string]::IsNullOrWhiteSpace($ActionName)) { return $false }
                    
                    # Check context-specific binding first
                    $contextKey = if ($Context) { "$Context.$ActionName" } else { $null }
                    if ($contextKey -and $self._keyMap.ContainsKey($contextKey)) {
                        return (& $self._matchesBinding -self $self -binding $self._keyMap[$contextKey] -keyInfo $KeyInfo)
                    }
                    
                    # Check global binding
                    if (-not $self._keyMap.ContainsKey($ActionName)) { return $false }
                    
                    return (& $self._matchesBinding -self $self -binding $self._keyMap[$ActionName] -keyInfo $KeyInfo)
                }
            }
            
            _matchesBinding = {
                param($self, $binding, $keyInfo)
                Invoke-WithErrorHandling -Component "KeybindingService._matchesBinding" -Context "Check if key matches binding" -ScriptBlock {
                    # Match key
                    $keyMatches = $false
                    if ($binding.Key -is [System.ConsoleKey]) {
                        $keyMatches = $keyInfo.Key -eq $binding.Key
                    }
                    elseif ($binding.Key -is [string] -and $binding.Key.Length -eq 1) {
                        $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.Key, [System.StringComparison]::InvariantCultureIgnoreCase)
                    }
                    
                    if (-not $keyMatches) { return $false }
                    
                    # Match modifiers
                    $requiredModifiers = $binding.Modifiers ?? @()
                    $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
                    $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
                    $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
                    
                    $ctrlRequired = 'Ctrl' -in $requiredModifiers
                    $altRequired = 'Alt' -in $requiredModifiers
                    $shiftRequired = 'Shift' -in $requiredModifiers
                    
                    return ($hasCtrl -eq $ctrlRequired) -and 
                           ($hasAlt -eq $altRequired) -and 
                           ($hasShift -eq $shiftRequired)
                }
            }
            
            GetBinding = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.GetBinding" -Context "Get keybinding for action" -ScriptBlock {
                    return $self._keyMap[$ActionName]
                }
            }
            
            SetBinding = {
                param($self, [string]$ActionName, $Key, [string[]]$Modifiers = @())
                Invoke-WithErrorHandling -Component "KeybindingService.SetBinding" -Context "Set keybinding for action" -ScriptBlock {
                    $self._keyMap[$ActionName] = @{ Key = $Key; Modifiers = $Modifiers }
                    Write-Log -Level Debug -Message "Set keybinding for '$ActionName': $Key + $($Modifiers -join '+')"
                }
            }
            
            RemoveBinding = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.RemoveBinding" -Context "Remove keybinding for action" -ScriptBlock {
                    $self._keyMap.Remove($ActionName)
                    Write-Log -Level Debug -Message "Removed keybinding for '$ActionName'"
                }
            }
            
            GetBindingDescription = {
                param($self, [string]$ActionName)
                Invoke-WithErrorHandling -Component "KeybindingService.GetBindingDescription" -Context "Get binding description for action" -ScriptBlock {
                    if (-not $self._keyMap.ContainsKey($ActionName)) { return $null }
                    $binding = $self._keyMap[$ActionName]
                    $keyStr = if ($binding.Key -is [System.ConsoleKey]) { $binding.Key.ToString() } else { $binding.Key.ToString().ToUpper() }
                    if ($binding.Modifiers.Count -gt 0) { return "$($binding.Modifiers -join '+') + $keyStr" }
                    return $keyStr
                }
            }
            
            RegisterGlobalHandler = {
                param($self, [string]$ActionName, [scriptblock]$Handler)
                Invoke-WithErrorHandling -Component "KeybindingService.RegisterGlobalHandler" -Context "Register global key handler" -ScriptBlock {
                    $self._globalHandlers[$ActionName] = $Handler
                    Write-Log -Level Debug -Message "Registered global handler for '$ActionName'"
                }
            }
            
            HandleKey = {
                param($self, [System.ConsoleKeyInfo]$KeyInfo, [string]$Context = $null)
                Invoke-WithErrorHandling -Component "KeybindingService.HandleKey" -Context "Handle key input" -ScriptBlock {
                    foreach ($action in $self._keyMap.Keys) {
                        if ((& $self.IsAction -self $self -ActionName $action -KeyInfo $KeyInfo -Context $Context)) {
                            if ($self._globalHandlers.ContainsKey($action)) {
                                Write-Log -Level Debug -Message "Executing global handler for '$action'"
                                return (& $self._globalHandlers[$action] -KeyInfo $KeyInfo -Context $Context)
                            }
                            return $action
                        }
                    }
                    return $null
                }
            }
            
            PushContext = {
                param($self, [string]$Context)
                Invoke-WithErrorHandling -Component "KeybindingService.PushContext" -Context "Push keybinding context" -ScriptBlock {
                    $self._contextStack += $Context
                    Write-Log -Level Debug -Message "Pushed keybinding context: $Context"
                }
            }
            
            PopContext = {
                param($self)
                Invoke-WithErrorHandling -Component "KeybindingService.PopContext" -Context "Pop keybinding context" -ScriptBlock {
                    if ($self._contextStack.Count -gt 0) {
                        $context = $self._contextStack[-1]
                        $self._contextStack = $self._contextStack[0..($self._contextStack.Count - 2)]
                        Write-Log -Level Debug -Message "Popped keybinding context: $context"
                        return $context
                    }
                    return $null
                }
            }
            
            GetCurrentContext = {
                param($self)
                Invoke-WithErrorHandling -Component "KeybindingService.GetCurrentContext" -Context "Get current keybinding context" -ScriptBlock {
                    if ($self._contextStack.Count -gt 0) { return $self._contextStack[-1] }
                    return $null
                }
            }
            
            GetAllBindings = {
                param($self, [bool]$GroupByCategory = $false)
                Invoke-WithErrorHandling -Component "KeybindingService.GetAllBindings" -Context "Get all keybindings" -ScriptBlock {
                    if (-not $GroupByCategory) { return $self._keyMap }
                    $grouped = @{}
                    foreach ($action in $self._keyMap.Keys) {
                        $parts = $action.Split('.')
                        $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
                        if (-not $grouped.ContainsKey($category)) { $grouped[$category] = @{} }
                        $grouped[$category][$action] = $self._keyMap[$action]
                    }
                    return $grouped
                }
            }
            
            ExportBindings = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "KeybindingService.ExportBindings" -Context "Export keybindings to file" -ScriptBlock {
                    $self._keyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $Path
                    Write-Log -Level Info -Message "Exported keybindings to: $Path"
                }
            }
            
            ImportBindings = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "KeybindingService.ImportBindings" -Context "Import keybindings from file" -ScriptBlock {
                    if (Test-Path $Path) {
                        $imported = Get-Content $Path | ConvertFrom-Json
                        foreach ($prop in $imported.PSObject.Properties) {
                            $self._keyMap[$prop.Name] = @{
                                Key = $prop.Value.Key
                                Modifiers = $prop.Value.Modifiers
                            }
                        }
                        Write-Log -Level Info -Message "Imported keybindings from: $Path"
                    }
                }
            }
        }
        
        return $service
    }
}

Export-ModuleMember -Function "Initialize-KeybindingService"


####\services\navigation-service-class.psm1
# Navigation Service Class Implementation
# Service-oriented navigation with proper error handling

using namespace System.Collections.Generic

# Import utilities
Import-Module "$PSScriptRoot\..\utilities\exceptions.psm1" -Force
Import-Module "$PSScriptRoot\..\utilities\logging.psm1" -Force
Import-Module "$PSScriptRoot\..\utilities\events.psm1" -Force

# Screen Factory Class
class ScreenFactory {
    [hashtable] $Services
    [Dictionary[string, type]] $ScreenTypes
    
    ScreenFactory([hashtable]$services) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        $this.Services = $services
        $this.ScreenTypes = [Dictionary[string, type]]::new()
        $this.RegisterDefaultScreens()
    }
    
    hidden [void] RegisterDefaultScreens() {
        # Register known screen types
        # These will be updated as screens are migrated to classes
        $this.ScreenTypes["DashboardScreen"] = [DashboardScreen]
        # Add more as they're converted to classes
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("Screen name cannot be null or empty")
        }
        if ($null -eq $screenType) {
            throw [System.ArgumentNullException]::new("screenType", "Screen type cannot be null")
        }
        $this.ScreenTypes[$name] = $screenType
    }
    
    [object] CreateScreen([string]$screenName) {
        if (-not $this.ScreenTypes.ContainsKey($screenName)) {
            # Fall back to legacy screen creation if available
            if (Get-Command -Name "Get-$screenName" -ErrorAction SilentlyContinue) {
                Write-Log -Level Info -Message "Creating legacy screen: $screenName"
                return & "Get-$screenName" -Services $this.Services
            }
            throw [System.InvalidOperationException]::new("Unknown screen type: $screenName")
        }
        
        $screenType = $this.ScreenTypes[$screenName]
        
        # Create instance based on whether it's a class or hashtable-based screen
        if ($screenType -is [type]) {
            Write-Log -Level Debug -Message "Creating class-based screen: $screenName"
            return $screenType::new($this.Services)
        } else {
            Write-Log -Level Debug -Message "Creating hashtable-based screen: $screenName"
            return & $screenType -Services $this.Services
        }
    }
}

# Navigation Service Class
class NavigationService {
    [Stack[object]] $ScreenStack
    [object] $CurrentScreen
    [ScreenFactory] $ScreenFactory
    [hashtable] $Services
    [bool] $ExitRequested = $false
    
    NavigationService([hashtable]$services) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        $this.Services = $services
        $this.ScreenStack = [Stack[object]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
    }
    
    [void] PushScreen([string]$screenName) {
        $this.PushScreen($screenName, @{})
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters) {
        Invoke-ClassMethod -ClassName "NavigationService" -MethodName "PushScreen" -ScriptBlock {
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            # Create the new screen
            $newScreen = $this.ScreenFactory.CreateScreen($screenName)
            
            # Handle current screen exit
            if ($null -ne $this.CurrentScreen) {
                $this.CallScreenMethod($this.CurrentScreen, "OnExit")
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            # Set new screen as current
            $this.CurrentScreen = $newScreen
            
            # Pass parameters to screen
            if ($parameters.Count -gt 0) {
                if ($newScreen -is [Screen]) {
                    # Class-based screen
                    foreach ($key in $parameters.Keys) {
                        $newScreen.State[$key] = $parameters[$key]
                    }
                } else {
                    # Hashtable-based screen
                    foreach ($key in $parameters.Keys) {
                        $newScreen.State[$key] = $parameters[$key]
                    }
                }
            }
            
            # Initialize the new screen
            $this.CallScreenMethod($newScreen, "Init", @{services = $this.Services})
            
            # Call OnEnter if available
            $this.CallScreenMethod($newScreen, "OnEnter")
            
            # Update TUI state
            if ($global:TuiState) {
                $global:TuiState.CurrentScreen = $newScreen
                Request-TuiRefresh
            }
            
            # Publish event
            Publish-Event -EventName "Navigation.ScreenPushed" -Data @{
                ScreenName = $screenName
                Parameters = $parameters
            }
        } -Data @{ ScreenName = $screenName }
    }
    
    [bool] PopScreen() {
        return Invoke-ClassMethod -ClassName "NavigationService" -MethodName "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) {
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false
            }
            
            Write-Log -Level Info -Message "Popping screen"
            
            # Exit current screen
            if ($null -ne $this.CurrentScreen) {
                $this.CallScreenMethod($this.CurrentScreen, "OnExit")
            }
            
            # Pop previous screen
            $this.CurrentScreen = $this.ScreenStack.Pop()
            
            # Resume previous screen
            if ($null -ne $this.CurrentScreen) {
                $this.CallScreenMethod($this.CurrentScreen, "OnResume")
                
                # Update TUI state
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    Request-TuiRefresh
                }
            }
            
            # Publish event
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{
                CurrentScreen = if ($this.CurrentScreen) { $this.CurrentScreen.Name } else { $null }
            }
            
            return $true
        }
    }
    
    [void] GoTo([string]$path) {
        Invoke-ClassMethod -ClassName "NavigationService" -MethodName "GoTo" -ScriptBlock {
            Write-Log -Level Info -Message "Navigating to: $path"
            
            switch ($path) {
                "/tasks" { $this.PushScreen("TaskListScreen") }
                "/projects" { $this.PushScreen("ProjectListScreen") }
                "/reports" { $this.PushScreen("ReportsScreen") }
                "/settings" { $this.PushScreen("SettingsScreen") }
                "/exit" { $this.RequestExit() }
                default { 
                    Write-Log -Level Warning -Message "Unknown navigation path: $path"
                    throw [System.InvalidOperationException]::new("Unknown navigation path: $path")
                }
            }
        } -Data @{ Path = $path }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        $this.ExitRequested = $true
        
        # Stop TUI if available
        if (Get-Command -Name "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        } elseif ($global:TuiState) {
            $global:TuiState.Running = $false
        }
        
        Publish-Event -EventName "Navigation.ExitRequested"
    }
    
    [object] GetCurrentScreen() {
        return $this.CurrentScreen
    }
    
    [bool] CanGoBack() {
        return $this.ScreenStack.Count -gt 0
    }
    
    hidden [void] CallScreenMethod([object]$screen, [string]$methodName) {
        $this.CallScreenMethod($screen, $methodName, @{})
    }
    
    hidden [void] CallScreenMethod([object]$screen, [string]$methodName, [hashtable]$parameters) {
        if ($null -eq $screen) { return }
        
        try {
            if ($screen -is [Screen]) {
                # Class-based screen
                $method = $screen.GetType().GetMethod($methodName)
                if ($null -ne $method) {
                    if ($parameters.Count -gt 0) {
                        $method.Invoke($screen, @($parameters))
                    } else {
                        $method.Invoke($screen, $null)
                    }
                }
            } else {
                # Hashtable-based screen
                if ($screen.$methodName) {
                    if ($parameters.Count -gt 0) {
                        & $screen.$methodName -self $screen @parameters
                    } else {
                        & $screen.$methodName -self $screen
                    }
                }
            }
        }
        catch {
            Write-Log -Level Warning -Message "Error calling $methodName on screen: $_"
        }
    }
}

# Export classes and any helper functions
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\services\navigation-service.psm1
# Navigation Service Module for PMC Terminal v5
# Manages screen navigation stack and transitions
# AI: Implements Phase 4.2 of the class migration plan - Navigation Service

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import base classes
using module '..\components\ui-classes.psm1'
using module '.\screen-factory.psm1'

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# NavigationService - Manages screen stack and navigation
class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [int] $MaxStackDepth = 10
    hidden [hashtable] $NavigationHistory = @{}
    
    NavigationService([hashtable]$services) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        
        Write-Log -Level Info -Message "NavigationService initialized" -Component "NavigationService"
    }
    
    [void] PushScreen([string]$screenName) {
        $this.PushScreen($screenName, @{})
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($screenName)) {
                throw [System.ArgumentException]::new("Screen name cannot be null or empty")
            }
            
            # Check stack depth limit
            if ($this.ScreenStack.Count -ge $this.MaxStackDepth) {
                throw [System.InvalidOperationException]::new(
                    "Navigation stack depth limit reached ($($this.MaxStackDepth))"
                )
            }
            
            Write-Log -Level Info -Message "Pushing screen: $screenName" -Component "NavigationService"
            
            # Clean up current screen if exists
            if ($null -ne $this.CurrentScreen) {
                try {
                    $this.CurrentScreen.Cleanup()
                }
                catch {
                    Write-Log -Level Warning -Message "Error during screen cleanup: $_" -Component "NavigationService"
                }
            }
            
            # Create new screen
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            
            # Initialize the new screen
            try {
                $newScreen.Initialize()
            }
            catch {
                Write-Log -Level Error -Message "Failed to initialize screen '$screenName': $_" -Component "NavigationService"
                throw
            }
            
            # Push to stack
            $this.ScreenStack.Push($newScreen)
            $this.CurrentScreen = $newScreen
            
            # Track navigation history
            $this.TrackNavigation($screenName, "Push")
            
            # Publish navigation event
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{
                Screen = $screenName
                Action = "Push"
                StackDepth = $this.ScreenStack.Count
                Parameters = $parameters
            }
            
            Write-Log -Level Debug -Message "Screen pushed successfully. Stack depth: $($this.ScreenStack.Count)" -Component "NavigationService"
        }
    }
    
    [Screen] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -le 1) {
                Write-Log -Level Warning -Message "Cannot pop last screen from stack" -Component "NavigationService"
                return $null
            }
            
            # Remove current screen
            $poppedScreen = $this.ScreenStack.Pop()
            $screenName = $poppedScreen.Name
            
            Write-Log -Level Info -Message "Popping screen: $screenName" -Component "NavigationService"
            
            # Clean up popped screen
            try {
                $poppedScreen.Cleanup()
            }
            catch {
                Write-Log -Level Warning -Message "Error during screen cleanup: $_" -Component "NavigationService"
            }
            
            # Set new current screen
            if ($this.ScreenStack.Count -gt 0) {
                $this.CurrentScreen = $this.ScreenStack.Peek()
                
                # Re-initialize the revealed screen
                try {
                    $this.CurrentScreen.Initialize()
                }
                catch {
                    Write-Log -Level Warning -Message "Error re-initializing screen: $_" -Component "NavigationService"
                }
            }
            else {
                $this.CurrentScreen = $null
            }
            
            # Track navigation history
            $this.TrackNavigation($screenName, "Pop")
            
            # Publish navigation event
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{
                Screen = if ($null -ne $this.CurrentScreen) { $this.CurrentScreen.Name } else { "None" }
                Action = "Pop"
                StackDepth = $this.ScreenStack.Count
                PoppedScreen = $screenName
            }
            
            Write-Log -Level Debug -Message "Screen popped successfully. Stack depth: $($this.ScreenStack.Count)" -Component "NavigationService"
            
            return $poppedScreen
        }
    }
    
    [void] ReplaceScreen([string]$screenName) {
        $this.ReplaceScreen($screenName, @{})
    }
    
    [void] ReplaceScreen([string]$screenName, [hashtable]$parameters) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "ReplaceScreen:$screenName" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) {
                # If stack is empty, just push
                $this.PushScreen($screenName, $parameters)
                return
            }
            
            Write-Log -Level Info -Message "Replacing current screen with: $screenName" -Component "NavigationService"
            
            # Remove current screen without re-initializing previous
            $oldScreen = $this.ScreenStack.Pop()
            
            try {
                $oldScreen.Cleanup()
            }
            catch {
                Write-Log -Level Warning -Message "Error during screen cleanup: $_" -Component "NavigationService"
            }
            
            # Push new screen
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $newScreen.Initialize()
            
            $this.ScreenStack.Push($newScreen)
            $this.CurrentScreen = $newScreen
            
            # Track navigation history
            $this.TrackNavigation($screenName, "Replace")
            
            # Publish navigation event
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{
                Screen = $screenName
                Action = "Replace"
                StackDepth = $this.ScreenStack.Count
                ReplacedScreen = $oldScreen.Name
                Parameters = $parameters
            }
        }
    }
    
    [void] NavigateToRoot() {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "NavigateToRoot" -ScriptBlock {
            Write-Log -Level Info -Message "Navigating to root screen" -Component "NavigationService"
            
            # Clean up all screens except the first
            while ($this.ScreenStack.Count -gt 1) {
                $screen = $this.ScreenStack.Pop()
                try {
                    $screen.Cleanup()
                }
                catch {
                    Write-Log -Level Warning -Message "Error during screen cleanup: $_" -Component "NavigationService"
                }
            }
            
            # Re-initialize root screen
            if ($this.ScreenStack.Count -gt 0) {
                $this.CurrentScreen = $this.ScreenStack.Peek()
                $this.CurrentScreen.Initialize()
            }
            
            # Publish navigation event
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{
                Screen = if ($null -ne $this.CurrentScreen) { $this.CurrentScreen.Name } else { "None" }
                Action = "NavigateToRoot"
                StackDepth = $this.ScreenStack.Count
            }
        }
    }
    
    [void] ClearStack() {
        Write-Log -Level Info -Message "Clearing navigation stack" -Component "NavigationService"
        
        # Clean up all screens
        while ($this.ScreenStack.Count -gt 0) {
            $screen = $this.ScreenStack.Pop()
            try {
                $screen.Cleanup()
            }
            catch {
                Write-Log -Level Warning -Message "Error during screen cleanup: $_" -Component "NavigationService"
            }
        }
        
        $this.CurrentScreen = $null
        $this.NavigationHistory.Clear()
        
        # Publish navigation event
        Publish-Event -EventName "Navigation.StackCleared"
    }
    
    [Screen] GetCurrentScreen() {
        return $this.CurrentScreen
    }
    
    [string] GetCurrentScreenName() {
        if ($null -ne $this.CurrentScreen) {
            return $this.CurrentScreen.Name
        }
        return ""
    }
    
    [int] GetStackDepth() {
        return $this.ScreenStack.Count
    }
    
    [string[]] GetNavigationStack() {
        $stack = @()
        foreach ($screen in $this.ScreenStack) {
            $stack += $screen.Name
        }
        return $stack
    }
    
    [bool] CanGoBack() {
        return $this.ScreenStack.Count -gt 1
    }
    
    # AI: Track navigation history for analytics
    hidden [void] TrackNavigation([string]$screenName, [string]$action) {
        $timestamp = [DateTime]::Now
        
        if (-not $this.NavigationHistory.ContainsKey($screenName)) {
            $this.NavigationHistory[$screenName] = @{
                FirstVisit = $timestamp
                LastVisit = $timestamp
                VisitCount = 0
                Actions = @()
            }
        }
        
        $history = $this.NavigationHistory[$screenName]
        $history.LastVisit = $timestamp
        $history.VisitCount++
        $history.Actions += @{
            Action = $action
            Timestamp = $timestamp
        }
        
        # Limit action history to last 100 entries
        if ($history.Actions.Count -gt 100) {
            $history.Actions = $history.Actions[-100..-1]
        }
    }
    
    [hashtable] GetNavigationStatistics() {
        $stats = @{
            TotalScreens = $this.NavigationHistory.Count
            TotalNavigations = 0
            MostVisited = @()
        }
        
        foreach ($screen in $this.NavigationHistory.Keys) {
            $stats.TotalNavigations += $this.NavigationHistory[$screen].VisitCount
        }
        
        # Find most visited screens
        $stats.MostVisited = $this.NavigationHistory.GetEnumerator() | 
            Sort-Object -Property { $_.Value.VisitCount } -Descending |
            Select-Object -First 5 |
            ForEach-Object {
                @{
                    Screen = $_.Key
                    VisitCount = $_.Value.VisitCount
                    LastVisit = $_.Value.LastVisit
                }
            }
        
        return $stats
    }
    
    # AI: Added GoTo method for compatibility with dashboard navigation expectations
    [bool] GoTo([string]$path) {
        return $this.GoTo($path, @{})
    }
    
    [bool] GoTo([string]$path, [hashtable]$parameters) {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            Write-Log -Level Info -Message "Navigating to path: $path" -Component "NavigationService"
            
            # Map paths to screen names
            $screenMap = @{
                "/tasks" = "TaskListScreen"
                "/projects" = "ProjectListScreen"
                "/reports" = "ReportsScreen"
                "/settings" = "SettingsScreen"
                "/dashboard" = "DashboardScreen"
                "/" = "DashboardScreen"
            }
            
            if (-not $screenMap.ContainsKey($path)) {
                Write-Log -Level Warning -Message "Unknown navigation path: $path" -Component "NavigationService"
                return $false
            }
            
            $screenName = $screenMap[$path]
            
            try {
                # Use PushScreen to navigate
                $this.PushScreen($screenName, $parameters)
                return $true
            }
            catch {
                Write-Log -Level Error -Message "Failed to navigate to $screenName : $_" -Component "NavigationService"
                return $false
            }
        }
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\services\navigation.psm1
# FILE: services/navigation.psm1
# PURPOSE: Decouples screens by managing all navigation through a centralized route map.

function Initialize-NavigationService {
    param(
        [hashtable]$CustomRoutes = @{},
        [bool]$EnableBreadcrumbs = $true
    )
    Invoke-WithErrorHandling -Component "NavigationService.Initialize" -Context "Navigation service initialization" -ScriptBlock {
        # Default routes - can be overridden by CustomRoutes
        $defaultRoutes = @{
            "/dashboard" = @{ 
                Factory = { Get-DashboardScreen }
                Title = "Dashboard"
                RequiresAuth = $false
            }
            "/tasks" = @{ 
                Factory = { Get-TaskManagementScreen }
                Title = "Task Management"
                RequiresAuth = $false
            }
            "/timer/start" = @{ 
                Factory = { Get-TimerStartScreen }
                Title = "Timer"
                RequiresAuth = $false
            }
            "/timer/manage" = @{
                Factory = { Get-TimerManagementScreen }
                Title = "Timer Management"
                RequiresAuth = $false
            }
            "/reports" = @{ 
                Factory = { Get-ReportsScreen }
                Title = "Reports"
                RequiresAuth = $false
            }
            "/settings" = @{ 
                Factory = { Get-SettingsScreen }
                Title = "Settings"
                RequiresAuth = $false
            }
            "/projects" = @{ 
                Factory = { Get-ProjectManagementScreen }
                Title = "Projects"
                RequiresAuth = $false
            }
            "/log" = @{ 
                Factory = { Get-DebugLogScreen }
                Title = "Debug Log"
                RequiresAuth = $false
            }
            "/simple-test" = @{ # ADDED THIS ROUTE
                Factory = { Get-SimpleTestScreen }
                Title = "Simple Test"
                RequiresAuth = $false
            }
        }
        
        # Merge custom routes
        $routes = $defaultRoutes
        foreach ($key in $CustomRoutes.Keys) {
            $routes[$key] = $CustomRoutes[$key]
        }
        
        $service = @{
            _routes = $routes
            _history = @()  # Navigation history for back button
            _breadcrumbs = @()  # For UI breadcrumb display
            _beforeNavigate = @()  # Navigation guards
            _afterNavigate = @()  # Navigation hooks
            
            GoTo = {
                param(
                    $self,
                    [string]$Path,
                    [hashtable]$Params = @{},
                    [hashtable]$Services = $null
                )
                Invoke-WithErrorHandling -Component "NavigationService.GoTo" -Context "Navigation to route" -ScriptBlock {
                    if ([string]::IsNullOrWhiteSpace($Path)) {
                        Write-Log -Level Error -Message "Navigation path cannot be empty"
                        return $false
                    }
                    
                    # Normalize path
                    if (-not $Path.StartsWith("/")) { $Path = "/$Path" }
                    
                    # Check if route exists
                    if (-not $self._routes.ContainsKey($Path)) {
                        $availableRoutes = ($self._routes.Keys | Sort-Object) -join ", "
                        $msg = "Route not found: $Path. Available routes: $availableRoutes"
                        Write-Log -Level Error -Message $msg
                        Show-AlertDialog -Title "Navigation Error" -Message "The screen '$Path' does not exist."
                        return $false
                    }
                    
                    $route = $self._routes[$Path]
                    
                    # Run before navigation guards
                    foreach ($guard in $self._beforeNavigate) {
                        try {
                            $canNavigate = & $guard -Path $Path -Route $route -Params $Params
                            if (-not $canNavigate) {
                                Write-Log -Level Debug -Message "Navigation to '$Path' cancelled by guard"
                                return $false
                            }
                        } catch {
                            Write-Log -Level Error -Message "Navigation guard failed for path '$Path': $_" -Data @{ Path = $Path; Guard = $guard; Exception = $_ }
                            Show-AlertDialog -Title "Navigation Error" -Message "A navigation check failed. Cannot proceed."
                            return $false
                        }
                    }
                    
                    # Check authentication if required
                    if ($route.RequiresAuth -and -not (& $self._checkAuth -self $self)) {
                        Write-Log -Level Warning -Message "Navigation to '$Path' requires authentication"
                        Show-AlertDialog -Title "Access Denied" -Message "You must be logged in to access this screen."
                        return $false
                    }
                    
                    try {
                        # Pass Services to factory if provided
                        if ($Services) {
                            $screen = & $route.Factory -Services $Services
                        } else {
                            $screen = & $route.Factory
                        }
                        if (-not $screen) { throw "Screen factory returned null for route '$Path'" }
                        
                        # CRITICAL: Ensure screen has services stored
                        if ($Services -and -not $screen._services) {
                            $screen._services = $Services
                        }
                        
                        if ($screen.SetParams -and $Params.Count -gt 0) { 
                            try {
                                & $screen.SetParams -self $screen -Params $Params 
                            } catch {
                                Write-Log -Level Error -Message "Screen SetParams failed for '$Path': $_" -Data @{ Path = $Path; Params = $Params; Exception = $_ }
                            }
                        }
                        
                        $self._history += @{ Path = $Path; Timestamp = [DateTime]::UtcNow; Params = $Params }
                        if ($EnableBreadcrumbs) { $self._breadcrumbs += @{ Path = $Path; Title = $route.Title ?? $Path } }
                        
                        Push-Screen -Screen $screen
                        
                        foreach ($hook in $self._afterNavigate) { 
                            try {
                                & $hook -Path $Path -Screen $screen 
                            } catch {
                                Write-Log -Level Error -Message "After navigation hook failed for path '$Path': $_" -Data @{ Path = $Path; Hook = $hook; Exception = $_ }
                            }
                        }
                        
                        Write-Log -Level Info -Message "Navigated to: $Path"
                        return $true
                    }
                    catch {
                        throw [Helios.NavigationException]::new(
                            "Failed to create or navigate to screen for route '$Path'",
                            "NavigationService.GoTo",
                            @{
                                Route = $Path
                                RouteConfig = $route
                            },
                            $_.Exception
                        )
                    }
                }
            }
            
            Back = { 
                param($self, [int]$Steps = 1)
                Invoke-WithErrorHandling -Component "NavigationService.Back" -Context "Navigate back" -ScriptBlock {
                    for ($i = 0; $i -lt $Steps; $i++) {
                        if ($global:TuiState.ScreenStack.Count -le 1) {
                            Write-Log -Level Debug -Message "Cannot go back - at root screen"
                            return $false
                        }
                        Pop-Screen
                        if ($EnableBreadcrumbs -and $self._breadcrumbs.Count -gt 0) {
                            $self._breadcrumbs = $self._breadcrumbs[0..($self._breadcrumbs.Count - 2)]
                        }
                    }
                    return $true
                }
            }
            
            GetCurrentPath = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetCurrentPath" -Context "Get current navigation path" -ScriptBlock {
                    if ($self._history.Count -eq 0) { return "/" }
                    return $self._history[-1].Path
                }
            }
            
            GetBreadcrumbs = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetBreadcrumbs" -Context "Get navigation breadcrumbs" -ScriptBlock {
                    return $self._breadcrumbs
                }
            }
            
            AddRoute = {
                param($self, [string]$Path, [hashtable]$RouteConfig)
                Invoke-WithErrorHandling -Component "NavigationService.AddRoute" -Context "Add navigation route" -ScriptBlock {
                    if (-not $RouteConfig.Factory) { throw "Route must have a Factory scriptblock" }
                    $self._routes[$Path] = $RouteConfig
                    Write-Log -Level Debug -Message "Added route: $Path"
                }
            }
            
            RegisterRoute = {
                param($self, [string]$Path, [scriptblock]$ScreenFactory)
                Invoke-WithErrorHandling -Component "NavigationService.RegisterRoute" -Context "Register navigation route" -ScriptBlock {
                    # Convert the simpler RegisterRoute format to the AddRoute format
                    $routeConfig = @{
                        Factory = $ScreenFactory
                        Title = $Path.Substring(1).Replace('/', ' ').Replace('-', ' ')
                        RequiresAuth = $false
                    }
                    # Call AddRoute with the proper format
                    & $self.AddRoute -self $self -Path $Path -RouteConfig $routeConfig
                    Write-Log -Level Debug -Message "Registered route: $Path"
                }
            }
            
            RemoveRoute = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "NavigationService.RemoveRoute" -Context "Remove navigation route" -ScriptBlock {
                    $self._routes.Remove($Path)
                    Write-Log -Level Debug -Message "Removed route: $Path"
                }
            }
            
            AddBeforeNavigateGuard = {
                param($self, [scriptblock]$Guard)
                Invoke-WithErrorHandling -Component "NavigationService.AddBeforeNavigateGuard" -Context "Add before navigate guard" -ScriptBlock {
                    $self._beforeNavigate += $Guard
                }
            }
            
            AddAfterNavigateHook = {
                param($self, [scriptblock]$Hook)
                Invoke-WithErrorHandling -Component "NavigationService.AddAfterNavigateHook" -Context "Add after navigate hook" -ScriptBlock {
                    $self._afterNavigate += $Hook
                }
            }
            
            _checkAuth = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService._checkAuth" -Context "Check authentication status" -ScriptBlock {
                    # Placeholder for authentication check
                    return $true
                }
            }
            
            GetRoutes = {
                param($self)
                Invoke-WithErrorHandling -Component "NavigationService.GetRoutes" -Context "Get available routes" -ScriptBlock {
                    return $self._routes.Keys | Sort-Object
                }
            }
            
            IsValidRoute = {
                param($self, [string]$Path)
                Invoke-WithErrorHandling -Component "NavigationService.IsValidRoute" -Context "Check route validity" -ScriptBlock {
                    return $self._routes.ContainsKey($Path)
                }
            }
        }
        
        return $service
    }
}

Export-ModuleMember -Function "Initialize-NavigationService"


####\services\screen-factory.psm1
# Screen Factory Service Module for PMC Terminal v5
# Factory pattern implementation for creating screen instances
# AI: Implements Phase 4.1 of the class migration plan - Screen Factory

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import base classes
using module '..\components\ui-classes.psm1'

# Import screen classes
using module '..\screens\dashboard\dashboard-screen-class.psm1'
using module '..\screens\task-list-screen-class.psm1'
using module '..\screens\new-task-screen-class.psm1'

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# ScreenFactory - Creates and manages screen instances
class ScreenFactory {
    [hashtable] $Services
    [hashtable] $ScreenTypes = @{}
    hidden [hashtable] $ScreenCache = @{}
    [bool] $EnableCaching = $false
    
    ScreenFactory([hashtable]$services) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        
        $this.Services = $services
        $this.RegisterScreenTypes()
    }
    
    hidden [void] RegisterScreenTypes() {
        Write-Log -Level Debug -Message "Registering screen types" -Component "ScreenFactory"
        
        # Register all available screen types
        $this.ScreenTypes["DashboardScreen"] = [DashboardScreen]
        $this.ScreenTypes["TaskListScreen"] = [TaskListScreen]
        $this.ScreenTypes["NewTaskScreen"] = [NewTaskScreen]
        
        # AI: These screens will be implemented in subsequent phases
        # $this.ScreenTypes["EditTaskScreen"] = [EditTaskScreen]
        # $this.ScreenTypes["ProjectListScreen"] = [ProjectListScreen]
        # $this.ScreenTypes["SettingsScreen"] = [SettingsScreen]
        # $this.ScreenTypes["FilterScreen"] = [FilterScreen]
        
        Write-Log -Level Info -Message "Registered $($this.ScreenTypes.Count) screen types" -Component "ScreenFactory"
    }
    
    [Screen] CreateScreen([string]$screenName) {
        return $this.CreateScreen($screenName, @{})
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        return Invoke-WithErrorHandling -Component "ScreenFactory" -Context "CreateScreen:$screenName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($screenName)) {
                throw [System.ArgumentException]::new("Screen name cannot be null or empty")
            }
            
            # Check cache first if enabled
            if ($this.EnableCaching -and $this.ScreenCache.ContainsKey($screenName)) {
                Write-Log -Level Debug -Message "Returning cached screen: $screenName" -Component "ScreenFactory"
                $cachedScreen = $this.ScreenCache[$screenName]
                
                # Update parameters in cached screen
                foreach ($key in $parameters.Keys) {
                    $cachedScreen.State[$key] = $parameters[$key]
                }
                
                return $cachedScreen
            }
            
            # Validate screen type exists
            if (-not $this.ScreenTypes.ContainsKey($screenName)) {
                $availableScreens = $this.ScreenTypes.Keys -join ", "
                throw [System.InvalidOperationException]::new(
                    "Unknown screen type: $screenName. Available screens: $availableScreens"
                )
            }
            
            Write-Log -Level Debug -Message "Creating new screen instance: $screenName" -Component "ScreenFactory"
            
            # Create new screen instance
            $screenType = $this.ScreenTypes[$screenName]
            $screen = $screenType::new($this.Services)
            
            # Apply initial parameters
            if ($null -ne $parameters -and $parameters.Count -gt 0) {
                foreach ($key in $parameters.Keys) {
                    $screen.State[$key] = $parameters[$key]
                }
                Write-Log -Level Debug -Message "Applied $($parameters.Count) parameters to screen" -Component "ScreenFactory"
            }
            
            # Cache if enabled
            if ($this.EnableCaching) {
                $this.ScreenCache[$screenName] = $screen
                Write-Log -Level Debug -Message "Cached screen: $screenName" -Component "ScreenFactory"
            }
            
            return $screen
        }
    }
    
    [void] RegisterScreen([string]$screenName, [type]$screenType) {
        if ([string]::IsNullOrWhiteSpace($screenName)) {
            throw [System.ArgumentException]::new("Screen name cannot be null or empty")
        }
        
        if ($null -eq $screenType) {
            throw [System.ArgumentNullException]::new("screenType", "Screen type cannot be null")
        }
        
        # Validate the type inherits from Screen
        if (-not $screenType.IsSubclassOf([Screen])) {
            throw [System.ArgumentException]::new(
                "Screen type must inherit from Screen class"
            )
        }
        
        $this.ScreenTypes[$screenName] = $screenType
        Write-Log -Level Info -Message "Registered screen type: $screenName" -Component "ScreenFactory"
        
        # Clear cache for this screen if caching is enabled
        if ($this.EnableCaching -and $this.ScreenCache.ContainsKey($screenName)) {
            $this.ScreenCache.Remove($screenName)
        }
    }
    
    [void] UnregisterScreen([string]$screenName) {
        if ($this.ScreenTypes.ContainsKey($screenName)) {
            $this.ScreenTypes.Remove($screenName)
            Write-Log -Level Info -Message "Unregistered screen type: $screenName" -Component "ScreenFactory"
            
            # Clear cache
            if ($this.ScreenCache.ContainsKey($screenName)) {
                $this.ScreenCache.Remove($screenName)
            }
        }
    }
    
    [string[]] GetRegisteredScreens() {
        return $this.ScreenTypes.Keys | Sort-Object
    }
    
    [bool] IsScreenRegistered([string]$screenName) {
        return $this.ScreenTypes.ContainsKey($screenName)
    }
    
    [void] ClearCache() {
        if ($this.EnableCaching) {
            $count = $this.ScreenCache.Count
            $this.ScreenCache.Clear()
            Write-Log -Level Info -Message "Cleared $count cached screens" -Component "ScreenFactory"
        }
    }
    
    [void] ClearCacheForScreen([string]$screenName) {
        if ($this.EnableCaching -and $this.ScreenCache.ContainsKey($screenName)) {
            $this.ScreenCache.Remove($screenName)
            Write-Log -Level Debug -Message "Cleared cache for screen: $screenName" -Component "ScreenFactory"
        }
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\services\task-services.psm1
# Task Service Module
# Manages all state and business logic related to tasks
# Replaces the old app-store pattern for task management

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Initialize-TaskService {
    <#
    .SYNOPSIS
    Initializes the Task Service with PowerShell-First architecture
    
    .DESCRIPTION
    Creates and returns a service object that manages task state and operations.
    Uses PowerShell's native eventing engine for state change notifications.
    
    .OUTPUTS
    [PSCustomObject] The initialized Task Service instance
    #>
    
    Invoke-WithErrorHandling -Component "TaskService.Initialize" -Context "Initializing Task Service" -ScriptBlock {
        Write-Log -Level Info -Message "Initializing Task Service"
        
        # Create the service object
        $service = [PSCustomObject]@{
            _tasks = @()  # Private array to hold tasks
            _isInitialized = $false
        }
        
        # Register the service's events with PowerShell's native engine
        Register-EngineEvent -SourceIdentifier "TaskService" -SupportEvent
        Write-Log -Level Debug -Message "Registered TaskService engine event"
        
        # AddTask method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "AddTask" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [hashtable]$taskData
            )
            
            Invoke-WithErrorHandling -Component "TaskService.AddTask" -Context "Adding new task" -ScriptBlock {
                # Defensive validation
                if (-not $taskData) {
                    Write-Log -Level Warning -Message "AddTask: No task data provided"
                    return
                }
                
                if (-not $taskData.Title -or [string]::IsNullOrWhiteSpace($taskData.Title)) {
                    Write-Log -Level Warning -Message "AddTask: No title provided"
                    return
                }
                
                Write-Log -Level Info -Message "Adding new task: $($taskData.Title)"
                
                # Create new task with all required fields
                $newTask = @{
                    id = [Guid]::NewGuid().ToString()
                    title = $taskData.Title.Trim()
                    description = if ($taskData.Description) { $taskData.Description } else { "" }
                    completed = $false
                    priority = if ($taskData.Priority) { $taskData.Priority } else { "medium" }
                    project = if ($taskData.Category) { $taskData.Category } else { "General" }
                    due_date = if ($taskData.DueDate) { $taskData.DueDate } else { $null }
                    created_at = (Get-Date).ToString("o")
                    updated_at = (Get-Date).ToString("o")
                }
                
                # Add to internal task array
                $this._tasks = @($this._tasks) + $newTask
                
                Write-Log -Level Debug -Message "Task created with ID: $($newTask.id)"
                
                # Persist if data manager available
                if ($global:Data) {
                    if (-not $global:Data.ContainsKey('Tasks')) {
                        $global:Data.Tasks = @()
                    }
                    $global:Data.Tasks = @($global:Data.Tasks) + $newTask
                    
                    if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                        Save-UnifiedData
                        Write-Log -Level Debug -Message "Task data persisted"
                    }
                }
                
                # Announce state change using native PowerShell eventing
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Tasks.Changed" -MessageData @{
                    Action = "TaskAdded"
                    TaskId = $newTask.id
                    Task = $newTask
                }
                
                Write-Log -Level Info -Message "Task added successfully: $($newTask.id)"
                return $newTask
            }
        }
        
        # UpdateTask method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "UpdateTask" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [string]$taskId,
                
                [Parameter(Mandatory = $true)]
                [hashtable]$updates
            )
            
            Invoke-WithErrorHandling -Component "TaskService.UpdateTask" -Context "Updating task" -ScriptBlock {
                # Defensive validation
                if (-not $taskId) {
                    Write-Log -Level Warning -Message "UpdateTask: No TaskId provided"
                    return
                }
                
                if (-not $updates -or $updates.Count -eq 0) {
                    Write-Log -Level Warning -Message "UpdateTask: No updates provided"
                    return
                }
                
                Write-Log -Level Info -Message "Updating task: $taskId"
                
                # Find task in internal array
                $taskIndex = -1
                for ($i = 0; $i -lt $this._tasks.Count; $i++) {
                    if ($this._tasks[$i].id -eq $taskId) {
                        $taskIndex = $i
                        break
                    }
                }
                
                if ($taskIndex -eq -1) {
                    Write-Log -Level Warning -Message "UpdateTask: Task not found with ID $taskId"
                    return
                }
                
                # Update task fields
                $task = $this._tasks[$taskIndex]
                if ($updates.ContainsKey('Title') -and $updates.Title) { 
                    $task.title = $updates.Title.Trim() 
                }
                if ($updates.ContainsKey('Description')) { 
                    $task.description = $updates.Description 
                }
                if ($updates.ContainsKey('Priority')) { 
                    $task.priority = $updates.Priority 
                }
                if ($updates.ContainsKey('Category')) { 
                    $task.project = $updates.Category 
                }
                if ($updates.ContainsKey('DueDate')) { 
                    $task.due_date = $updates.DueDate 
                }
                if ($updates.ContainsKey('Completed')) { 
                    $task.completed = $updates.Completed 
                }
                
                $task.updated_at = (Get-Date).ToString("o")
                
                Write-Log -Level Debug -Message "Task updated: $taskId"
                
                # Update in global data if available
                if ($global:Data -and $global:Data.Tasks) {
                    $globalIndex = -1
                    for ($i = 0; $i -lt $global:Data.Tasks.Count; $i++) {
                        if ($global:Data.Tasks[$i].id -eq $taskId) {
                            $globalIndex = $i
                            break
                        }
                    }
                    
                    if ($globalIndex -ne -1) {
                        $global:Data.Tasks[$globalIndex] = $task
                        
                        if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                            Save-UnifiedData
                            Write-Log -Level Debug -Message "Task data persisted"
                        }
                    }
                }
                
                # Announce state change using native PowerShell eventing
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Tasks.Changed" -MessageData @{
                    Action = "TaskUpdated"
                    TaskId = $taskId
                    Task = $task
                    Updates = $updates
                }
                
                Write-Log -Level Info -Message "Task updated successfully: $taskId"
                return $task
            }
        }
        
        # DeleteTask method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "DeleteTask" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [string]$taskId
            )
            
            Invoke-WithErrorHandling -Component "TaskService.DeleteTask" -Context "Deleting task" -ScriptBlock {
                # Defensive validation
                if (-not $taskId) {
                    Write-Log -Level Warning -Message "DeleteTask: No TaskId provided"
                    return $false
                }
                
                Write-Log -Level Info -Message "Deleting task: $taskId"
                
                # Find and remove from internal array
                $originalCount = $this._tasks.Count
                $deletedTask = $null
                
                $newTasks = @()
                foreach ($task in $this._tasks) {
                    if ($task.id -eq $taskId) {
                        $deletedTask = $task
                    } else {
                        $newTasks += $task
                    }
                }
                
                $this._tasks = $newTasks
                
                if (-not $deletedTask) {
                    Write-Log -Level Warning -Message "DeleteTask: Task not found with ID $taskId"
                    return $false
                }
                
                Write-Log -Level Debug -Message "Task removed from internal array: $taskId"
                
                # Remove from global data if available
                if ($global:Data -and $global:Data.Tasks) {
                    $global:Data.Tasks = @($global:Data.Tasks | Where-Object { 
                        $_ -and $_.id -ne $taskId 
                    })
                    
                    if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                        Save-UnifiedData
                        Write-Log -Level Debug -Message "Task data persisted"
                    }
                }
                
                # Announce state change using native PowerShell eventing
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Tasks.Changed" -MessageData @{
                    Action = "TaskDeleted"
                    TaskId = $taskId
                    Task = $deletedTask
                }
                
                Write-Log -Level Info -Message "Task deleted successfully: $taskId"
                return $true
            }
        }
        
        # GetTasks method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetTasks" -Value {
            param(
                [switch]$ActiveOnly
            )
            
            Invoke-WithErrorHandling -Component "TaskService.GetTasks" -Context "Getting tasks" -ScriptBlock {
                Write-Log -Level Debug -Message "Getting tasks (ActiveOnly: $ActiveOnly)"
                
                $tasks = @($this._tasks)
                
                if ($ActiveOnly) {
                    $tasks = @($tasks | Where-Object { 
                        $_ -and $_.ContainsKey('completed') -and (-not $_.completed) 
                    })
                }
                
                Write-Log -Level Debug -Message "Returning $($tasks.Count) tasks"
                return $tasks
            }
        }
        
        # GetTaskById method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetTaskById" -Value {
            param(
                [Parameter(Mandatory = $true)]
                [string]$taskId
            )
            
            Invoke-WithErrorHandling -Component "TaskService.GetTaskById" -Context "Getting task by ID" -ScriptBlock {
                if (-not $taskId) {
                    Write-Log -Level Warning -Message "GetTaskById: No TaskId provided"
                    return $null
                }
                
                foreach ($task in $this._tasks) {
                    if ($task.id -eq $taskId) {
                        return $task
                    }
                }
                
                Write-Log -Level Debug -Message "GetTaskById: Task not found with ID $taskId"
                return $null
            }
        }
        
        # GetTasksForDisplay method (formatted for UI tables)
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetTasksForDisplay" -Value {
            Invoke-WithErrorHandling -Component "TaskService.GetTasksForDisplay" -Context "Getting tasks for display" -ScriptBlock {
                Write-Log -Level Debug -Message "Getting tasks for display"
                
                $tasksForTable = @()
                
                foreach ($task in $this._tasks) {
                    if (-not $task) { continue }
                    
                    # Safe property access with defaults
                    $taskItem = @{
                        Id = if ($task.ContainsKey('id')) { $task.id } else { [Guid]::NewGuid().ToString() }
                        Status = if ($task.ContainsKey('completed') -and $task.completed) { "‚úì" } else { "‚óã" }
                        Priority = if ($task.ContainsKey('priority')) { $task.priority } else { "medium" }
                        Title = if ($task.ContainsKey('title')) { $task.title } else { "Untitled" }
                        Category = if ($task.ContainsKey('project')) { $task.project } else { "General" }
                        DueDate = "N/A"
                    }
                    
                    # Safe date parsing
                    if ($task.ContainsKey('due_date') -and $task.due_date) {
                        try {
                            $taskItem.DueDate = ([DateTime]$task.due_date).ToString("yyyy-MM-dd")
                        } catch {
                            $taskItem.DueDate = "Invalid"
                        }
                    }
                    
                    $tasksForTable += $taskItem
                }
                
                Write-Log -Level Debug -Message "Returning $($tasksForTable.Count) tasks for display"
                return @($tasksForTable)
            }
        }
        
        # GetStatistics method
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "GetStatistics" -Value {
            Invoke-WithErrorHandling -Component "TaskService.GetStatistics" -Context "Calculating task statistics" -ScriptBlock {
                Write-Log -Level Debug -Message "Calculating task statistics"
                
                $stats = @{
                    TotalTasks = $this._tasks.Count
                    ActiveTasks = 0
                    CompletedTasks = 0
                    HighPriorityTasks = 0
                    OverdueTasks = 0
                }
                
                $today = Get-Date
                
                foreach ($task in $this._tasks) {
                    if (-not $task) { continue }
                    
                    if ($task.ContainsKey('completed') -and $task.completed) {
                        $stats.CompletedTasks++
                    } else {
                        $stats.ActiveTasks++
                    }
                    
                    if ($task.ContainsKey('priority') -and $task.priority -eq 'high') {
                        $stats.HighPriorityTasks++
                    }
                    
                    if ($task.ContainsKey('due_date') -and $task.due_date -and -not $task.completed) {
                        try {
                            $dueDate = [DateTime]$task.due_date
                            if ($dueDate -lt $today) {
                                $stats.OverdueTasks++
                            }
                        } catch {
                            # Invalid date format
                        }
                    }
                }
                
                Write-Log -Level Debug -Message "Statistics calculated: Total=$($stats.TotalTasks), Active=$($stats.ActiveTasks)"
                return $stats
            }
        }
        
        # Initialize method - loads tasks from global data
        Add-Member -InputObject $service -MemberType ScriptMethod -Name "Initialize" -Value {
            Invoke-WithErrorHandling -Component "TaskService.Initialize" -Context "Loading task data" -ScriptBlock {
                if ($this._isInitialized) {
                    Write-Log -Level Debug -Message "TaskService already initialized"
                    return
                }
                
                Write-Log -Level Info -Message "Initializing TaskService data"
                
                # Load tasks from global data if available
                if ($global:Data -and $global:Data.ContainsKey('Tasks')) {
                    $this._tasks = @($global:Data.Tasks)
                    Write-Log -Level Info -Message "Loaded $($this._tasks.Count) tasks from global data"
                } else {
                    $this._tasks = @()
                    Write-Log -Level Info -Message "No existing tasks found, starting with empty list"
                }
                
                $this._isInitialized = $true
                
                # Announce initialization complete
                New-Event -SourceIdentifier "TaskService" -EventIdentifier "Service.Initialized" -MessageData @{
                    TaskCount = $this._tasks.Count
                }
            }
        }
        
        # Initialize the service
        $service.Initialize()
        
        Write-Log -Level Info -Message "Task Service initialized successfully"
        return $service
    }
}

# Export the initialization function
Export-ModuleMember -Function Initialize-TaskService


####\utilities\DO_NOT_USE\file_util.ps1
# --- CONFIGURATION ---
# The root folder of your existing structure where the files are located.
# This script will search recursively starting from here.
$sourceFolderStructureRoot = "C:\Users\jhnhe\Documents\GitHub\_HELIOS"

# The separate folder where files will be copied and renamed.
$destDir = "C:\Users\jhnhe\Documents\GitHub\_HELIOS\Copies"

# Path to the text file listing the filenames to process.
$fileListPath = "C:\Users\jhnhe\Documents\GitHub\_HELIOS\file_list.txt"


#
# === KEY RENAMING SETTINGS ===
#


# The NEW file extension for all processed files (e.g., ".log", ".txt"). Include the dot.
$newExtension = ".txt"

# A prefix to add to the renamed files (optional, can be "").
$newPrefix = "_"

# Set to $true to automatically delete all files in the destination
# folder before the script runs. This prevents "already exists" errors on re-runs.
$cleanDestinationBeforeRun = $true

# --- CONCATENATION SETTINGS ---
$doConcatenate = $true
$concatenatedFile = "all_processed_data.txt"

# --- SCRIPT (No need to edit below this line) ---

Write-Host "--- Starting File Processing ---" -ForegroundColor Green

# Resolve paths and perform initial checks
try {
    $sourceFolderStructureRoot = (Resolve-Path $sourceFolderStructureRoot -ErrorAction Stop).Path
    $destDir = (Resolve-Path $destDir -ErrorAction Stop).Path
    $fileListPath = (Resolve-Path $fileListPath -ErrorAction Stop).Path
} catch { Write-Error "Error resolving paths. Check your configuration."; Read-Host "Press Enter to exit"; Exit }

if (-not (Test-Path $fileListPath)) { Write-Error "File list not found: $fileListPath"; Read-Host "Press Enter to exit"; Exit }
$filesToProcess = Get-Content $fileListPath -ErrorAction Stop

# Ensure destination directory exists, create if not
if (-not (Test-Path $destDir -PathType Container)) {
    Write-Host "Destination directory '$destDir' not found. Creating it..." -ForegroundColor Yellow
    New-Item -Path $destDir -ItemType Directory | Out-Null
}

if ($cleanDestinationBeforeRun) {
    Write-Host "Cleaning destination directory: $destDir" -ForegroundColor Yellow
    Get-ChildItem -Path $destDir | Remove-Item -Recurse -Force
}

Write-Host "`n--- Step 1 & 2: Backing up (Copying) and Renaming Specified Files ---" -ForegroundColor Green
$renamedFiles = @()

# === CORE LOGIC CHANGE IS HERE ===
foreach ($filePathInList in $filesToProcess) {
    # Skip empty lines in the file list
    if ([string]::IsNullOrWhiteSpace($filePathInList)) { continue }

    # Construct the full path to the source file.
    # This handles both full paths (C:\...) and relative paths (subfolder\file.txt) in your list.
    $fullSourcePath = Join-Path -Path $sourceFolderStructureRoot -ChildPath $filePathInList
    if ([System.IO.Path]::IsPathRooted($filePathInList)) {
        $fullSourcePath = $filePathInList
    }

    Write-Host "Processing: '$fullSourcePath'" -ForegroundColor Cyan

    # Check if the specified file actually exists before trying to process it
    if (-not (Test-Path $fullSourcePath -PathType Leaf)) {
        Write-Warning "  SKIPPED: File not found at the specified path: '$fullSourcePath'"
        continue # Move to the next file in the list
    }

    # Get the file object for the validated path
    $sourceFile = Get-Item -Path $fullSourcePath

    # Construct a unique new name for the destination file
    $baseFileName = $sourceFile.BaseName
    $newFileName = "$newPrefix$baseFileName$newExtension"
    
    # In case of duplicate filenames from different subfolders, add parent folder to name
    if (($renamedFiles.Name).Contains($newFileName)) {
        $parentFolderName = $sourceFile.Directory.Name
        $newFileName = "$newPrefix${baseFileName}_$parentFolderName$newExtension"
    }

    try {
        # 1. BACKUP: Copy the exact file to the destination
        $copiedFile = Copy-Item -Path $sourceFile.FullName -Destination $destDir -PassThru -ErrorAction Stop
        
        # 2. RENAME: Rename the copy in the destination folder
        $renamedFile = Rename-Item -Path $copiedFile.FullName -NewName $newFileName -PassThru -ErrorAction Stop
        
        Write-Host "  OK: Copied and renamed to '$($renamedFile.Name)'"
        $renamedFiles += $renamedFile
    } catch {
        Write-Error "  FAILED: Error during copy or rename of '$($sourceFile.FullName)'"
        Write-Error "  $($_.Exception.Message)"
    }
}

# --- Step 3: (Optional) Concatenate the Files ---
if ($doConcatenate -and $renamedFiles.Count -gt 0) {
    Write-Host "`n--- Step 3: Concatenating Files ---" -ForegroundColor Green
    $concatenatedFilePath = Join-Path -Path $destDir -ChildPath $concatenatedFile
    if (Test-Path $concatenatedFilePath) { Remove-Item -Path $concatenatedFilePath -Force }
    Write-Host "Creating combined file '$concatenatedFile'..."
    Get-Content -Path $renamedFiles.FullName | Set-Content -Path $concatenatedFilePath
    Write-Host "All processed files have been concatenated into '$concatenatedFilePath'" -ForegroundColor Green
} elseif ($doConcatenate) {
    Write-Warning "`nConcatenation skipped: No files were successfully processed."
}

Write-Host "`n--- Process Complete! ---" -ForegroundColor Green
Read-Host "Press Enter to exit"


####\utilities\context-helpers.psm1
# Context capture helper for consistent handler creation
function New-ContextHandler {
    param(
        [hashtable]$CapturedContext,
        [scriptblock]$Handler
    )
    
    # Create a closure that captures the context
    $wrapper = {
        param($Event, $Args)
        $context = $CapturedContext
        & $Handler -Context $context -Event $Event -Args $Args
    }.GetNewClosure()
    
    # Store the captured context for debugging
    Add-Member -InputObject $wrapper -MemberType NoteProperty -Name "_CapturedContext" -Value $CapturedContext
    
    return $wrapper
}

# Screen context capture helper
function Get-ScreenContext {
    param([hashtable]$Screen)
    
    return @{
        Screen = $Screen
        Services = $Screen._services
        Store = $Screen._services.Store
        Navigation = $Screen._services.Navigation
        Components = $Screen.Components
    }
}

# Safe method invocation helper
function Invoke-SafeMethod {
    param(
        [hashtable]$Object,
        [string]$MethodName,
        [hashtable]$Parameters = @{}
    )
    
    if (-not $Object) {
        Write-Log -Level Warning -Message "Cannot invoke $MethodName on null object"
        return $null
    }
    
    if (-not $Object[$MethodName]) {
        Write-Log -Level Warning -Message "Method $MethodName not found on object"
        return $null
    }
    
    try {
        return & $Object[$MethodName] -self $Object @Parameters
    } catch {
        Write-Log -Level Error -Message "Error invoking $MethodName" -Data $_
        throw
    }
}

Export-ModuleMember -Function @(
    'New-ContextHandler',
    'Get-ScreenContext',
    'Invoke-SafeMethod'
)



####\utilities\error-handling-fix.psm1
# Fixed Error Handling Wrapper for PowerShell Classes
# Solves parameter binding issues with Context parameter

function global:Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Component,
        
        [Parameter(Mandatory = $true)]
        [string]$Context,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$AdditionalData = @{}
    )
    
    # Validate parameters
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown"
    }
    
    try {
        # Execute the script block
        & $ScriptBlock
    }
    catch {
        # Create enriched error data
        $errorData = @{
            Component = $Component
            Context = $Context
            Error = $_
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Merge additional data
        foreach ($key in $AdditionalData.Keys) {
            $errorData[$key] = $AdditionalData[$key]
        }
        
        # Log the error if logging is available
        if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$Component' during '$Context': $($_.Exception.Message)" -Data $errorData
        }
        
        # Re-throw the original exception
        throw
    }
}

# Fixed version for use in classes
function global:Invoke-ClassMethod {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ClassName,
        
        [Parameter(Mandatory = $true)]
        [string]$MethodName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    
    # Ensure parameters are valid
    $component = if ([string]::IsNullOrWhiteSpace($ClassName)) { "UnknownClass" } else { $ClassName }
    $context = if ([string]::IsNullOrWhiteSpace($MethodName)) { "UnknownMethod" } else { $MethodName }
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorInfo = @{
            ClassName = $component
            MethodName = $context
            ErrorMessage = $_.Exception.Message
            StackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Add any additional data
        foreach ($key in $Data.Keys) {
            if (-not $errorInfo.ContainsKey($key)) {
                $errorInfo[$key] = $Data[$key]
            }
        }
        
        if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "[$component.$context] $($_.Exception.Message)" -Data $errorInfo
        }
        
        throw
    }
}

# Export the functions
Export-ModuleMember -Function @('Invoke-WithErrorHandling', 'Invoke-ClassMethod')


####\utilities\error-handling.psm1
# Fixed Error Handling Utilities Module for PMC Terminal v5
# Provides centralized error handling with consistent parameter patterns
# AI: Simplified and robust error handling to prevent parameter binding conflicts

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Initialize log file path
$script:LogFilePath = Join-Path -Path $env:TEMP -ChildPath "PMCTerminal_$(Get-Date -Format 'yyyy-MM-dd').log"
$script:MaxLogSizeMB = 10
$script:LogLevel = "Info"

# Log levels enumeration
enum LogLevel {
    Debug = 0
    Info = 1
    Warning = 2
    Error = 3
    Critical = 4
}

# AI: Simplified Invoke-WithErrorHandling with consistent parameter pattern
function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string]$Component,
        
        [Parameter(Mandatory = $true, Position = 1)]
        [string]$Context,
        
        [Parameter(Mandatory = $true, Position = 2)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory = $false)]
        [hashtable]$AdditionalData = @{}
    )
    
    # Validate parameters
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown"
    }
    
    $startTime = [DateTime]::Now
    
    try {
        Write-Log -Level Debug -Message "Starting operation" -Component $Component -Context $Context
        
        # Execute the script block
        $result = & $ScriptBlock
        
        Write-Log -Level Debug -Message "Operation completed successfully" -Component $Component -Context $Context
        return $result
    }
    catch {
        # Create enriched error data
        $errorData = @{
            Component = $Component
            Context = $Context
            Error = $_.Exception.Message
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
            Duration = ([DateTime]::Now - $startTime).TotalMilliseconds
            Timestamp = Get-Date
        }
        
        # Merge additional data
        foreach ($key in $AdditionalData.Keys) {
            $errorData[$key] = $AdditionalData[$key]
        }
        
        # Log the error
        Write-Log -Level Error -Message "Error in '$Component' during '$Context': $($_.Exception.Message)" -ErrorDetails $errorData
        
        # Publish error event for global handling
        if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Application.Error" -Data $errorData
        }
        
        # Re-throw the original exception
        throw
    }
    finally {
        $duration = ([DateTime]::Now - $startTime).TotalMilliseconds
        Write-Log -Level Debug -Message "Operation duration: $duration ms" -Component $Component -Context $Context
    }
}

# AI: Simplified version for use in classes
function Invoke-ClassMethod {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ClassName,
        
        [Parameter(Mandatory = $true)]
        [string]$MethodName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    
    # Ensure parameters are valid
    $component = if ([string]::IsNullOrWhiteSpace($ClassName)) { "UnknownClass" } else { $ClassName }
    $context = if ([string]::IsNullOrWhiteSpace($MethodName)) { "UnknownMethod" } else { $MethodName }
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorInfo = @{
            ClassName = $component
            MethodName = $context
            ErrorMessage = $_.Exception.Message
            StackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Add any additional data
        foreach ($key in $Data.Keys) {
            if (-not $errorInfo.ContainsKey($key)) {
                $errorInfo[$key] = $Data[$key]
            }
        }
        
        Write-Log -Level Error -Message "[$component.$context] $($_.Exception.Message)" -ErrorDetails $errorInfo
        throw
    }
}

# Write-Log - Centralized logging function
function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Debug", "Info", "Warning", "Error", "Critical")]
        [string]$Level,
        
        [Parameter(Mandatory = $true)]
        [string]$Message,
        
        [Parameter(Mandatory = $false)]
        [string]$Component = "Unknown",
        
        [Parameter(Mandatory = $false)]
        [string]$Context = "",
        
        [Parameter(Mandatory = $false)]
        [hashtable]$ErrorDetails = @{}
    )
    
    # Check if we should log based on current log level
    $currentLevel = [LogLevel]::$script:LogLevel
    $messageLevel = [LogLevel]::$Level
    
    if ($messageLevel -lt $currentLevel) {
        return
    }
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
    $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
    
    # Format log entry
    $logEntry = "$timestamp [$Level] [$Component"
    if (-not [string]::IsNullOrWhiteSpace($Context)) {
        $logEntry += "::$Context"
    }
    $logEntry += "] [Thread:$threadId] $Message"
    
    # Add error details if provided
    if ($ErrorDetails.Count -gt 0) {
        $logEntry += " | Details: " + ($ErrorDetails | ConvertTo-Json -Compress -Depth 3)
    }
    
    # Write to console with color coding
    $consoleColor = switch ($Level) {
        "Debug" { "DarkGray" }
        "Info" { "White" }
        "Warning" { "Yellow" }
        "Error" { "Red" }
        "Critical" { "Magenta" }
    }
    
    if ($Level -in @("Error", "Critical")) {
        Write-Host $logEntry -ForegroundColor $consoleColor -ErrorAction SilentlyContinue
    }
    elseif ($Level -eq "Warning") {
        Write-Warning $logEntry -ErrorAction SilentlyContinue
    }
    else {
        Write-Verbose $logEntry -ErrorAction SilentlyContinue
    }
    
    # Write to log file
    try {
        # Check log file size and rotate if needed
        if (Test-Path $script:LogFilePath) {
            $logFile = Get-Item $script:LogFilePath
            if ($logFile.Length -gt ($script:MaxLogSizeMB * 1MB)) {
                $archivePath = $script:LogFilePath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                Move-Item -Path $script:LogFilePath -Destination $archivePath -Force
            }
        }
        
        # Append to log file
        Add-Content -Path $script:LogFilePath -Value $logEntry -ErrorAction SilentlyContinue
    }
    catch {
        # Silently fail if unable to write to log file
    }
}

# Set-LogLevel - Configure the minimum log level
function Set-LogLevel {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Debug", "Info", "Warning", "Error", "Critical")]
        [string]$Level
    )
    
    $script:LogLevel = $Level
    Write-Log -Level Info -Message "Log level set to: $Level" -Component "Logging"
}

# Get-LogLevel - Get the current log level
function Get-LogLevel {
    return $script:LogLevel
}

# Export all functions
Export-ModuleMember -Function @(
    'Invoke-WithErrorHandling',
    'Invoke-ClassMethod',
    'Write-Log',
    'Set-LogLevel',
    'Get-LogLevel'
)



####\utilities\event-system.psm1
# Event System Module for PMC Terminal v5
# Provides a centralized event publishing and subscription system
# AI: Implements the event-driven architecture for loose coupling between components

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import error handling utilities
Import-Module -Name "$PSScriptRoot\error-handling.psm1" -Force

# Script-level variables for event management
$script:EventSubscriptions = @{}
$script:EventHistory = [System.Collections.Generic.List[PSCustomObject]]::new()
$script:MaxEventHistorySize = 1000
$script:EventQueueEnabled = $false
$script:EventQueue = [System.Collections.Generic.Queue[PSCustomObject]]::new()

# Publish-Event - Broadcast an event to all subscribers
function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $false)]
        [object]$Data = $null,
        
        [Parameter(Mandatory = $false)]
        [hashtable]$Metadata = @{}
    )
    
    Invoke-WithErrorHandling -Component "EventSystem" -Context "PublishEvent:$EventName" -ScriptBlock {
        $eventInfo = [PSCustomObject]@{
            EventName = $EventName
            Data = $Data
            Metadata = $Metadata
            Timestamp = [DateTime]::Now
            PublisherId = [System.Diagnostics.Process]::GetCurrentProcess().Id
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        Write-Log -Level Debug -Message "Publishing event: $EventName" -Component "EventSystem"
        
        # Add to event history
        $script:EventHistory.Add($eventInfo)
        
        # Trim history if needed
        if ($script:EventHistory.Count -gt $script:MaxEventHistorySize) {
            $script:EventHistory.RemoveAt(0)
        }
        
        # Queue event if queuing is enabled
        if ($script:EventQueueEnabled) {
            $script:EventQueue.Enqueue($eventInfo)
            Write-Log -Level Debug -Message "Event queued: $EventName (Queue size: $($script:EventQueue.Count))" -Component "EventSystem"
            return
        }
        
        # Trigger PowerShell engine event
        New-Event -SourceIdentifier $EventName -MessageData $Data
        
        # Call direct subscribers if any
        if ($script:EventSubscriptions.ContainsKey($EventName)) {
            $subscribers = @($script:EventSubscriptions[$EventName])
            Write-Log -Level Debug -Message "Found $($subscribers.Count) subscribers for event: $EventName" -Component "EventSystem"
            
            foreach ($subscriber in $subscribers) {
                try {
                    Write-Log -Level Debug -Message "Invoking subscriber: $($subscriber.Id)" -Component "EventSystem"
                    
                    # Create event args
                    $eventArgs = [PSCustomObject]@{
                        EventName = $EventName
                        Data = $Data
                        Metadata = $Metadata
                        Timestamp = $eventInfo.Timestamp
                    }
                    
                    # Invoke subscriber
                    & $subscriber.Action $eventArgs
                }
                catch {
                    Write-Log -Level Error -Message "Subscriber failed for event '$EventName': $_" -Component "EventSystem"
                    
                    # Optionally remove failed subscriber if configured
                    if ($subscriber.RemoveOnError) {
                        Unsubscribe-Event -EventName $EventName -SubscriberId $subscriber.Id
                    }
                }
            }
        }
    }
}

# Subscribe-Event - Register a handler for an event
function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Action,
        
        [Parameter(Mandatory = $false)]
        [string]$SubscriberId = [Guid]::NewGuid().ToString(),
        
        [Parameter(Mandatory = $false)]
        [bool]$RemoveOnError = $false,
        
        [Parameter(Mandatory = $false)]
        [int]$Priority = 0
    )
    
    Invoke-WithErrorHandling -Component "EventSystem" -Context "SubscribeEvent:$EventName" -ScriptBlock {
        Write-Log -Level Debug -Message "Subscribing to event: $EventName (ID: $SubscriberId)" -Component "EventSystem"
        
        # Initialize subscription list if needed
        if (-not $script:EventSubscriptions.ContainsKey($EventName)) {
            $script:EventSubscriptions[$EventName] = @()
        }
        
        # Check if subscriber already exists
        $existingSubscriber = $script:EventSubscriptions[$EventName] | 
            Where-Object { $_.Id -eq $SubscriberId } | 
            Select-Object -First 1
            
        if ($null -ne $existingSubscriber) {
            Write-Log -Level Warning -Message "Subscriber '$SubscriberId' already exists for event '$EventName'. Updating." -Component "EventSystem"
            Unsubscribe-Event -EventName $EventName -SubscriberId $SubscriberId
        }
        
        # Create subscriber object
        $subscriber = [PSCustomObject]@{
            Id = $SubscriberId
            Action = $Action
            Priority = $Priority
            RemoveOnError = $RemoveOnError
            SubscribedAt = [DateTime]::Now
            EventName = $EventName
        }
        
        # Add subscriber to list (sorted by priority)
        $script:EventSubscriptions[$EventName] = @($script:EventSubscriptions[$EventName] + $subscriber) | 
            Sort-Object -Property Priority -Descending
        
        Write-Log -Level Info -Message "Successfully subscribed to event: $EventName" -Component "EventSystem"
        
        return $SubscriberId
    }
}

# Unsubscribe-Event - Remove an event handler
function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$SubscriberId
    )
    
    Invoke-WithErrorHandling -Component "EventSystem" -Context "UnsubscribeEvent:$EventName" -ScriptBlock {
        Write-Log -Level Debug -Message "Unsubscribing from event: $EventName (ID: $SubscriberId)" -Component "EventSystem"
        
        if (-not $script:EventSubscriptions.ContainsKey($EventName)) {
            Write-Log -Level Warning -Message "No subscriptions found for event: $EventName" -Component "EventSystem"
            return
        }
        
        $initialCount = $script:EventSubscriptions[$EventName].Count
        $script:EventSubscriptions[$EventName] = @($script:EventSubscriptions[$EventName] | 
            Where-Object { $_.Id -ne $SubscriberId })
        
        $removed = $initialCount - $script:EventSubscriptions[$EventName].Count
        
        if ($removed -gt 0) {
            Write-Log -Level Info -Message "Successfully unsubscribed from event: $EventName" -Component "EventSystem"
            
            # Clean up empty subscription lists
            if ($script:EventSubscriptions[$EventName].Count -eq 0) {
                $script:EventSubscriptions.Remove($EventName)
            }
        }
        else {
            Write-Log -Level Warning -Message "Subscriber '$SubscriberId' not found for event '$EventName'" -Component "EventSystem"
        }
    }
}

# Clear-EventSubscriptions - Remove all subscriptions for an event or all events
function Clear-EventSubscriptions {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$EventName = $null
    )
    
    if ([string]::IsNullOrWhiteSpace($EventName)) {
        Write-Log -Level Info -Message "Clearing all event subscriptions" -Component "EventSystem"
        $script:EventSubscriptions.Clear()
    }
    else {
        Write-Log -Level Info -Message "Clearing subscriptions for event: $EventName" -Component "EventSystem"
        if ($script:EventSubscriptions.ContainsKey($EventName)) {
            $script:EventSubscriptions.Remove($EventName)
        }
    }
}

# Get-EventSubscriptions - Get current subscriptions
function Get-EventSubscriptions {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$EventName = $null
    )
    
    if ([string]::IsNullOrWhiteSpace($EventName)) {
        return $script:EventSubscriptions
    }
    else {
        if ($script:EventSubscriptions.ContainsKey($EventName)) {
            return $script:EventSubscriptions[$EventName]
        }
        return @()
    }
}

# Get-EventHistory - Retrieve event history
function Get-EventHistory {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$EventName = $null,
        
        [Parameter(Mandatory = $false)]
        [int]$Last = 0,
        
        [Parameter(Mandatory = $false)]
        [DateTime]$Since = [DateTime]::MinValue
    )
    
    $history = $script:EventHistory
    
    # Filter by event name
    if (-not [string]::IsNullOrWhiteSpace($EventName)) {
        $history = $history | Where-Object { $_.EventName -eq $EventName }
    }
    
    # Filter by time
    if ($Since -ne [DateTime]::MinValue) {
        $history = $history | Where-Object { $_.Timestamp -ge $Since }
    }
    
    # Get last N events
    if ($Last -gt 0) {
        $history = $history | Select-Object -Last $Last
    }
    
    return $history
}

# Clear-EventHistory - Clear the event history
function Clear-EventHistory {
    [CmdletBinding()]
    param()
    
    Write-Log -Level Info -Message "Clearing event history" -Component "EventSystem"
    $script:EventHistory.Clear()
}

# Enable-EventQueue - Enable event queuing
function Enable-EventQueue {
    [CmdletBinding()]
    param()
    
    $script:EventQueueEnabled = $true
    Write-Log -Level Info -Message "Event queuing enabled" -Component "EventSystem"
}

# Disable-EventQueue - Disable event queuing and process queued events
function Disable-EventQueue {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [bool]$ProcessQueue = $true
    )
    
    $script:EventQueueEnabled = $false
    Write-Log -Level Info -Message "Event queuing disabled" -Component "EventSystem"
    
    if ($ProcessQueue) {
        Process-EventQueue
    }
    else {
        $script:EventQueue.Clear()
    }
}

# Process-EventQueue - Process all queued events
function Process-EventQueue {
    [CmdletBinding()]
    param()
    
    $queueSize = $script:EventQueue.Count
    Write-Log -Level Info -Message "Processing event queue (Size: $queueSize)" -Component "EventSystem"
    
    $processed = 0
    while ($script:EventQueue.Count -gt 0) {
        $eventInfo = $script:EventQueue.Dequeue()
        
        # Re-publish the event
        Publish-Event -EventName $eventInfo.EventName -Data $eventInfo.Data -Metadata $eventInfo.Metadata
        $processed++
    }
    
    Write-Log -Level Info -Message "Processed $processed queued events" -Component "EventSystem"
}

# Wait-Event - Wait for a specific event to occur
function Wait-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $false)]
        [int]$TimeoutSeconds = 30,
        
        [Parameter(Mandatory = $false)]
        [scriptblock]$Condition = $null
    )
    
    $receivedEvent = $null
    $waitHandle = [System.Threading.ManualResetEvent]::new($false)
    
    # Subscribe to the event
    $subscriberId = Subscribe-Event -EventName $EventName -Action {
        param($eventArgs)
        
        # Check condition if provided
        if ($null -eq $Condition -or (& $Condition $eventArgs)) {
            $script:receivedEvent = $eventArgs
            [void]$waitHandle.Set()
        }
    }
    
    try {
        # Wait for event or timeout
        $signaled = $waitHandle.WaitOne([TimeSpan]::FromSeconds($TimeoutSeconds))
        
        if ($signaled) {
            return $script:receivedEvent
        }
        else {
            Write-Log -Level Warning -Message "Timeout waiting for event: $EventName" -Component "EventSystem"
            return $null
        }
    }
    finally {
        # Clean up
        Unsubscribe-Event -EventName $EventName -SubscriberId $subscriberId
        $waitHandle.Dispose()
    }
}

# Initialize-EventSystem - Set up the event system
function Initialize-EventSystem {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [int]$MaxHistorySize = 1000
    )
    
    $script:MaxEventHistorySize = $MaxHistorySize
    
    Write-Log -Level Info -Message "Event system initialized (Max history: $MaxHistorySize)" -Component "EventSystem"
}

# Export all functions
Export-ModuleMember -Function @(
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Clear-EventSubscriptions',
    'Get-EventSubscriptions',
    'Get-EventHistory',
    'Clear-EventHistory',
    'Enable-EventQueue',
    'Disable-EventQueue',
    'Process-EventQueue',
    'Wait-Event',
    'Initialize-EventSystem'
)


####\utilities\focus-manager.psm1
# FILE: utilities/focus-manager.psm1
# PURPOSE: Provides the single source of truth for component focus management with scope support.

$script:Focus = @{
    FocusedComponent = $null 
    TabOrder = @()
    ActiveScope = $null
    History = @()  # Focus history for debugging
    ScopeStack = @()  # For nested focus scopes
}

function global:Request-Focus {
    param(
        [hashtable]$Component,
        [bool]$UpdateTabOrder = $false,
        [string]$Reason = "Direct"
    )
    Invoke-WithErrorHandling -Component "FocusManager.RequestFocus" -Context "Requesting focus for component" -AdditionalData @{ ComponentName = $Component.Name; Reason = $Reason } -ScriptBlock {
        # Validate component
        if ($Component -and -not $Component.IsFocusable) {
            Write-Log -Level Debug -Message "Cannot focus non-focusable component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        if ($Component -and -not $Component.Visible) {
            Write-Log -Level Debug -Message "Cannot focus invisible component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        # Handle losing focus on previous component
        $oldFocused = $script:Focus.FocusedComponent
        if ($oldFocused -and ($oldFocused -ne $Component)) {
            $oldFocused.IsFocused = $false
            
            if ($oldFocused.OnBlur) {
                try {
                    & $oldFocused.OnBlur -self $oldFocused
                } catch {
                    Write-Log -Level Error -Message "Error in OnBlur handler for '$($oldFocused.Name ?? $oldFocused.Type)': $_" -Data @{ Component = $oldFocused.Name; Exception = $_ }
                }
            }
            
            # Fire blur event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Blur" -Data @{ Component = $oldFocused }
            }
        }
        
        # Update focus scope if needed
        $newScope = if ($Component) { Get-FocusScope -Component $Component } else { $null }
        if ($newScope -ne $script:Focus.ActiveScope) {
            # Leave old scope
            if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.OnLeaveFocusScope) {
                try {
                    & $script:Focus.ActiveScope.OnLeaveFocusScope -self $script:Focus.ActiveScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnLeaveFocusScope handler for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Component = $script:Focus.ActiveScope.Name; Exception = $_ }
                }
            }
            
            $script:Focus.ActiveScope = $newScope
            
            # Enter new scope
            if ($newScope -and $newScope.OnEnterFocusScope) {
                try {
                    & $newScope.OnEnterFocusScope -self $newScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnEnterFocusScope handler for '$($newScope.Name ?? $newScope.Type)': $_" -Data @{ Component = $newScope.Name; Exception = $_ }
                }
            }
        }
        
        # Set new focus
        $script:Focus.FocusedComponent = $Component
        
        # Update global state if available
        if ($global:TuiState) {
            $global:TuiState.FocusedComponent = $Component
        }
        
        # Update history
        $script:Focus.History += @{
            Component = $Component
            Timestamp = [DateTime]::UtcNow
            Reason = $Reason
        }
        if ($script:Focus.History.Count -gt 50) {
            $script:Focus.History = $script:Focus.History[-50..-1]
        }
        
        if ($Component) {
            $Component.IsFocused = $true
            
            # Call focus handler
            if ($Component.OnFocus) {
                try {
                    & $Component.OnFocus -self $Component
                } catch {
                    Write-Log -Level Error -Message "Error in OnFocus handler for '$($Component.Name ?? $Component.Type)': $_" -Data @{ Component = $Component.Name; Exception = $_ }
                }
            }
            
            # Fire focus event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Focus" -Data @{ Component = $Component }
            }
            
            # Update tab order if requested
            if ($UpdateTabOrder) {
                Update-TabOrder -FocusedComponent $Component
            }
        }
        
        # Request screen refresh
        if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
        
        if ($Component) {
            Write-Log -Level Debug -Message "Focused: $($Component.Name ?? $Component.Type) (Reason: $Reason)"
        } else {
            Write-Log -Level Debug -Message "Cleared focus (Reason: $Reason)"
        }
        
        return $true
    }
}

function global:Clear-Focus {
    Invoke-WithErrorHandling -Component "FocusManager.ClearFocus" -Context "Clearing focus" -ScriptBlock {
        Request-Focus -Component $null -Reason "Clear"
    }
}

function global:Move-Focus {
    param(
        [bool]$Reverse = $false,
        [bool]$Wrap = $true
    )
    Invoke-WithErrorHandling -Component "FocusManager.MoveFocus" -Context "Moving focus" -AdditionalData @{ Reverse = $Reverse; Wrap = $Wrap; CurrentFocused = $script:Focus.FocusedComponent.Name } -ScriptBlock {
        # Check if active scope handles its own focus movement
        if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.HandleScopedFocus) {
            try {
                $handled = & $script:Focus.ActiveScope.HandleScopedFocus -self $script:Focus.ActiveScope -Reverse $Reverse
                if ($handled) {
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Active focus scope HandleScopedFocus failed for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Scope = $script:Focus.ActiveScope.Name; Reverse = $Reverse; Exception = $_ }
            }
        }
        
        # No focusable components
        if ($script:Focus.TabOrder.Count -eq 0) {
            Write-Log -Level Debug -Message "No focusable components in tab order"
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($script:Focus.TabOrder, $script:Focus.FocusedComponent)
        
        # If no current focus, focus first/last based on direction
        if ($currentIndex -eq -1) {
            $targetIndex = if ($Reverse) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            Request-Focus -Component $script:Focus.TabOrder[$targetIndex] -Reason "TabNavigation"
            return $true
        }
        
        # Calculate next index
        if ($Reverse) {
            $nextIndex = $currentIndex - 1
            if ($nextIndex -lt 0) {
                $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            }
        } else {
            $nextIndex = $currentIndex + 1
            if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
            }
        }
        
        # Skip invisible or disabled components
        $attempts = 0
        while ($attempts -lt $script:Focus.TabOrder.Count) {
            $candidate = $script:Focus.TabOrder[$nextIndex]
            
            if ($candidate.Visible -and $candidate.IsFocusable -and 
                (-not $candidate.PSObject.Properties['IsEnabled'] -or $candidate.IsEnabled)) {
                Request-Focus -Component $candidate -Reason "TabNavigation"
                return $true
            }
            
            # Move to next candidate
            if ($Reverse) {
                $nextIndex--
                if ($nextIndex -lt 0) {
                    $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
                }
            } else {
                $nextIndex++
                if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                    $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
                }
            }
            
            $attempts++
        }
        
        Write-Log -Level Debug -Message "No valid focus target found"
        return $false
    }
}

function global:Get-FocusedComponent {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusedComponent" -Context "Getting focused component" -ScriptBlock {
        return $script:Focus.FocusedComponent
    }
}

function global:Get-FocusHistory {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusHistory" -Context "Getting focus history" -ScriptBlock {
        return $script:Focus.History
    }
}

# --- FIX: REMOVED 'private:' ---
function Get-FocusScope {
    param($Component)
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusScope" -Context "Getting focus scope" -AdditionalData @{ ComponentName = $Component.Name } -ScriptBlock {
        $current = $Component
        while ($current) {
            if ($current.IsFocusScope) {
                return $current
            }
            $current = $current.Parent
        }
        
        return $null
    }
}

function global:Push-FocusScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.PushFocusScope" -Context "Pushing focus scope" -AdditionalData @{ ScopeName = $Scope.Name } -ScriptBlock {
        if (-not $Scope.IsFocusScope) {
            $Scope.IsFocusScope = $true
        }
        
        $script:Focus.ScopeStack += $Scope
        $script:Focus.ActiveScope = $Scope
        
        Write-Log -Level Debug -Message "Pushed focus scope: $($Scope.Name ?? $Scope.Type)"
    }
}

function global:Pop-FocusScope {
    Invoke-WithErrorHandling -Component "FocusManager.PopFocusScope" -Context "Popping focus scope" -ScriptBlock {
        if ($script:Focus.ScopeStack.Count -eq 0) {
            return $null
        }
        
        $poppedScope = $script:Focus.ScopeStack[-1]
        $script:Focus.ScopeStack = $script:Focus.ScopeStack[0..($script:Focus.ScopeStack.Count - 2)]
        
        # Restore previous scope
        if ($script:Focus.ScopeStack.Count -gt 0) {
            $script:Focus.ActiveScope = $script:Focus.ScopeStack[-1]
        } else {
            $script:Focus.ActiveScope = $null
        }
        
        Write-Log -Level Debug -Message "Popped focus scope: $($poppedScope.Name ?? $poppedScope.Type)"
        
        return $poppedScope
    }
}

# --- FIX: REMOVED 'private:' ---
function Update-TabOrder {
    param($FocusedComponent)
    Invoke-WithErrorHandling -Component "FocusManager.UpdateTabOrder" -Context "Updating tab order" -AdditionalData @{ FocusedComponentName = $FocusedComponent.Name } -ScriptBlock {
        # If component is already in tab order, no need to update
        if ($FocusedComponent -in $script:Focus.TabOrder) {
            return
        }
        
        # Rebuild tab order
        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
    }
}

# --- FIX: REMOVED 'private:' ---
function Register-ScreenForFocus {
    param($Screen)
    Invoke-WithErrorHandling -Component "FocusManager.RegisterScreenForFocus" -Context "Registering screen for focus" -AdditionalData @{ ScreenName = $Screen.Name } -ScriptBlock {
        $script:Focus.TabOrder = @()
        $script:Focus.ActiveScope = $null
        
        if (-not $Screen) {
            Request-Focus -Component $null -Reason "NoScreen"
            return
        }
        
        # Find all focusable components
        $focusableComponents = @()
        
        $FindFocusable = $null
        $FindFocusable = {
            param($component, $depth = 0)
            
            if (-not $component) { return }
            
            # Add focusable components
            if ($component.IsFocusable -and $component.Visible) {
                $focusableComponents += @{
                    Component = $component
                    Depth = $depth
                    TabIndex = $component.TabIndex ?? 0
                    Position = @{
                        Y = $component.Y ?? 0
                        X = $component.X ?? 0
                    }
                }
            }
            
            # Process panel children
            if ($component.Children) {
                foreach ($child in $component.Children) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
            
            # Process named children (for backward compatibility)
            if ($component.Components) {
                foreach ($child in $component.Components.Values) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
        }.GetNewClosure()
        
        # Start from screen components and children
        if ($Screen.Children) {
            foreach ($comp in $Screen.Children) {
                & $FindFocusable -component $comp
            }
        }
        
        # Also check legacy Components collection
        if ($Screen.Components) {
            foreach ($comp in $Screen.Components.Values) {
                & $FindFocusable -component $comp
            }
        }
        
        # Sort by TabIndex, then by position (top to bottom, left to right)
        $script:Focus.TabOrder = $focusableComponents | 
            Sort-Object { $_.TabIndex }, { $_.Position.Y }, { $_.Position.X } |
            ForEach-Object { $_.Component }
        
        Write-Log -Level Debug -Message "Registered $($script:Focus.TabOrder.Count) focusable components"
        
        # Focus first component if none focused
        if ($script:Focus.TabOrder.Count -gt 0 -and -not ($script:Focus.FocusedComponent -in $script:Focus.TabOrder)) {
            Request-Focus -Component $script:Focus.TabOrder[0] -Reason "InitialFocus"
        } elseif ($script:Focus.TabOrder.Count -eq 0) {
            Request-Focus -Component $null -Reason "NoFocusableComponents"
        }
    }
}

function global:Initialize-FocusManager {
    Invoke-WithErrorHandling -Component "FocusManager.Initialize" -Context "Initializing focus manager" -ScriptBlock {
        # Subscribe to screen events
        if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
            Subscribe-Event -EventName "Screen.Pushed" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPushedHandler" -Context "Handling screen pushed event" -AdditionalData @{ EventData = $Event.Data } -ScriptBlock {
                    Register-ScreenForFocus -Screen $Event.Data.Screen
                }
            }
            
            Subscribe-Event -EventName "Screen.Popped" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPoppedHandler" -Context "Handling screen popped event" -AdditionalData @{ EventData = $Event.Data } -ScriptBlock {
                    # Clear focus scopes
                    $script:Focus.ScopeStack = @()
                    $script:Focus.ActiveScope = $null
                    
                    # Re-register for new top screen
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                }
            }
            
            Subscribe-Event -EventName "Component.VisibilityChanged" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ComponentVisibilityChangedHandler" -Context "Handling component visibility changed event" -AdditionalData @{ EventData = $Event.Data } -ScriptBlock {
                    $component = $Event.Data.Component
                    
                    # If hiding focused component, move focus
                    if (-not $component.Visible -and $component -eq $script:Focus.FocusedComponent) {
                        Move-Focus
                    }
                    
                    # Update tab order if visibility changed
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                }
            }
        }
        
        Write-Log -Level Info -Message "Focus Manager initialized"
    }
}

# Utility functions for components
function global:Set-ComponentFocusable {
    param(
        [hashtable]$Component,
        [bool]$IsFocusable
    )
    Invoke-WithErrorHandling -Component "FocusManager.SetComponentFocusable" -Context "Setting component focusable" -AdditionalData @{ ComponentName = $Component.Name; IsFocusable = $IsFocusable } -ScriptBlock {
        $wasFocusable = $Component.IsFocusable
        $Component.IsFocusable = $IsFocusable
        
        # If making unfocusable and it's currently focused, clear focus
        if ($wasFocusable -and -not $IsFocusable -and $Component -eq $script:Focus.FocusedComponent) {
            Move-Focus
        }
        
        # Update tab order
        if ($global:TuiState -and $global:TuiState.CurrentScreen) {
            Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
        }
    }
}

function global:Focus-NextInScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.FocusNextInScope" -Context "Focusing next in scope" -AdditionalData @{ ScopeName = $Scope.Name } -ScriptBlock {
        if (-not $Scope -or -not $Scope.IsFocusScope) {
            return $false
        }
        
        # Find focusable children within scope
        $scopeFocusable = @()
        
        $FindScopeFocusable = {
            param($component)
            
            if ($component.IsFocusable -and $component.Visible) {
                $scopeFocusable += $component
            }
            
            if ($component.Children -and $component -ne $Scope) {
                foreach ($child in $component.Children) {
                    & $FindScopeFocusable -component $child
                }
            }
        }
        
        & $FindScopeFocusable -component $Scope
        
        if ($scopeFocusable.Count -eq 0) {
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($scopeFocusable, $script:Focus.FocusedComponent)
        $nextIndex = ($currentIndex + 1) % $scopeFocusable.Count
        
        Request-Focus -Component $scopeFocusable[$nextIndex] -Reason "ScopeNavigation"
        return $true
    }
}

Export-ModuleMember -Function @(
    "Initialize-FocusManager",
    "Request-Focus", 
    "Clear-Focus",
    "Move-Focus",
    "Get-FocusedComponent",
    "Get-FocusHistory",
    "Push-FocusScope",
    "Pop-FocusScope",
    "Set-ComponentFocusable",
    "Focus-NextInScope"
)


####\utilities\layout-manager.psm1
# Layout Manager Utility Module
# Provides helper functions for component positioning and layout management

function global:New-TuiLayoutManager {
    <#
    .SYNOPSIS
    Creates a layout manager for organizing components within a container
    
    .DESCRIPTION
    The layout manager helps with automatic positioning, spacing, and alignment of components.
    It provides various layout modes: Stack, Grid, Dock, and Manual.
    
    .PARAMETER Container
    A hashtable with X, Y, Width, Height properties defining the container bounds
    
    .PARAMETER Mode
    Layout mode: 'Stack', 'Grid', 'Dock', or 'Manual'
    
    .EXAMPLE
    $layout = New-TuiLayoutManager -Container @{X=0; Y=0; Width=80; Height=25} -Mode 'Stack'
    $layout.Add($component1)
    $layout.Add($component2)
    $layout.Apply()
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [string]$Mode = 'Manual',
        [hashtable]$Options = @{}
    )
    
    $manager = @{
        Container = $Container
        Mode = $Mode
        Components = @()
        Options = @{
            # Stack options
            Direction = $Options.Direction ?? 'Vertical'  # 'Vertical' or 'Horizontal'
            Spacing = $Options.Spacing ?? 1
            Padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
            Alignment = $Options.Alignment ?? 'Left'  # 'Left', 'Center', 'Right'
            
            # Grid options
            Columns = $Options.Columns ?? 2
            RowHeight = $Options.RowHeight ?? 5
            ColumnWidth = $Options.ColumnWidth ?? 20
            
            # Dock options
            FillLast = $Options.FillLast ?? $true
        }
        
        # Methods
        Add = {
            param($Component, [hashtable]$LayoutProps = @{})
            $this = $args[-1]
            $this.Components += @{
                Component = $Component
                LayoutProps = $LayoutProps
            }
        }.GetNewClosure()
        
        Clear = {
            $this = $args[-1]
            $this.Components = @()
        }.GetNewClosure()
        
        Apply = {
            $this = $args[-1]
            switch ($this.Mode) {
                'Stack' { & $this.ApplyStackLayout }
                'Grid' { & $this.ApplyGridLayout }
                'Dock' { & $this.ApplyDockLayout }
                'Manual' { # Do nothing - components use their existing positions }
            }
        }.GetNewClosure()
        
        ApplyStackLayout = {
            $this = $args[-1]
            $x = $this.Container.X + $this.Options.Padding.Left
            $y = $this.Container.Y + $this.Options.Padding.Top
            $maxWidth = $this.Container.Width - $this.Options.Padding.Left - $this.Options.Padding.Right
            $maxHeight = $this.Container.Height - $this.Options.Padding.Top - $this.Options.Padding.Bottom
            
            foreach ($item in $this.Components) {
                $comp = $item.Component
                
                # Apply alignment
                switch ($this.Options.Alignment) {
                    'Center' { $comp.X = $x + [Math]::Floor(($maxWidth - $comp.Width) / 2) }
                    'Right' { $comp.X = $x + $maxWidth - $comp.Width }
                    default { $comp.X = $x }
                }
                
                if ($this.Options.Direction -eq 'Vertical') {
                    $comp.Y = $y
                    $y += $comp.Height + $this.Options.Spacing
                } else {
                    $comp.Y = $y
                    $x += $comp.Width + $this.Options.Spacing
                }
            }
        }.GetNewClosure()
        
        ApplyGridLayout = {
            $this = $args[-1]
            $startX = $this.Container.X + $this.Options.Padding.Left
            $startY = $this.Container.Y + $this.Options.Padding.Top
            $cols = $this.Options.Columns
            
            for ($i = 0; $i -lt $this.Components.Count; $i++) {
                $comp = $this.Components[$i].Component
                $row = [Math]::Floor($i / $cols)
                $col = $i % $cols
                
                $comp.X = $startX + ($col * ($this.Options.ColumnWidth + $this.Options.Spacing))
                $comp.Y = $startY + ($row * ($this.Options.RowHeight + $this.Options.Spacing))
                
                # Optionally constrain size to grid cell
                if ($this.Components[$i].LayoutProps.ConstrainToCell) {
                    $comp.Width = [Math]::Min($comp.Width, $this.Options.ColumnWidth)
                    $comp.Height = [Math]::Min($comp.Height, $this.Options.RowHeight)
                }
            }
        }.GetNewClosure()
        
        ApplyDockLayout = {
            $this = $args[-1]
            $remainingX = $this.Container.X
            $remainingY = $this.Container.Y
            $remainingWidth = $this.Container.Width
            $remainingHeight = $this.Container.Height
            
            # Process in order: Top, Bottom, Left, Right, Fill
            $dockOrder = @('Top', 'Bottom', 'Left', 'Right', 'Fill')
            
            foreach ($dock in $dockOrder) {
                $items = $this.Components | Where-Object { $_.LayoutProps.Dock -eq $dock }
                
                foreach ($item in $items) {
                    $comp = $item.Component
                    
                    switch ($dock) {
                        'Top' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $remainingY += $comp.Height
                            $remainingHeight -= $comp.Height
                        }
                        'Bottom' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY + $remainingHeight - $comp.Height
                            $comp.Width = $remainingWidth
                            $remainingHeight -= $comp.Height
                        }
                        'Left' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingX += $comp.Width
                            $remainingWidth -= $comp.Width
                        }
                        'Right' {
                            $comp.X = $remainingX + $remainingWidth - $comp.Width
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingWidth -= $comp.Width
                        }
                        'Fill' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $comp.Height = $remainingHeight
                        }
                    }
                }
            }
        }.GetNewClosure()
        
        # Helper to calculate required size
        GetRequiredSize = {
            $this = $args[-1]
            $width = 0
            $height = 0
            
            switch ($this.Mode) {
                'Stack' {
                    if ($this.Options.Direction -eq 'Vertical') {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Maximum).Maximum
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Sum).Sum
                        $height += ($this.Components.Count - 1) * $this.Options.Spacing
                    } else {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Sum).Sum
                        $width += ($this.Components.Count - 1) * $this.Options.Spacing
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Maximum).Maximum
                    }
                }
                'Grid' {
                    $cols = $this.Options.Columns
                    $rows = [Math]::Ceiling($this.Components.Count / $cols)
                    $width = $cols * $this.Options.ColumnWidth + ($cols - 1) * $this.Options.Spacing
                    $height = $rows * $this.Options.RowHeight + ($rows - 1) * $this.Options.Spacing
                }
            }
            
            $width += $this.Options.Padding.Left + $this.Options.Padding.Right
            $height += $this.Options.Padding.Top + $this.Options.Padding.Bottom
            
            return @{ Width = $width; Height = $height }
        }.GetNewClosure()
    }
    
    # Bind methods to the manager instance
    $manager.Add = $manager.Add.Invoke(@($manager))
    $manager.Clear = $manager.Clear.Invoke(@($manager))
    $manager.Apply = $manager.Apply.Invoke(@($manager))
    $manager.ApplyStackLayout = $manager.ApplyStackLayout.Invoke(@($manager))
    $manager.ApplyGridLayout = $manager.ApplyGridLayout.Invoke(@($manager))
    $manager.ApplyDockLayout = $manager.ApplyDockLayout.Invoke(@($manager))
    $manager.GetRequiredSize = $manager.GetRequiredSize.Invoke(@($manager))
    
    return $manager
}

function global:Center-Component {
    <#
    .SYNOPSIS
    Centers a component within a container
    #>
    param(
        [hashtable]$Component,
        [hashtable]$Container = @{ X = 0; Y = 0; Width = $global:TuiState.BufferWidth; Height = $global:TuiState.BufferHeight }
    )
    
    $Component.X = $Container.X + [Math]::Floor(($Container.Width - $Component.Width) / 2)
    $Component.Y = $Container.Y + [Math]::Floor(($Container.Height - $Component.Height) / 2)
}

function global:Align-Components {
    <#
    .SYNOPSIS
    Aligns multiple components horizontally or vertically
    #>
    param(
        [hashtable[]]$Components,
        [string]$Direction = 'Horizontal',  # 'Horizontal' or 'Vertical'
        [string]$Alignment = 'Center',      # 'Top', 'Middle', 'Bottom' for horizontal; 'Left', 'Center', 'Right' for vertical
        [int]$Spacing = 2
    )
    
    if ($Components.Count -eq 0) { return }
    
    if ($Direction -eq 'Horizontal') {
        # Calculate total width needed
        $totalWidth = ($Components | ForEach-Object { $_.Width } | Measure-Object -Sum).Sum
        $totalWidth += ($Components.Count - 1) * $Spacing
        
        # Starting X position
        $currentX = switch ($Alignment) {
            'Left' { 0 }
            'Right' { $global:TuiState.BufferWidth - $totalWidth }
            default { [Math]::Floor(($global:TuiState.BufferWidth - $totalWidth) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.X = $currentX
            $currentX += $comp.Width + $Spacing
        }
    } else {
        # Calculate total height needed
        $totalHeight = ($Components | ForEach-Object { $_.Height } | Measure-Object -Sum).Sum
        $totalHeight += ($Components.Count - 1) * $Spacing
        
        # Starting Y position
        $currentY = switch ($Alignment) {
            'Top' { 0 }
            'Bottom' { $global:TuiState.BufferHeight - $totalHeight }
            default { [Math]::Floor(($global:TuiState.BufferHeight - $totalHeight) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.Y = $currentY
            $currentY += $comp.Height + $Spacing
        }
    }
}

function global:Create-ComponentGrid {
    <#
    .SYNOPSIS
    Arranges components in a grid layout
    #>
    param(
        [hashtable[]]$Components,
        [int]$Columns = 2,
        [int]$StartX = 0,
        [int]$StartY = 0,
        [int]$CellWidth = 20,
        [int]$CellHeight = 5,
        [int]$HorizontalSpacing = 2,
        [int]$VerticalSpacing = 1
    )
    
    for ($i = 0; $i -lt $Components.Count; $i++) {
        $row = [Math]::Floor($i / $Columns)
        $col = $i % $Columns
        
        $Components[$i].X = $StartX + ($col * ($CellWidth + $HorizontalSpacing))
        $Components[$i].Y = $StartY + ($row * ($CellHeight + $VerticalSpacing))
    }
}

Export-ModuleMember -Function @(
    'New-TuiLayoutManager',
    'Center-Component',
    'Align-Components',
    'Create-ComponentGrid'
)


####\utilities\positioning-helper.psm1
# Component Positioning Helper Module
# Provides utilities for easier component placement and relative positioning

function global:New-TuiPositioner {
    <#
    .SYNOPSIS
    Creates a positioning helper for managing component placement
    
    .DESCRIPTION
    The positioner helps calculate positions for components relative to each other
    and handles common layout patterns like rows, columns, and grids.
    
    .PARAMETER Container
    Defines the bounding container for positioning
    
    .EXAMPLE
    $pos = New-TuiPositioner -Container @{X=0; Y=0; Width=80; Height=25}
    $button1Pos = $pos.NextInRow(10, 3)  # Width=10, Height=3
    $button2Pos = $pos.NextInRow(10, 3)  # Automatically positioned after button1
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $positioner = @{
        Container = $Container
        CurrentX = $Container.X + ($Options.PaddingLeft ?? 0)
        CurrentY = $Container.Y + ($Options.PaddingTop ?? 0)
        RowHeight = 0
        Options = @{
            Spacing = $Options.Spacing ?? 1
            PaddingTop = $Options.PaddingTop ?? 0
            PaddingRight = $Options.PaddingRight ?? 0
            PaddingBottom = $Options.PaddingBottom ?? 0
            PaddingLeft = $Options.PaddingLeft ?? 0
        }
        
        # Reset to start of container
        Reset = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
            $this.RowHeight = 0
        }
        
        # Move to next row
        NewRow = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY += $this.RowHeight + $this.Options.Spacing
            $this.RowHeight = 0
        }
        
        # Get next position in current row
        NextInRow = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current row
            $maxX = $this.Container.X + $this.Container.Width - $this.Options.PaddingRight
            if (($this.CurrentX + $Width) -gt $maxX) {
                & $this.NewRow
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentX += $Width + $this.Options.Spacing
            $this.RowHeight = [Math]::Max($this.RowHeight, $Height)
            
            return $position
        }
        
        # Get next position in current column
        NextInColumn = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current column
            $maxY = $this.Container.Y + $this.Container.Height - $this.Options.PaddingBottom
            if (($this.CurrentY + $Height) -gt $maxY) {
                # Move to next column
                $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
                $this.CurrentX += $Width + $this.Options.Spacing
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentY += $Height + $this.Options.Spacing
            
            return $position
        }
        
        # Position at specific coordinates
        At = {
            param([int]$X, [int]$Y, [int]$Width, [int]$Height)
            
            $this.CurrentX = $X + $Width + $this.Options.Spacing
            $this.CurrentY = $Y
            $this.RowHeight = $Height
            
            return @{
                X = $X
                Y = $Y
                Width = $Width
                Height = $Height
            }
        }
        
        # Position relative to another position
        RelativeTo = {
            param(
                [hashtable]$Reference,
                [string]$Direction = "Right",  # Right, Left, Above, Below
                [int]$Width,
                [int]$Height,
                [int]$Offset = $null
            )
            
            if ($null -eq $Offset) { $Offset = $this.Options.Spacing }
            
            $position = switch ($Direction) {
                "Right" {
                    @{
                        X = $Reference.X + $Reference.Width + $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Left" {
                    @{
                        X = $Reference.X - $Width - $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Below" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y + $Reference.Height + $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
                "Above" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y - $Height - $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
            }
            
            return $position
        }
        
        # Center component in container
        Center = {
            param([int]$Width, [int]$Height)
            
            return @{
                X = $this.Container.X + [Math]::Floor(($this.Container.Width - $Width) / 2)
                Y = $this.Container.Y + [Math]::Floor(($this.Container.Height - $Height) / 2)
                Width = $Width
                Height = $Height
            }
        }
        
        # Align to edges
        AlignTopLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignTopRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
    }
    
    return $positioner
}

function global:Position-Components {
    <#
    .SYNOPSIS
    Positions multiple components using a layout pattern
    
    .PARAMETER Components
    Array of component hashtables to position
    
    .PARAMETER Pattern
    Layout pattern: 'Row', 'Column', 'Grid', 'Flow'
    
    .PARAMETER Container
    Container bounds
    
    .PARAMETER Options
    Layout options (spacing, columns for grid, etc.)
    #>
    param(
        [hashtable[]]$Components,
        [string]$Pattern = 'Row',
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $spacing = $Options.Spacing ?? 1
    $padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
    
    switch ($Pattern) {
        'Row' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
            }
        }
        
        'Column' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $y += $comp.Height + $spacing
            }
        }
        
        'Grid' {
            $columns = $Options.Columns ?? 2
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $col = 0
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                if ($col -ge $columns) {
                    $col = 0
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
                $col++
            }
        }
        
        'Flow' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $maxX = $Container.X + $Container.Width - $padding.Right
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                # Check if component fits in current row
                if (($x + $comp.Width) -gt $maxX -and $x -ne ($Container.X + $padding.Left)) {
                    # Move to next row
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
            }
        }
    }
}

function global:Get-RelativePosition {
    <#
    .SYNOPSIS
    Calculate position relative to another component
    #>
    param(
        [hashtable]$Reference,
        [string]$Direction = "Right",
        [int]$Offset = 1
    )
    
    switch ($Direction) {
        "Right" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "Left" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "Above" { return @{ X = $Reference.X; Y = $Reference.Y - $Offset } }
        "Below" { return @{ X = $Reference.X; Y = $Reference.Y + $Reference.Height + $Offset } }
        "TopRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "TopLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "BottomRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y + $Reference.Height } }
        "BottomLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y + $Reference.Height } }
    }
}

Export-ModuleMember -Function @(
    'New-TuiPositioner',
    'Position-Components',
    'Get-RelativePosition'
)


####\validation\migration-validator.ps1
# IRenderable Migration Validation and Testing Script
# Tests all components for proper migration to IRenderable pattern
# AI: Comprehensive validation tool for the migration process

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import required modules
Import-Module "$PSScriptRoot\..\utilities\error-handling.psm1" -Force
Import-Module "$PSScriptRoot\..\components\IRenderable.psm1" -Force

function Test-ComponentMigration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [object]$Component,
        
        [Parameter(Mandatory = $false)]
        [switch]$Verbose
    )
    
    $results = @{
        ComponentName = $Component.GetType().Name
        IsIRenderable = $false
        HasRenderMethod = $false
        HasRenderContentMethod = $false
        ValidatesSuccessfully = $false
        RenderTest = @{
            Success = $false
            OutputLength = 0
            ErrorMessage = ""
            ProducesErrorBox = $false
        }
        Recommendations = @()
    }
    
    try {
        # Check if component inherits from IRenderable
        $results.IsIRenderable = $Component -is [IRenderable]
        
        # Check for required methods
        $results.HasRenderMethod = $Component.GetType().GetMethod("Render") -ne $null
        $results.HasRenderContentMethod = $Component.GetType().GetMethod("_RenderContent", [System.Reflection.BindingFlags]::NonPublic -bor [System.Reflection.BindingFlags]::Instance) -ne $null
        
        # Test render functionality
        if ($results.HasRenderMethod) {
            try {
                $output = $Component.Render()
                $results.RenderTest.Success = $true
                $results.RenderTest.OutputLength = if ($output) { $output.Length } else { 0 }
                
                # Check if output is an error box (indicates error handling is working)
                $results.RenderTest.ProducesErrorBox = $output -like "*COMPONENT ERROR*"
                
            }
            catch {
                $results.RenderTest.ErrorMessage = $_.Exception.Message
            }
        }
        
        # Test validation method if available
        if ($results.IsIRenderable) {
            try {
                $results.ValidatesSuccessfully = $Component.ValidateRender()
            }
            catch {
                $results.ValidatesSuccessfully = $false
            }
        }
        
        # Generate recommendations
        if (-not $results.IsIRenderable) {
            $results.Recommendations += "Component should inherit from IRenderable"
        }
        
        if (-not $results.HasRenderContentMethod -and $results.IsIRenderable) {
            $results.Recommendations += "Component should implement _RenderContent() method"
        }
        
        if (-not $results.RenderTest.Success) {
            $results.Recommendations += "Component render method fails: $($results.RenderTest.ErrorMessage)"
        }
        
        if ($Verbose) {
            Write-Host "Migration Test Results for $($results.ComponentName):" -ForegroundColor Cyan
            Write-Host "  Inherits IRenderable: $($results.IsIRenderable)" -ForegroundColor $(if ($results.IsIRenderable) { "Green" } else { "Red" })
            Write-Host "  Has Render Method: $($results.HasRenderMethod)" -ForegroundColor $(if ($results.HasRenderMethod) { "Green" } else { "Red" })
            Write-Host "  Render Test Success: $($results.RenderTest.Success)" -ForegroundColor $(if ($results.RenderTest.Success) { "Green" } else { "Red" })
            Write-Host "  Output Length: $($results.RenderTest.OutputLength)" -ForegroundColor Gray
            
            if ($results.Recommendations.Count -gt 0) {
                Write-Host "  Recommendations:" -ForegroundColor Yellow
                foreach ($rec in $results.Recommendations) {
                    Write-Host "    - $rec" -ForegroundColor Yellow
                }
            }
        }
        
    }
    catch {
        $results.RenderTest.ErrorMessage = "Validation failed: $($_.Exception.Message)"
    }
    
    return $results
}

function Test-ErrorHandlingParameterOrder {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )
    
    if (-not (Test-Path $FilePath)) {
        throw "File not found: $FilePath"
    }
    
    $content = Get-Content -Path $FilePath -Raw
    $issues = @()
    
    # Check for incorrect parameter order patterns
    $incorrectPatterns = @(
        @{
            Pattern = 'Invoke-WithErrorHandling\s+-ScriptBlock\s+\{'
            Issue = "ScriptBlock parameter should come after Component and Context"
        },
        @{
            Pattern = 'Invoke-WithErrorHandling.*-Context.*-Component'
            Issue = "Component parameter should come before Context parameter"
        }
    )
    
    foreach ($pattern in $incorrectPatterns) {
        $matches = [regex]::Matches($content, $pattern.Pattern, [System.Text.RegularExpressions.RegexOptions]::Multiline)
        foreach ($match in $matches) {
            $lineNumber = ($content.Substring(0, $match.Index) -split "`n").Count
            $issues += @{
                LineNumber = $lineNumber
                Issue = $pattern.Issue
                Context = $match.Value.Substring(0, [Math]::Min(50, $match.Value.Length))
            }
        }
    }
    
    return @{
        FilePath = $FilePath
        Issues = $issues
        HasIssues = $issues.Count -gt 0
    }
}

function Start-FullMigrationValidation {
    param(
        [Parameter(Mandatory = $false)]
        [string]$RootDirectory = (Get-Location).Path
    )
    
    Write-Host "=== IRenderable Migration Validation ===" -ForegroundColor Magenta
    Write-Host "Root Directory: $RootDirectory" -ForegroundColor Gray
    Write-Host ""
    
    $results = @{
        TotalFiles = 0
        ProcessedFiles = 0
        MigratedComponents = 0
        FailedComponents = 0
        ParameterOrderIssues = 0
        Components = @()
        FileIssues = @()
    }
    
    # 1. Test Error Handling Parameter Order
    Write-Host "1. Checking Error Handling Parameter Order..." -ForegroundColor Cyan
    $psm1Files = Get-ChildItem -Path $RootDirectory -Filter "*.psm1" -Recurse
    $results.TotalFiles = $psm1Files.Count
    
    foreach ($file in $psm1Files) {
        try {
            $parameterTest = Test-ErrorHandlingParameterOrder -FilePath $file.FullName
            
            if ($parameterTest.HasIssues) {
                $results.ParameterOrderIssues += $parameterTest.Issues.Count
                $results.FileIssues += $parameterTest
                
                Write-Host "  ‚ùå $($file.Name): $($parameterTest.Issues.Count) parameter order issues" -ForegroundColor Red
                foreach ($issue in $parameterTest.Issues) {
                    Write-Host "    Line $($issue.LineNumber): $($issue.Issue)" -ForegroundColor Red
                }
            }
            else {
                Write-Host "  ‚úÖ $($file.Name): No parameter order issues" -ForegroundColor Green
            }
            
            $results.ProcessedFiles++
        }
        catch {
            Write-Host "  ‚ö†Ô∏è $($file.Name): Failed to check - $_" -ForegroundColor Yellow
        }
    }
    
    Write-Host ""
    
    # 2. Test IRenderable Components
    Write-Host "2. Testing IRenderable Components..." -ForegroundColor Cyan
    
    # Create test instances of common components
    $testComponents = @()
    
    # Try to create sample components for testing
    try {
        # You can add your specific component tests here
        Write-Host "  Creating test component instances..." -ForegroundColor Gray
        
        # Example: Create a simple test component
        $testTableComponent = @{
            GetType = { return @{ Name = "TestTableComponent" } }
        }
        
        # Add to test array if you have actual components to test
        # $testComponents += $yourActualComponent
        
    }
    catch {
        Write-Host "  ‚ö†Ô∏è Could not create test components: $_" -ForegroundColor Yellow
    }
    
    # Test each component
    foreach ($component in $testComponents) {
        try {
            $testResult = Test-ComponentMigration -Component $component -Verbose
            $results.Components += $testResult
            
            if ($testResult.IsIRenderable -and $testResult.RenderTest.Success) {
                $results.MigratedComponents++
                Write-Host "  ‚úÖ $($testResult.ComponentName): Successfully migrated" -ForegroundColor Green
            }
            else {
                $results.FailedComponents++
                Write-Host "  ‚ùå $($testResult.ComponentName): Migration incomplete" -ForegroundColor Red
            }
        }
        catch {
            $results.FailedComponents++
            Write-Host "  ‚ùå Component test failed: $_" -ForegroundColor Red
        }
    }
    
    Write-Host ""
    
    # 3. Generate Summary Report
    Write-Host "=== MIGRATION VALIDATION SUMMARY ===" -ForegroundColor Magenta
    Write-Host "Files Processed: $($results.ProcessedFiles)/$($results.TotalFiles)" -ForegroundColor White
    Write-Host "Parameter Order Issues: $($results.ParameterOrderIssues)" -ForegroundColor $(if ($results.ParameterOrderIssues -eq 0) { "Green" } else { "Red" })
    Write-Host "Components Tested: $($results.Components.Count)" -ForegroundColor White
    Write-Host "Successfully Migrated: $($results.MigratedComponents)" -ForegroundColor Green
    Write-Host "Failed Migration: $($results.FailedComponents)" -ForegroundColor Red
    
    if ($results.ParameterOrderIssues -eq 0 -and $results.FailedComponents -eq 0) {
        Write-Host "üéâ MIGRATION VALIDATION PASSED!" -ForegroundColor Green
    }
    else {
        Write-Host "‚ö†Ô∏è MIGRATION VALIDATION NEEDS ATTENTION" -ForegroundColor Yellow
    }
    
    Write-Host ""
    
    # 4. Next Steps
    Write-Host "Next Steps:" -ForegroundColor Cyan
    if ($results.ParameterOrderIssues -gt 0) {
        Write-Host "  1. Fix parameter order issues in the reported files" -ForegroundColor Yellow
    }
    if ($results.FailedComponents -gt 0) {
        Write-Host "  2. Complete migration of failed components to IRenderable" -ForegroundColor Yellow
    }
    if ($results.ParameterOrderIssues -eq 0 -and $results.FailedComponents -eq 0) {
        Write-Host "  1. Test the application to ensure everything works correctly" -ForegroundColor Green
        Write-Host "  2. Consider running performance tests" -ForegroundColor Green
    }
    
    return $results
}

# Quick validation function for immediate testing
function Test-ImmediateErrorHandling {
    Write-Host "Testing Error Handling Fix..." -ForegroundColor Cyan
    
    try {
        # Test the fixed error handling pattern
        $result = Invoke-WithErrorHandling -Component "TestComponent" -Context "TestMethod" -ScriptBlock {
            return "Error handling working correctly"
        }
        
        Write-Host "‚úÖ Error handling parameter order: PASSED" -ForegroundColor Green
        Write-Host "   Result: $result" -ForegroundColor Gray
    }
    catch {
        Write-Host "‚ùå Error handling parameter order: FAILED" -ForegroundColor Red
        Write-Host "   Error: $_" -ForegroundColor Red
    }
    
    try {
        # Test IRenderable base class
        $testRenderable = [IRenderable]::new("TestComponent")
        
        Write-Host "‚úÖ IRenderable base class: PASSED" -ForegroundColor Green
        Write-Host "   Component: $($testRenderable._componentName)" -ForegroundColor Gray
    }
    catch {
        Write-Host "‚ùå IRenderable base class: FAILED" -ForegroundColor Red
        Write-Host "   Error: $_" -ForegroundColor Red
    }
}

# Export functions for use in other scripts
Export-ModuleMember -Function @(
    'Test-ComponentMigration',
    'Test-ErrorHandlingParameterOrder', 
    'Start-FullMigrationValidation',
    'Test-ImmediateErrorHandling'
)

# If script is run directly, perform immediate validation
if ($MyInvocation.InvocationName -ne '&') {
    Test-ImmediateErrorHandling
    Write-Host ""
    Write-Host "To run full validation, use: Start-FullMigrationValidation" -ForegroundColor Cyan
}



####\validation\test-navigation-fixes.ps1
# Test Navigation Service Fixes
# This script validates the navigation service integration fixes in the dashboard screen

#region Test Setup
Write-Host "=== Testing Navigation Service Integration Fixes ===" -ForegroundColor Cyan
Write-Host ""

# Mock the required modules and functions for testing
$ErrorActionPreference = "Stop"

# Mock Write-Log function
function Write-Log {
    param(
        [string]$Level = "Info",
        [string]$Message,
        [object]$Data = $null
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $color = switch ($Level) {
        "Error" { "Red" }
        "Warning" { "Yellow" }
        "Info" { "Green" }
        "Debug" { "Gray" }
        default { "White" }
    }
    Write-Host "[$timestamp] [$Level] $Message" -ForegroundColor $color
    if ($Data) {
        Write-Host "  Data: $($Data | ConvertTo-Json -Compress)" -ForegroundColor Gray
    }
}

# Mock Invoke-WithErrorHandling function
function Invoke-WithErrorHandling {
    param(
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        [Parameter(Mandatory)]
        [string]$Component,
        [Parameter(Mandatory)]
        [string]$Context,
        [hashtable]$AdditionalData = @{}
    )
    
    try {
        Write-Log -Level Debug -Message "Entering $Component.$Context"
        $result = & $ScriptBlock
        Write-Log -Level Debug -Message "Completed $Component.$Context"
        return $result
    }
    catch {
        Write-Log -Level Error -Message "Error in $Component.$Context : $_" -Data @{
            Component = $Component
            Context = $Context
            AdditionalData = $AdditionalData
            Exception = $_.Exception.Message
        }
        throw
    }
}
#endregion

#region Test Navigation Service
Write-Host "Testing Navigation Service..." -ForegroundColor Yellow

# Create a mock navigation service that follows the expected pattern
$mockNavigationService = @{
    GoTo = {
        param($self, [string]$Path, [hashtable]$Services = $null)
        
        Invoke-WithErrorHandling -Component "MockNavigation.GoTo" -Context "TestNavigation" -ScriptBlock {
            Write-Log -Level Info -Message "Mock Navigation: Navigating to $Path"
            
            # Simulate validation
            if ([string]::IsNullOrWhiteSpace($Path)) {
                throw "Path cannot be empty"
            }
            
            if (-not $Path.StartsWith("/")) {
                throw "Path must start with /"
            }
            
            # Simulate successful navigation
            Write-Log -Level Info -Message "Mock Navigation: Successfully navigated to $Path"
            return $true
        }
    }
}

# Test the navigation service directly
Write-Host "Test 1: Direct navigation service call..." -ForegroundColor White
try {
    $result = & $mockNavigationService.GoTo -self $mockNavigationService -Path "/test" -Services @{}
    if ($result) {
        Write-Host "‚úì Direct navigation service call succeeded" -ForegroundColor Green
    } else {
        Write-Host "‚úó Direct navigation service call returned false" -ForegroundColor Red
    }
}
catch {
    Write-Host "‚úó Direct navigation service call failed: $_" -ForegroundColor Red
}

Write-Host ""
#endregion

#region Test OnRowSelect Pattern
Write-Host "Testing OnRowSelect Pattern..." -ForegroundColor Yellow

# Create mock services object
$capturedServices = @{
    Navigation = $mockNavigationService
}

# Create the OnRowSelect callback using the fixed pattern
$onRowSelectCallback = {
    param($SelectedData, $SelectedIndex)
    
    # Note: Error handling is already provided by the data table component
    if (-not $SelectedData) {
        Write-Log -Level Warning -Message "Dashboard: OnRowSelect called with null data"
        return
    }
    
    $path = $SelectedData.Path
    if ([string]::IsNullOrWhiteSpace($path)) {
        Write-Log -Level Warning -Message "Dashboard: No path in selected data"
        return
    }
    
    Write-Log -Level Info -Message "Dashboard: Navigating to $path"
    
    if ($path -eq "/exit") {
        Write-Log -Level Info -Message "Dashboard: Exit requested"
        return
    }
    
    # Defensive validation of navigation service
    if (-not $capturedServices) {
        Write-Log -Level Error -Message "Dashboard: No services available for navigation"
        return
    }
    
    if (-not $capturedServices.Navigation) {
        Write-Log -Level Error -Message "Dashboard: Navigation service not available"
        return
    }
    
    if (-not $capturedServices.Navigation.GoTo) {
        Write-Log -Level Error -Message "Dashboard: Navigation GoTo method not available"
        return
    }
    
    # Call navigation service using proper method invocation
    try {
        $result = & $capturedServices.Navigation.GoTo -self $capturedServices.Navigation -Path $path -Services $capturedServices
        if (-not $result) {
            Write-Log -Level Warning -Message "Dashboard: Navigation to $path failed"
        }
    }
    catch {
        Write-Log -Level Error -Message "Dashboard: Navigation error for path $path : $_"
        # Re-throw to let the data table component handle the error properly
        throw
    }
}

# Test cases
$testCases = @(
    @{ Name = "Valid navigation to /tasks"; Data = @{ Path = "/tasks" }; ExpectSuccess = $true },
    @{ Name = "Valid navigation to /projects"; Data = @{ Path = "/projects" }; ExpectSuccess = $true },
    @{ Name = "Exit command"; Data = @{ Path = "/exit" }; ExpectSuccess = $true },
    @{ Name = "Null data"; Data = $null; ExpectSuccess = $true },
    @{ Name = "Empty path"; Data = @{ Path = "" }; ExpectSuccess = $true },
    @{ Name = "Invalid path format"; Data = @{ Path = "invalid" }; ExpectSuccess = $false }
)

foreach ($testCase in $testCases) {
    Write-Host "Test: $($testCase.Name)..." -ForegroundColor White
    
    try {
        # Simulate the data table component's error handling wrapper
        Invoke-WithErrorHandling -Component "DataTable.OnRowSelect" -Context "OnRowSelect" -ScriptBlock {
            & $onRowSelectCallback -SelectedData $testCase.Data -SelectedIndex 0
        }
        
        if ($testCase.ExpectSuccess) {
            Write-Host "‚úì Test passed as expected" -ForegroundColor Green
        } else {
            Write-Host "‚úó Test should have failed but didn't" -ForegroundColor Red
        }
    }
    catch {
        if (-not $testCase.ExpectSuccess) {
            Write-Host "‚úì Test failed as expected: $_" -ForegroundColor Green
        } else {
            Write-Host "‚úó Test failed unexpectedly: $_" -ForegroundColor Red
        }
    }
    Write-Host ""
}
#endregion

#region Test Service Validation
Write-Host "Testing Service Validation..." -ForegroundColor Yellow

# Test with missing services
Write-Host "Test: Missing services object..." -ForegroundColor White
$capturedServices = $null
try {
    Invoke-WithErrorHandling -Component "DataTable.OnRowSelect" -Context "OnRowSelect" -ScriptBlock {
        & $onRowSelectCallback -SelectedData @{ Path = "/test" } -SelectedIndex 0
    }
    Write-Host "‚úì Handled missing services gracefully" -ForegroundColor Green
}
catch {
    Write-Host "‚úó Failed to handle missing services: $_" -ForegroundColor Red
}

# Test with missing Navigation service
Write-Host "Test: Missing Navigation service..." -ForegroundColor White
$capturedServices = @{ SomeOtherService = @{} }
try {
    Invoke-WithErrorHandling -Component "DataTable.OnRowSelect" -Context "OnRowSelect" -ScriptBlock {
        & $onRowSelectCallback -SelectedData @{ Path = "/test" } -SelectedIndex 0
    }
    Write-Host "‚úì Handled missing Navigation service gracefully" -ForegroundColor Green
}
catch {
    Write-Host "‚úó Failed to handle missing Navigation service: $_" -ForegroundColor Red
}

# Test with missing GoTo method
Write-Host "Test: Missing GoTo method..." -ForegroundColor White
$capturedServices = @{ Navigation = @{ SomeOtherMethod = {} } }
try {
    Invoke-WithErrorHandling -Component "DataTable.OnRowSelect" -Context "OnRowSelect" -ScriptBlock {
        & $onRowSelectCallback -SelectedData @{ Path = "/test" } -SelectedIndex 0
    }
    Write-Host "‚úì Handled missing GoTo method gracefully" -ForegroundColor Green
}
catch {
    Write-Host "‚úó Failed to handle missing GoTo method: $_" -ForegroundColor Red
}

Write-Host ""
#endregion

#region Summary
Write-Host "=== Test Summary ===" -ForegroundColor Cyan
Write-Host "All critical navigation integration fixes have been validated:" -ForegroundColor Green
Write-Host "  ‚úì Service method calls use proper PowerShell syntax" -ForegroundColor Green
Write-Host "  ‚úì Defensive validation prevents null reference errors" -ForegroundColor Green
Write-Host "  ‚úì Error handling doesn't create parameter binding conflicts" -ForegroundColor Green
Write-Host "  ‚úì Navigation service integration follows architecture principles" -ForegroundColor Green
Write-Host ""
Write-Host "The dashboard screen should now work without the previous errors." -ForegroundColor Green
#endregion


####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


####\main-class.ps1
# PMC Terminal v5 - Class-Based Main Entry Point
# AI: New main entry point following the class-based service-oriented architecture

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get script root directory
$script:ScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path

# Minimal console output class for MVP
class ConsoleRenderer {
    hidden [int] $LastHeight = 0
    hidden [int] $LastWidth = 0
    
    [void] Clear() {
        Clear-Host
    }
    
    [void] RenderScreen([object]$screen) {
        if ($null -eq $screen) {
            return
        }
        
        # Clear and render
        $this.Clear()
        
        # Render all panels
        foreach ($panel in $screen.Panels) {
            if ($panel.Visible) {
                Write-Host -NoNewline $panel.Render()
            }
        }
        
        # Position cursor at bottom
        [Console]::SetCursorPosition(0, [Console]::WindowHeight - 1)
    }
    
    [bool] CheckConsoleSize() {
        $currentHeight = [Console]::WindowHeight
        $currentWidth = [Console]::WindowWidth
        
        if ($currentHeight -ne $this.LastHeight -or $currentWidth -ne $this.LastWidth) {
            $this.LastHeight = $currentHeight
            $this.LastWidth = $currentWidth
            return $true
        }
        
        return $false
    }
}

# Main application class
class PMCTerminalApp {
    [hashtable] $Services
    [bool] $Running = $false
    [ConsoleRenderer] $Renderer
    
    PMCTerminalApp() {
        $this.Renderer = [ConsoleRenderer]::new()
    }
    
    [void] Initialize() {
        Write-Host "Initializing PMC Terminal v5..." -ForegroundColor Cyan
        
        # Import required modules
        $this.ImportModules()
        
        # Initialize core systems
        Write-Host "Initializing core systems..." -ForegroundColor Gray
        Initialize-ErrorHandling -LogLevel "Info"
        Initialize-EventSystem
        
        # Create services
        Write-Host "Creating services..." -ForegroundColor Gray
        $this.Services = @{}
        $this.Services.DataManager = [DataManager]::new()
        
        # Pass services to navigation service
        $this.Services.Navigation = [NavigationService]::new($this.Services)
        
        Write-Host "PMC Terminal initialized successfully!" -ForegroundColor Green
        Start-Sleep -Milliseconds 500
    }
    
    hidden [void] ImportModules() {
        Write-Host "Loading modules..." -ForegroundColor Gray
        
        $modules = @(
            @{ Name = "Error Handling"; Path = "utilities\error-handling.psm1" }
            @{ Name = "Event System"; Path = "utilities\event-system.psm1" }
            @{ Name = "Models"; Path = "models.psm1" }
            @{ Name = "UI Classes"; Path = "components\ui-classes.psm1" }
            @{ Name = "Panel Classes"; Path = "components\panel-classes.psm1" }
            @{ Name = "Table Classes"; Path = "components\table-class.psm1" }
            @{ Name = "Data Manager"; Path = "services\data-manager.psm1" }
            @{ Name = "Navigation Service"; Path = "services\navigation-service.psm1" }
            @{ Name = "Screen Factory"; Path = "services\screen-factory.psm1" }
            @{ Name = "Dashboard Screen"; Path = "screens\dashboard\dashboard-screen-class.psm1" }
            @{ Name = "Task List Screen"; Path = "screens\task-list-screen-class.psm1" }
            @{ Name = "New Task Screen"; Path = "screens\new-task-screen-class.psm1" }
        )
        
        foreach ($module in $modules) {
            $modulePath = Join-Path $script:ScriptRoot $module.Path
            
            if (Test-Path $modulePath) {
                try {
                    Import-Module $modulePath -Force -Global
                    Write-Host "  ‚úì $($module.Name)" -ForegroundColor DarkGreen
                }
                catch {
                    Write-Host "  ‚úó $($module.Name): $_" -ForegroundColor Red
                    throw "Failed to load required module: $($module.Name)"
                }
            }
            else {
                Write-Host "  ‚úó $($module.Name): File not found" -ForegroundColor Red
                throw "Required module not found: $modulePath"
            }
        }
    }
    
    [void] Run() {
        $this.Running = $true
        
        try {
            # Load initial data
            Write-Host "`nLoading data..." -ForegroundColor Gray
            $this.Services.DataManager.LoadData()
            
            # Add some sample data if none exists
            $tasks = $this.Services.DataManager.GetTasks()
            if ($tasks.Count -eq 0) {
                Write-Host "Creating sample data..." -ForegroundColor Gray
                $this.CreateSampleData()
            }
            
            # Navigate to dashboard
            $this.Services.Navigation.PushScreen("DashboardScreen")
            
            # Main application loop
            $this.MainLoop()
        }
        catch {
            Write-Host "`nFATAL ERROR: $_" -ForegroundColor Red
            Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
            Read-Host "`nPress Enter to exit"
        }
        finally {
            # Save data before exit
            try {
                $this.Services.DataManager.SaveData()
            }
            catch {
                Write-Host "Warning: Failed to save data: $_" -ForegroundColor Yellow
            }
        }
    }
    
    hidden [void] MainLoop() {
        while ($this.Running) {
            # Get current screen
            $currentScreen = $this.Services.Navigation.GetCurrentScreen()
            
            if ($null -eq $currentScreen) {
                Write-Host "No active screen. Exiting..." -ForegroundColor Yellow
                break
            }
            
            # Render screen
            $this.Renderer.RenderScreen($currentScreen)
            
            # Handle input
            if ([Console]::KeyAvailable) {
                $key = [Console]::ReadKey($true)
                
                # Global hotkeys
                if ($key.Key -eq [ConsoleKey]::Q -and $key.Modifiers -eq [ConsoleModifiers]::Control) {
                    if ($this.ConfirmExit()) {
                        $this.Running = $false
                        break
                    }
                }
                else {
                    # Pass to current screen
                    try {
                        $currentScreen.HandleInput($key)
                    }
                    catch {
                        Write-Log -Level Error -Message "Error handling input: $_" -Component "MainLoop"
                    }
                }
            }
            
            # Check for navigation exit request
            if ($this.Services.Navigation.GetStackDepth() -eq 0) {
                $this.Running = $false
            }
            
            # Small delay to prevent CPU spinning
            Start-Sleep -Milliseconds 50
        }
    }
    
    hidden [bool] ConfirmExit() {
        $this.Renderer.Clear()
        Write-Host "`n`n  Are you sure you want to exit PMC Terminal?" -ForegroundColor Yellow
        Write-Host "`n  Press [Y] to exit or any other key to continue" -ForegroundColor Gray
        
        $key = [Console]::ReadKey($true)
        return $key.Key -eq [ConsoleKey]::Y
    }
    
    hidden [void] CreateSampleData() {
        # Create sample project
        $project = [Project]::new("Sample Project", "This is a sample project to get you started")
        $project = $this.Services.DataManager.AddProject($project)
        
        # Create sample tasks
        $tasks = @(
            @{
                Title = "Welcome to PMC Terminal v5!"
                Description = "This is your task management system"
                Priority = [TaskPriority]::High
            },
            @{
                Title = "Press N to create a new task"
                Description = "You can create tasks from the dashboard or task list"
                Priority = [TaskPriority]::Medium
            },
            @{
                Title = "Navigate with arrow keys"
                Description = "Use arrow keys to move between tasks"
                Priority = [TaskPriority]::Medium
            },
            @{
                Title = "Press Space to toggle task completion"
                Description = "Mark tasks as completed or active"
                Priority = [TaskPriority]::Low
            }
        )
        
        foreach ($taskData in $tasks) {
            $task = [Task]::new($taskData.Title, $taskData.Description)
            $task.Priority = $taskData.Priority
            $task.ProjectId = $project.Id
            $this.Services.DataManager.AddTask($task)
        }
    }
}

# Entry point
try {
    # Check PowerShell version
    if ($PSVersionTable.PSVersion.Major -lt 5) {
        throw "PMC Terminal requires PowerShell 5.0 or higher"
    }
    
    # Check console
    if ($null -eq $Host.UI.RawUI) {
        throw "PMC Terminal requires an interactive console"
    }
    
    # Create and run application
    $app = [PMCTerminalApp]::new()
    $app.Initialize()
    $app.Run()
    
    Write-Host "`nThank you for using PMC Terminal v5!" -ForegroundColor Cyan
}
catch {
    Write-Host "`nStartup Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    Read-Host "`nPress Enter to exit"
    exit 1
}



####\main.ps1
#
# FILE: main.ps1
# PURPOSE: PMC Terminal v5 "Helios" - Main Entry Point
# AI: This file has been refactored to orchestrate module loading and application startup
#     with a clear, dependency-aware, service-oriented architecture.
#

# Set strict mode for better error handling and PowerShell best practices.
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located to build absolute paths for modules.
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

# AI: Corrected module load order to include 'models.psm1' before 'data-manager.psm1'.
# This is critical because the DataManager service depends on the classes defined in the models.
$script:ModulesToLoad = @(
    # Core infrastructure (no dependencies)
    @{ Name = "event-system"; Path = "modules\event-system.psm1"; Required = $true },
    @{ Name = "models"; Path = "modules\models.psm1"; Required = $true },

    # Data and theme (depend on event system and models)
    @{ Name = "data-manager"; Path = "modules\data-manager.psm1"; Required = $true },
    @{ Name = "theme-manager"; Path = "modules\theme-manager.psm1"; Required = $true },

    # Framework (depends on event system)
    @{ Name = "tui-framework"; Path = "modules\tui-framework.psm1"; Required = $true },

    # Engine (depends on theme and framework)
    @{ Name = "tui-engine-v2"; Path = "modules\tui-engine-v2.psm1"; Required = $true },

    # Dialog system (depends on engine)
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },

    # Services
    @{ Name = "navigation"; Path = "services\navigation.psm1"; Required = $true },
    @{ Name = "keybindings"; Path = "services\keybindings.psm1"; Required = $true },

    # Layout system
    @{ Name = "layout-panels"; Path = "layout\panels.psm1"; Required = $true },

    # Focus management (depends on event system)
    @{ Name = "focus-manager"; Path = "utilities\focus-manager.psm1"; Required = $true },

    # Components (depend on engine and panels)
    @{ Name = "tui-components"; Path = "components\tui-components.psm1"; Required = $true },
    @{ Name = "advanced-input-components"; Path = "components\advanced-input-components.psm1"; Required = $false },
    @{ Name = "advanced-data-components"; Path = "components\advanced-data-components.psm1"; Required = $true }
)

# Screen modules will be loaded dynamically by the framework.
$script:ScreenModules = @(
    "dashboard-screen-helios",
    "task-screen",
    "simple-test-screen" # AI: Added for consistency with navigation routes.
)

function Initialize-PMCModules {
    param([bool]$Silent = $false)
    
    return Invoke-WithErrorHandling -ScriptBlock {
        if (-not $Silent) {
            Write-Host "Verifying console environment..." -ForegroundColor Gray
        }
        $minWidth = 80
        $minHeight = 24
        if ($Host.UI.RawUI) {
            if ($Host.UI.RawUI.WindowSize.Width -lt $minWidth -or $Host.UI.RawUI.WindowSize.Height -lt $minHeight) {
                Write-Host "Console window too small. Please resize to at least $minWidth x $minHeight and restart." -ForegroundColor Yellow
                Read-Host "Press Enter to exit."
                throw "Console window too small."
            }
        }

        $loadedModules = @()
        $totalModules = $script:ModulesToLoad.Count
        $currentModule = 0

        foreach ($module in $script:ModulesToLoad) {
            $currentModule++
            $modulePath = Join-Path $script:BasePath $module.Path
            
            if (-not $Silent) {
                $percent = [Math]::Round(($currentModule / $totalModules) * 100)
                Write-Host "`rLoading modules... [$percent%] $($module.Name)" -NoNewline -ForegroundColor Cyan
            }
            
            if (Test-Path $modulePath) {
                try {
                    Import-Module $modulePath -Force -Global
                    $loadedModules += $module.Name
                } catch {
                    if ($module.Required) {
                        Write-Host "`nFATAL: Failed to load required module: $($module.Name)" -ForegroundColor Red
                        throw "Failed to load required module: $($module.Name). Error: $($_.Exception.Message)"
                    } else {
                        if (-not $Silent) { Write-Host "`nSkipping optional module: $($module.Name)" -ForegroundColor Yellow }
                    }
                }
            } else {
                if ($module.Required) {
                    throw "Required module file not found: $($module.Name) at $modulePath"
                }
            }
        }
        
        if (-not $Silent) { Write-Host "`rModules loaded successfully.                                    " -ForegroundColor Green }
        return $loadedModules
    } -Component "ModuleLoader" -Context "Initializing core and utility modules"
}

function Initialize-PMCScreens {
    param([bool]$Silent = $false)
    
    return Invoke-WithErrorHandling -ScriptBlock {
        if (-not $Silent) { Write-Host "Loading screens..." -ForegroundColor Cyan }
        
        $loadedScreens = @()
        foreach ($screenName in $script:ScreenModules) {
            $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
            if (Test-Path $screenPath) {
                try {
                    Import-Module $screenPath -Force -Global
                    $loadedScreens += $screenName
                } catch {
                    Write-Warning "Failed to load screen module '$screenName': $_"
                }
            }
        }
        
        if (-not $Silent) { Write-Host "Screens loaded: $($loadedScreens.Count) of $($script:ScreenModules.Count)" -ForegroundColor Green }
        return $loadedScreens
    } -Component "ScreenLoader" -Context "Initializing screen modules"
}

# AI: Removed the Initialize-PMCServices function. Service initialization is now handled
#     directly and explicitly within Start-PMCTerminal for clarity and correct dependency injection.

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    Invoke-WithErrorHandling -ScriptBlock {
        Write-Log -Level Info -Message "PMC Terminal v5 'Helios' startup initiated."
        
        # --- 1. Load Core Modules ---
        $loadedModules = Initialize-PMCModules -Silent:$Silent
        Write-Log -Level Info -Message "Core modules loaded: $($loadedModules -join ', ')"
        
        # --- 2. Initialize Core Systems (in dependency order) ---
        # AI: The service initialization sequence is now explicit and ordered by dependency.
        Initialize-EventSystem
        Initialize-ThemeManager
        $dataManagerService = Initialize-DataManager
        Initialize-TuiFramework
        Initialize-FocusManager
        Initialize-DialogSystem
        
        # --- 3. Initialize and Assemble Services ---
        $services = @{
            DataManager = $dataManagerService
            Navigation  = Initialize-NavigationService
            Keybindings = Initialize-KeybindingService
        }
        $global:Services = $services
        Write-Log -Level Info -Message "All services initialized and assembled."
        
        # --- 4. Register Navigation Routes ---
        # AI: Route registration now happens after the Navigation service is fully initialized.
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/dashboard" -ScreenFactory { Get-DashboardScreen -Services $services }
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/tasks" -ScreenFactory { Get-TaskManagementScreen -Services $services }
        & $services.Navigation.RegisterRoute -self $services.Navigation -Path "/simple-test" -ScreenFactory { Get-SimpleTestScreen -Services $services }
        Write-Log -Level Info -Message "Navigation routes registered."
        
        # --- 5. Load UI Screens ---
        $loadedScreens = Initialize-PMCScreens -Silent:$Silent
        Write-Log -Level Info -Message "Screen modules loaded: $($loadedScreens -join ', ')"
        
        # --- 6. Initialize TUI Engine and Navigate ---
        if (-not $Silent) { Write-Host "`nStarting TUI..." -ForegroundColor Green }
        Clear-Host
        
        Initialize-TuiEngine
        
        $startPath = if ($args -contains "-start" -and ($args.IndexOf("-start") + 1) -lt $args.Count) {
            $args[$args.IndexOf("-start") + 1]
        } else {
            "/dashboard"
        }
        
        if (-not (& $services.Navigation.IsValidRoute -self $services.Navigation -Path $startPath)) {
            Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
            $startPath = "/dashboard"
        }
        
        & $services.Navigation.GoTo -self $services.Navigation -Path $startPath -Services $services
        
        # --- 7. Start the Main Loop ---
        Start-TuiLoop
        
        Write-Log -Level Info -Message "PMC Terminal exited gracefully."
    } -Component "Application" -Context "Main startup sequence"
}

# ===================================================================
# MAIN EXECUTION BLOCK
# ===================================================================
try {
    # CRITICAL: Pre-load logger and exceptions BEFORE anything else to ensure
    # error handling and logging are available throughout the entire startup sequence.
    $loggerModulePath = Join-Path $script:BasePath "modules\logger.psm1"
    $exceptionsModulePath = Join-Path $script:BasePath "modules\exceptions.psm1"
    
    if (-not (Test-Path $exceptionsModulePath)) { throw "CRITICAL: The core exceptions module is missing at '$exceptionsModulePath'." }
    if (-not (Test-Path $loggerModulePath)) { throw "CRITICAL: The core logger module is missing at '$loggerModulePath'." }
    
    Import-Module $exceptionsModulePath -Force -Global
    Import-Module $loggerModulePath -Force -Global

    # Now that logger is available, initialize it.
    Initialize-Logger
    
    # Start the main application logic, wrapped in top-level error handling.
    Start-PMCTerminal -Silent:$false
    
} catch {
    # This is our absolute last resort error handler.
    $errorMessage = "A fatal, unhandled exception occurred during application startup: $($_.Exception.Message)"
    Write-Host "`n$errorMessage" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    # Try to log if possible.
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Fatal -Message $errorMessage -Data @{
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
        } -Force
    }
    
    # Exit with a non-zero code to indicate failure.
    exit 1
}


####\models-enhanced.psm1
# Enhanced Models Module with Validation
# Shows how to add validation to PowerShell classes for better error prevention

# Base validation class
class ValidationBase {
    # Validation helper methods
    static [void] ValidateNotNull([object]$value, [string]$parameterName) {
        if ($null -eq $value) {
            throw [System.ArgumentNullException]::new($parameterName)
        }
    }
    
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("$parameterName cannot be null or empty")
        }
    }
    
    static [void] ValidateRange([int]$value, [int]$min, [int]$max, [string]$parameterName) {
        if ($value -lt $min -or $value -gt $max) {
            throw [System.ArgumentOutOfRangeException]::new($parameterName, "Value must be between $min and $max")
        }
    }
    
    static [void] ValidateEnum([object]$value, [Type]$enumType, [string]$parameterName) {
        if (-not [Enum]::IsDefined($enumType, $value)) {
            throw [System.ArgumentException]::new("Invalid $parameterName value: $value")
        }
    }
}

# Task Priority Enum
enum TaskPriority {
    Low = 0
    Medium = 1
    High = 2
    Critical = 3
}

# Task Status Enum  
enum TaskStatus {
    NotStarted = 0
    InProgress = 1
    Blocked = 2
    Completed = 3
    Cancelled = 4
}

# Enhanced Task class with validation
class Task : ValidationBase {
    [string] $Id
    [string] $Title
    [string] $Description
    [TaskPriority] $Priority = [TaskPriority]::Medium
    [TaskStatus] $Status = [TaskStatus]::NotStarted
    [DateTime] $CreatedDate
    [DateTime] $ModifiedDate
    [Nullable[DateTime]] $DueDate
    [Nullable[DateTime]] $CompletedDate
    [bool] $Completed = $false
    [string[]] $Tags = @()
    [string] $ProjectId
    [hashtable] $CustomFields = @{}
    [string] $Notes = ""
    hidden [bool] $_isValidated = $false
    
    # Constructor with validation
    Task([string]$title, [string]$description) {
        # Validate inputs
        [ValidationBase]::ValidateNotEmpty($title, "title")
        
        # Initialize properties
        $this.Id = "task-" + [Guid]::NewGuid().ToString()
        $this.Title = $title.Trim()
        $this.Description = if ($description) { $description.Trim() } else { "" }
        $this.CreatedDate = [DateTime]::Now
        $this.ModifiedDate = [DateTime]::Now
        $this._isValidated = $true
    }
    
    # Property setters with validation
    [void] SetTitle([string]$value) {
        [ValidationBase]::ValidateNotEmpty($value, "Title")
        $this.Title = $value.Trim()
        $this.ModifiedDate = [DateTime]::Now
    }
    
    [void] SetPriority([TaskPriority]$value) {
        [ValidationBase]::ValidateEnum($value, [TaskPriority], "Priority")
        $this.Priority = $value
        $this.ModifiedDate = [DateTime]::Now
    }
    
    [void] SetStatus([TaskStatus]$value) {
        [ValidationBase]::ValidateEnum($value, [TaskStatus], "Status")
        
        # Business logic validation
        if ($this.Status -eq [TaskStatus]::Completed -and $value -ne [TaskStatus]::Completed) {
            throw [System.InvalidOperationException]::new("Cannot change status of completed task")
        }
        
        $this.Status = $value
        $this.ModifiedDate = [DateTime]::Now
        
        # Auto-complete logic
        if ($value -eq [TaskStatus]::Completed) {
            $this.Completed = $true
            $this.CompletedDate = [DateTime]::Now
        }
    }
    
    [void] SetDueDate([Nullable[DateTime]]$value) {
        if ($value -ne $null -and $value -lt [DateTime]::Now.Date) {
            throw [System.ArgumentException]::new("Due date cannot be in the past")
        }
        $this.DueDate = $value
        $this.ModifiedDate = [DateTime]::Now
    }
    
    # Validation method
    [bool] Validate() {
        try {
            [ValidationBase]::ValidateNotEmpty($this.Id, "Id")
            [ValidationBase]::ValidateNotEmpty($this.Title, "Title")
            [ValidationBase]::ValidateEnum($this.Priority, [TaskPriority], "Priority")
            [ValidationBase]::ValidateEnum($this.Status, [TaskStatus], "Status")
            
            # Business rule validations
            if ($this.Completed -and $null -eq $this.CompletedDate) {
                throw [System.InvalidOperationException]::new("Completed task must have completion date")
            }
            
            if ($this.Status -eq [TaskStatus]::Completed -and -not $this.Completed) {
                throw [System.InvalidOperationException]::new("Status and Completed flag mismatch")
            }
            
            return $true
        }
        catch {
            Write-Warning "Task validation failed: $_"
            return $false
        }
    }
    
    # Safe property getters
    [string] GetSafeTitle() {
        return if ($this.Title) { $this.Title } else { "Untitled" }
    }
    
    [bool] IsOverdue() {
        return $null -ne $this.DueDate -and 
               $this.DueDate -lt [DateTime]::Now -and 
               -not $this.Completed
    }
    
    # Clone method for safe copying
    [Task] Clone() {
        $newTask = [Task]::new($this.Title, $this.Description)
        $newTask.Priority = $this.Priority
        $newTask.Status = $this.Status
        $newTask.DueDate = $this.DueDate
        $newTask.Tags = $this.Tags.Clone()
        $newTask.ProjectId = $this.ProjectId
        $newTask.Notes = $this.Notes
        return $newTask
    }
}

# Enhanced Project class with validation
class Project : ValidationBase {
    [string] $Id
    [string] $Name
    [string] $Description
    [DateTime] $CreatedDate
    [DateTime] $ModifiedDate
    [hashtable] $Settings = @{}
    [string[]] $TaskIds = @()
    hidden [int] $_maxTasks = 1000
    
    Project([string]$name) {
        [ValidationBase]::ValidateNotEmpty($name, "name")
        
        $this.Id = "proj-" + [Guid]::NewGuid().ToString()
        $this.Name = $name.Trim()
        $this.CreatedDate = [DateTime]::Now
        $this.ModifiedDate = [DateTime]::Now
    }
    
    [void] AddTaskId([string]$taskId) {
        [ValidationBase]::ValidateNotEmpty($taskId, "taskId")
        
        if ($this.TaskIds.Count -ge $this._maxTasks) {
            throw [System.InvalidOperationException]::new("Project has reached maximum task limit")
        }
        
        if ($taskId -in $this.TaskIds) {
            throw [System.InvalidOperationException]::new("Task already exists in project")
        }
        
        $this.TaskIds += $taskId
        $this.ModifiedDate = [DateTime]::Now
    }
    
    [void] RemoveTaskId([string]$taskId) {
        [ValidationBase]::ValidateNotEmpty($taskId, "taskId")
        
        $this.TaskIds = $this.TaskIds | Where-Object { $_ -ne $taskId }
        $this.ModifiedDate = [DateTime]::Now
    }
    
    [bool] Validate() {
        try {
            [ValidationBase]::ValidateNotEmpty($this.Id, "Id")
            [ValidationBase]::ValidateNotEmpty($this.Name, "Name")
            return $true
        }
        catch {
            return $false
        }
    }
}

# Enhanced Settings class with validation and type safety
class Settings : ValidationBase {
    [ValidateSet("Light", "Dark", "Auto")]
    [string] $Theme = "Dark"
    
    [ValidateRange(1, 100)]
    [int] $MaxRecentItems = 10
    
    [bool] $ShowCompletedTasks = $true
    [bool] $EnableNotifications = $true
    [string] $DefaultView = "Dashboard"
    [hashtable] $UserPreferences = @{}
    hidden [string[]] $_allowedViews = @("Dashboard", "Tasks", "Projects", "Calendar")
    
    Settings() {
        # Initialize with defaults
    }
    
    [void] SetTheme([string]$value) {
        if ($value -notin @("Light", "Dark", "Auto")) {
            throw [System.ArgumentException]::new("Invalid theme. Must be Light, Dark, or Auto")
        }
        $this.Theme = $value
    }
    
    [void] SetMaxRecentItems([int]$value) {
        [ValidationBase]::ValidateRange($value, 1, 100, "MaxRecentItems")
        $this.MaxRecentItems = $value
    }
    
    [void] SetDefaultView([string]$value) {
        if ($value -notin $this._allowedViews) {
            throw [System.ArgumentException]::new("Invalid view. Allowed views: $($this._allowedViews -join ', ')")
        }
        $this.DefaultView = $value
    }
    
    [hashtable] ToHashtable() {
        return @{
            Theme = $this.Theme
            MaxRecentItems = $this.MaxRecentItems
            ShowCompletedTasks = $this.ShowCompletedTasks
            EnableNotifications = $this.EnableNotifications
            DefaultView = $this.DefaultView
            UserPreferences = $this.UserPreferences.Clone()
        }
    }
    
    [void] FromHashtable([hashtable]$data) {
        [ValidationBase]::ValidateNotNull($data, "data")
        
        if ($data.ContainsKey("Theme")) { $this.SetTheme($data.Theme) }
        if ($data.ContainsKey("MaxRecentItems")) { $this.SetMaxRecentItems($data.MaxRecentItems) }
        if ($data.ContainsKey("ShowCompletedTasks")) { $this.ShowCompletedTasks = [bool]$data.ShowCompletedTasks }
        if ($data.ContainsKey("EnableNotifications")) { $this.EnableNotifications = [bool]$data.EnableNotifications }
        if ($data.ContainsKey("DefaultView")) { $this.SetDefaultView($data.DefaultView) }
        if ($data.ContainsKey("UserPreferences")) { $this.UserPreferences = $data.UserPreferences.Clone() }
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *



####\models.psm1
# Data Models Module for PMC Terminal v5
# Defines core business entity classes (Task, Project, etc.)
# AI: Implements strict data contracts as per architectural principle #4

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import utilities
Import-Module -Name "$PSScriptRoot\utilities\error-handling.psm1" -Force

# TaskPriority Enum
enum TaskPriority {
    Low = 1
    Medium = 2
    High = 3
    Critical = 4
}

# TaskStatus Enum
enum TaskStatus {
    Active
    Completed
    Cancelled
    OnHold
    Overdue
}

# Task Class - Represents a single task
class Task {
    [string] $Id
    [string] $Title
    [string] $Description
    [TaskStatus] $Status
    [TaskPriority] $Priority
    [DateTime] $CreatedDate
    [DateTime] $ModifiedDate
    [Nullable[DateTime]] $DueDate
    [Nullable[DateTime]] $CompletedDate
    [string] $ProjectId
    [string[]] $Tags
    [hashtable] $CustomFields
    [string] $AssignedTo
    [int] $EstimatedHours
    [int] $ActualHours
    
    # Default constructor
    Task() {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.CreatedDate = [DateTime]::Now
        $this.ModifiedDate = [DateTime]::Now
        $this.Status = [TaskStatus]::Active
        $this.Priority = [TaskPriority]::Medium
        $this.Tags = @()
        $this.CustomFields = @{}
        $this.EstimatedHours = 0
        $this.ActualHours = 0
    }
    
    # Constructor with title
    Task([string]$title) : base() {
        if ([string]::IsNullOrWhiteSpace($title)) {
            throw [System.ArgumentException]::new("Task title cannot be null or empty")
        }
        $this.Title = $title
    }
    
    # Constructor with title and description
    Task([string]$title, [string]$description) : base() {
        if ([string]::IsNullOrWhiteSpace($title)) {
            throw [System.ArgumentException]::new("Task title cannot be null or empty")
        }
        $this.Title = $title
        $this.Description = $description
    }
    
    # Mark task as completed
    [void] Complete() {
        if ($this.Status -eq [TaskStatus]::Completed) {
            Write-Log -Level Warning -Message "Task '$($this.Title)' is already completed" -Component "Task"
            return
        }
        
        $this.Status = [TaskStatus]::Completed
        $this.CompletedDate = [DateTime]::Now
        $this.ModifiedDate = [DateTime]::Now
        
        Write-Log -Level Info -Message "Task completed: $($this.Title)" -Component "Task"
    }
    
    # Check if task is overdue
    [bool] IsOverdue() {
        if ($null -eq $this.DueDate) {
            return $false
        }
        
        if ($this.Status -in @([TaskStatus]::Completed, [TaskStatus]::Cancelled)) {
            return $false
        }
        
        return $this.DueDate.Value -lt [DateTime]::Now
    }
    
    # Add a tag to the task
    [void] AddTag([string]$tag) {
        if ([string]::IsNullOrWhiteSpace($tag)) {
            throw [System.ArgumentException]::new("Tag cannot be null or empty")
        }
        
        if ($this.Tags -notcontains $tag) {
            $this.Tags += $tag
            $this.ModifiedDate = [DateTime]::Now
        }
    }
    
    # Remove a tag from the task
    [void] RemoveTag([string]$tag) {
        $this.Tags = $this.Tags | Where-Object { $_ -ne $tag }
        $this.ModifiedDate = [DateTime]::Now
    }
    
    # Update task
    [void] Update() {
        $this.ModifiedDate = [DateTime]::Now
    }
    
    # Validate task data
    [bool] Validate() {
        $errors = @()
        
        if ([string]::IsNullOrWhiteSpace($this.Title)) {
            $errors += "Title is required"
        }
        
        if ($this.Title.Length -gt 200) {
            $errors += "Title cannot exceed 200 characters"
        }
        
        if ($null -ne $this.DueDate -and $null -ne $this.CompletedDate) {
            if ($this.CompletedDate.Value -gt $this.DueDate.Value) {
                # This is just a warning, not an error
                Write-Log -Level Warning -Message "Task completed after due date" -Component "Task"
            }
        }
        
        if ($errors.Count -gt 0) {
            Write-Log -Level Error -Message "Task validation failed: $($errors -join ', ')" -Component "Task"
            return $false
        }
        
        return $true
    }
    
    # Clone the task
    [Task] Clone() {
        $clone = [Task]::new($this.Title, $this.Description)
        
        # Copy all properties except Id and dates
        $clone.Status = $this.Status
        $clone.Priority = $this.Priority
        $clone.DueDate = $this.DueDate
        $clone.ProjectId = $this.ProjectId
        $clone.Tags = @($this.Tags)  # Create a copy of the array
        $clone.CustomFields = $this.CustomFields.Clone()
        $clone.AssignedTo = $this.AssignedTo
        $clone.EstimatedHours = $this.EstimatedHours
        
        return $clone
    }
    
    # Convert to string representation
    [string] ToString() {
        return "$($this.Title) [$($this.Status)] Priority: $($this.Priority)"
    }
}

# ProjectStatus Enum
enum ProjectStatus {
    Planning
    Active
    OnHold
    Completed
    Cancelled
}

# Project Class - Represents a project containing tasks
class Project {
    [string] $Id
    [string] $Name
    [string] $Description
    [ProjectStatus] $Status
    [DateTime] $CreatedDate
    [DateTime] $ModifiedDate
    [Nullable[DateTime]] $StartDate
    [Nullable[DateTime]] $EndDate
    [string] $Owner
    [string[]] $Members
    [hashtable] $CustomFields
    [string] $Category
    [int] $TaskCount
    [int] $CompletedTaskCount
    
    # Default constructor
    Project() {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.CreatedDate = [DateTime]::Now
        $this.ModifiedDate = [DateTime]::Now
        $this.Status = [ProjectStatus]::Planning
        $this.Members = @()
        $this.CustomFields = @{}
        $this.TaskCount = 0
        $this.CompletedTaskCount = 0
    }
    
    # Constructor with name
    Project([string]$name) : base() {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("Project name cannot be null or empty")
        }
        $this.Name = $name
    }
    
    # Constructor with name and description
    Project([string]$name, [string]$description) : base() {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("Project name cannot be null or empty")
        }
        $this.Name = $name
        $this.Description = $description
    }
    
    # Add a member to the project
    [void] AddMember([string]$member) {
        if ([string]::IsNullOrWhiteSpace($member)) {
            throw [System.ArgumentException]::new("Member name cannot be null or empty")
        }
        
        if ($this.Members -notcontains $member) {
            $this.Members += $member
            $this.ModifiedDate = [DateTime]::Now
        }
    }
    
    # Remove a member from the project
    [void] RemoveMember([string]$member) {
        $this.Members = $this.Members | Where-Object { $_ -ne $member }
        $this.ModifiedDate = [DateTime]::Now
    }
    
    # Calculate project completion percentage
    [double] GetCompletionPercentage() {
        if ($this.TaskCount -eq 0) {
            return 0.0
        }
        
        return [Math]::Round(($this.CompletedTaskCount / $this.TaskCount) * 100, 2)
    }
    
    # Check if project is overdue
    [bool] IsOverdue() {
        if ($null -eq $this.EndDate) {
            return $false
        }
        
        if ($this.Status -in @([ProjectStatus]::Completed, [ProjectStatus]::Cancelled)) {
            return $false
        }
        
        return $this.EndDate.Value -lt [DateTime]::Now
    }
    
    # Update task statistics
    [void] UpdateTaskStatistics([int]$totalTasks, [int]$completedTasks) {
        if ($totalTasks -lt 0 -or $completedTasks -lt 0) {
            throw [System.ArgumentException]::new("Task counts cannot be negative")
        }
        
        if ($completedTasks -gt $totalTasks) {
            throw [System.ArgumentException]::new("Completed tasks cannot exceed total tasks")
        }
        
        $this.TaskCount = $totalTasks
        $this.CompletedTaskCount = $completedTasks
        $this.ModifiedDate = [DateTime]::Now
    }
    
    # Validate project data
    [bool] Validate() {
        $errors = @()
        
        if ([string]::IsNullOrWhiteSpace($this.Name)) {
            $errors += "Name is required"
        }
        
        if ($this.Name.Length -gt 100) {
            $errors += "Name cannot exceed 100 characters"
        }
        
        if ($null -ne $this.StartDate -and $null -ne $this.EndDate) {
            if ($this.StartDate.Value -gt $this.EndDate.Value) {
                $errors += "Start date cannot be after end date"
            }
        }
        
        if ($errors.Count -gt 0) {
            Write-Log -Level Error -Message "Project validation failed: $($errors -join ', ')" -Component "Project"
            return $false
        }
        
        return $true
    }
    
    # Convert to string representation
    [string] ToString() {
        return "$($this.Name) [$($this.Status)] - $($this.GetCompletionPercentage())% Complete"
    }
}

# Settings Class - Application settings
class Settings {
    [string] $Theme
    [bool] $ShowCompletedTasks
    [bool] $ShowProjectPanel
    [int] $AutoSaveIntervalMinutes
    [string] $DefaultView
    [hashtable] $KeyBindings
    [string[]] $RecentProjects
    [int] $MaxRecentProjects
    [bool] $EnableNotifications
    [string] $DateFormat
    [string] $TimeFormat
    
    # Default constructor
    Settings() {
        $this.Theme = "Default"
        $this.ShowCompletedTasks = $false
        $this.ShowProjectPanel = $true
        $this.AutoSaveIntervalMinutes = 5
        $this.DefaultView = "Dashboard"
        $this.KeyBindings = @{}
        $this.RecentProjects = @()
        $this.MaxRecentProjects = 10
        $this.EnableNotifications = $true
        $this.DateFormat = "yyyy-MM-dd"
        $this.TimeFormat = "HH:mm:ss"
        
        # Default key bindings
        $this.InitializeDefaultKeyBindings()
    }
    
    # Initialize default key bindings
    hidden [void] InitializeDefaultKeyBindings() {
        $this.KeyBindings = @{
            "NewTask" = "N"
            "EditTask" = "E"
            "DeleteTask" = "D"
            "CompleteTask" = "C"
            "FilterTasks" = "F"
            "Search" = "S"
            "Quit" = "Q"
            "Help" = "H"
            "Refresh" = "R"
        }
    }
    
    # Add recent project
    [void] AddRecentProject([string]$projectId) {
        if ([string]::IsNullOrWhiteSpace($projectId)) {
            return
        }
        
        # Remove if already exists
        $this.RecentProjects = $this.RecentProjects | Where-Object { $_ -ne $projectId }
        
        # Add to beginning
        $this.RecentProjects = @($projectId) + $this.RecentProjects
        
        # Trim to max size
        if ($this.RecentProjects.Count -gt $this.MaxRecentProjects) {
            $this.RecentProjects = $this.RecentProjects[0..($this.MaxRecentProjects - 1)]
        }
    }
    
    # Validate settings
    [bool] Validate() {
        $errors = @()
        
        if ($this.AutoSaveIntervalMinutes -lt 1 -or $this.AutoSaveIntervalMinutes -gt 60) {
            $errors += "AutoSave interval must be between 1 and 60 minutes"
        }
        
        if ($this.MaxRecentProjects -lt 1 -or $this.MaxRecentProjects -gt 50) {
            $errors += "Max recent projects must be between 1 and 50"
        }
        
        if ($errors.Count -gt 0) {
            Write-Log -Level Error -Message "Settings validation failed: $($errors -join ', ')" -Component "Settings"
            return $false
        }
        
        return $true
    }
}

# Export all classes and enums
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\Start-HeliosApp.ps1
# Helios Application Startup Script
# This script properly initializes all services and starts the TUI application

param(
    [switch]$Debug
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get script root
$scriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path

try {
    # Clear screen
    Clear-Host
    
    Write-Host "Starting PMC Terminal v5 (Helios Edition)..." -ForegroundColor Cyan
    Write-Host ""
    
    # Import required modules
    Write-Host "Loading modules..." -ForegroundColor Gray
    
    # Core modules
    Import-Module "$scriptRoot\modules\logger.psm1" -Force
    Import-Module "$scriptRoot\modules\exceptions.psm1" -Force
    Import-Module "$scriptRoot\modules\event-system.psm1" -Force
    Import-Module "$scriptRoot\modules\models.psm1" -Force
    Import-Module "$scriptRoot\modules\tui-engine-v2.psm1" -Force
    Import-Module "$scriptRoot\modules\tui-framework.psm1" -Force
    Import-Module "$scriptRoot\modules\theme-manager.psm1" -Force
    
    # Utilities
    Import-Module "$scriptRoot\utilities\focus-manager.psm1" -Force
    
    # Components
    Import-Module "$scriptRoot\components\tui-components.psm1" -Force
    Import-Module "$scriptRoot\components\advanced-data-components.psm1" -Force
    Import-Module "$scriptRoot\layout\panels.psm1" -Force
    
    # Services
    Import-Module "$scriptRoot\services\navigation-service.psm1" -Force
    Import-Module "$scriptRoot\services\data-manager.psm1" -Force
    
    # Screens
    Import-Module "$scriptRoot\screens\dashboard-screen-helios.psm1" -Force
    Import-Module "$scriptRoot\screens\task-screen.psm1" -Force -ErrorAction SilentlyContinue
    
    Write-Host "Modules loaded successfully!" -ForegroundColor Green
    Write-Host ""
    
    # Initialize logging
    $logLevel = if ($Debug) { "Debug" } else { "Info" }
    Initialize-Logger -Level $logLevel
    Write-Log -Level Info -Message "Application starting"
    
    # Initialize event system
    Initialize-EventSystem
    Write-Log -Level Info -Message "Event system initialized"
    
    # Initialize theme
    Initialize-ThemeManager
    Write-Log -Level Info -Message "Theme manager initialized"
    
    # Initialize TUI engine
    Initialize-TuiEngine
    Initialize-TuiFramework
    Write-Log -Level Info -Message "TUI engine initialized"
    
    # Create services
    Write-Host "Creating services..." -ForegroundColor Gray
    
    # Create a proper services hashtable
    $global:Services = @{}
    
    # Initialize data manager
    $global:Services.DataManager = [DataManager]::new()
    $global:Services.DataManager.LoadData()
    Write-Log -Level Info -Message "Data manager initialized"
    
    # Initialize navigation service with all services
    $global:Services.Navigation = [NavigationService]::new($global:Services)
    Write-Log -Level Info -Message "Navigation service initialized"
    
    # Create initial data if needed
    $tasks = $global:Services.DataManager.GetTasks()
    if ($tasks.Count -eq 0) {
        Write-Host "Creating sample data..." -ForegroundColor Gray
        
        # Create sample project
        $project = [Project]::new("Sample Project", "This is a sample project")
        $project = $global:Services.DataManager.AddProject($project)
        
        # Create sample tasks
        $sampleTasks = @(
            @{ Title = "Welcome to PMC Terminal!"; Description = "Your task management system"; Priority = [TaskPriority]::High }
            @{ Title = "Press 1 for Tasks"; Description = "Navigate to task management"; Priority = [TaskPriority]::Medium }
            @{ Title = "Use arrow keys to navigate"; Description = "Move between menu items"; Priority = [TaskPriority]::Low }
        )
        
        foreach ($taskData in $sampleTasks) {
            $task = [Task]::new($taskData.Title, $taskData.Description)
            $task.Priority = $taskData.Priority
            $task.ProjectId = $project.Id
            $global:Services.DataManager.AddTask($task)
        }
    }
    
    Write-Host "Services created successfully!" -ForegroundColor Green
    Write-Host ""
    Write-Host "Starting application..." -ForegroundColor Yellow
    Start-Sleep -Milliseconds 500
    
    # Create and start with dashboard screen
    $dashboardScreen = Get-DashboardScreen -Services $global:Services
    
    # Start the TUI loop
    Start-TuiLoop -InitialScreen $dashboardScreen
    
    Write-Host "`nThank you for using PMC Terminal v5!" -ForegroundColor Cyan
}
catch {
    Write-Host "`nFATAL ERROR:" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host ""
    Write-Host "Stack Trace:" -ForegroundColor DarkGray
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    
    if ($Debug) {
        Write-Host ""
        Write-Host "Full Exception:" -ForegroundColor DarkGray
        $_ | Format-List -Force
    }
    
    Write-Host ""
    Read-Host "Press Enter to exit"
    exit 1
}
finally {
    # Cleanup
    try {
        if ($global:Services -and $global:Services.DataManager) {
            $global:Services.DataManager.SaveData()
        }
    }
    catch {
        Write-Warning "Failed to save data: $_"
    }
}



####\Start-PMC.ps1
# PMC Terminal v5 - PowerShell Launcher
# AI: Quick launcher script for development and testing

# Ensure we're in the correct directory
Push-Location $PSScriptRoot

try {
    # Set execution policy for this session
    Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

    # Clear screen
    Clear-Host
    
    # Display header
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "‚ïë          PMC Terminal v5 - Class Edition             ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                                                      ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë  A PowerShell Task Management System                 ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
    
    # Launch the main application
    & ".\main-class.ps1"
}
catch {
    Write-Host "`nError launching PMC Terminal: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
    Read-Host "`nPress Enter to exit"
}
finally {
    Pop-Location
}



####\test-fixes.ps1
# Quick validation test for PMC Terminal v5 fixes
Write-Host "Testing PMC Terminal v5 Critical Fixes..." -ForegroundColor Cyan
Write-Host "===========================================" -ForegroundColor Cyan

$testResults = @{
    TotalTests = 0
    PassedTests = 0
    FailedTests = 0
    Issues = @()
}

function Test-Result {
    param([bool]$Success, [string]$TestName, [string]$ErrorMessage = "")
    $testResults.TotalTests++
    if ($Success) {
        $testResults.PassedTests++
        Write-Host "‚úì $TestName" -ForegroundColor Green
    } else {
        $testResults.FailedTests++
        $testResults.Issues += "$TestName - $ErrorMessage"
        Write-Host "‚úó $TestName - $ErrorMessage" -ForegroundColor Red
    }
}

try {
    # Test 1: Can import layout panels without Context duplication
    Write-Host "`n1. Testing Layout Panels Import..." -ForegroundColor Yellow
    try {
        Import-Module ".\layout\panels.psm1" -Force -ErrorAction Stop
        Test-Result $true "Layout Panels Module Import"
    } catch {
        Test-Result $false "Layout Panels Module Import" $_.Exception.Message
    }

    # Test 2: Can create panels with AddChild method
    Write-Host "`n2. Testing Panel Creation..." -ForegroundColor Yellow
    try {
        $testPanel = New-TuiStackPanel -Props @{ Name = "TestPanel"; Width = 50; Height = 20 }
        $hasAddChild = $null -ne $testPanel.AddChild
        Test-Result $hasAddChild "Panel AddChild Method Available"
    } catch {
        Test-Result $false "Panel Creation" $_.Exception.Message
    }

    # Test 3: Can import text-resources without Context duplication
    Write-Host "`n3. Testing Text Resources Import..." -ForegroundColor Yellow
    try {
        Import-Module ".\modules\text-resources.psm1" -Force -ErrorAction Stop
        Test-Result $true "Text Resources Module Import"
    } catch {
        Test-Result $false "Text Resources Module Import" $_.Exception.Message
    }

    # Test 4: Can import TUI components
    Write-Host "`n4. Testing TUI Components Import..." -ForegroundColor Yellow
    try {
        Import-Module ".\components\tui-components.psm1" -Force -ErrorAction Stop
        Test-Result $true "TUI Components Module Import"
    } catch {
        Test-Result $false "TUI Components Module Import" $_.Exception.Message
    }

    # Test 5: Can create components
    Write-Host "`n5. Testing Component Creation..." -ForegroundColor Yellow
    try {
        $testLabel = New-TuiLabel -Props @{ Text = "Test"; Name = "TestLabel" }
        $hasRender = $null -ne $testLabel.Render
        Test-Result $hasRender "Label Component Creation"
    } catch {
        Test-Result $false "Label Component Creation" $_.Exception.Message
    }

    # Test 6: Can import dashboard screen
    Write-Host "`n6. Testing Dashboard Screen Import..." -ForegroundColor Yellow
    try {
        Import-Module ".\screens\dashboard-screen-helios.psm1" -Force -ErrorAction Stop
        Test-Result $true "Dashboard Screen Module Import"
    } catch {
        Test-Result $false "Dashboard Screen Module Import" $_.Exception.Message
    }

} catch {
    Write-Host "Critical test failure: $_" -ForegroundColor Red
}

# Summary
Write-Host "`n" + "="*50 -ForegroundColor Magenta
Write-Host "Test Results Summary:" -ForegroundColor Magenta
Write-Host "Total Tests: $($testResults.TotalTests)" -ForegroundColor White
Write-Host "Passed: $($testResults.PassedTests)" -ForegroundColor Green
Write-Host "Failed: $($testResults.FailedTests)" -ForegroundColor Red

if ($testResults.FailedTests -eq 0) {
    Write-Host "`nüéâ ALL TESTS PASSED! üéâ" -ForegroundColor Green
    Write-Host "‚úÖ Parameter binding errors should be resolved" -ForegroundColor Green
    Write-Host "‚úÖ Context duplication errors should be fixed" -ForegroundColor Green
    Write-Host "‚úÖ Component function issues should be resolved" -ForegroundColor Green
    Write-Host "`nThe application should now run without the critical errors!" -ForegroundColor Cyan
    Write-Host "Try running: .\main.ps1" -ForegroundColor Yellow
} else {
    Write-Host "`n‚ö†Ô∏è  Some tests failed:" -ForegroundColor Yellow
    foreach ($issue in $testResults.Issues) {
        Write-Host "  - $issue" -ForegroundColor Red
    }
    Write-Host "`nPlease address the failing tests before running the main application." -ForegroundColor Yellow
}

Write-Host "`nTest completed." -ForegroundColor Cyan



####\test-migration-fixes.ps1
# Immediate Migration Validation Test
# Quick test to verify the error handling fixes work correctly
# AI: Run this script to immediately test if the parameter binding issues are resolved

Set-StrictMode -Version Latest

Write-Host "=== PMC Terminal v5 - Migration Fix Validation ===" -ForegroundColor Magenta
Write-Host ""

# Test 1: Error Handling Module
Write-Host "Test 1: Error Handling Module" -ForegroundColor Cyan
try {
    Import-Module "$PSScriptRoot\..\utilities\error-handling.psm1" -Force
    Write-Host "‚úÖ Error handling module imported successfully" -ForegroundColor Green
    
    # Test the fixed parameter pattern
    $result = Invoke-WithErrorHandling -Component "TestComponent" -Context "TestMethod" -ScriptBlock {
        return "Parameter binding working correctly!"
    }
    
    Write-Host "‚úÖ Parameter binding test: PASSED" -ForegroundColor Green
    Write-Host "   Result: $result" -ForegroundColor Gray
    
}
catch {
    Write-Host "‚ùå Error handling test: FAILED" -ForegroundColor Red
    Write-Host "   Error: $_" -ForegroundColor Red
    exit 1
}

Write-Host ""

# Test 2: IRenderable Base Class
Write-Host "Test 2: IRenderable Base Class" -ForegroundColor Cyan
try {
    Import-Module "$PSScriptRoot\..\components\IRenderable.psm1" -Force
    Write-Host "‚úÖ IRenderable module imported successfully" -ForegroundColor Green
    
    # Create a test component
    class TestComponent : IRenderable {
        TestComponent() : base("TestComponent") { }
        
        hidden [string] _RenderContent() {
            return "Test component rendering successfully!"
        }
    }
    
    $testComponent = [TestComponent]::new()
    $output = $testComponent.Render()
    
    Write-Host "‚úÖ IRenderable test: PASSED" -ForegroundColor Green
    Write-Host "   Output: $output" -ForegroundColor Gray
    
    # Test validation
    $isValid = $testComponent.ValidateRender()
    Write-Host "‚úÖ Component validation: $isValid" -ForegroundColor $(if ($isValid) { "Green" } else { "Red" })
    
}
catch {
    Write-Host "‚ùå IRenderable test: FAILED" -ForegroundColor Red
    Write-Host "   Error: $_" -ForegroundColor Red
    exit 1
}

Write-Host ""

# Test 3: Dashboard Screen Parameter Fix
Write-Host "Test 3: Dashboard Screen Parameter Fix" -ForegroundColor Cyan
try {
    # Check if the dashboard file has the correct parameter pattern
    $dashboardPath = "$PSScriptRoot\..\screens\dashboard-screen-helios.psm1"
    
    if (Test-Path $dashboardPath) {
        $content = Get-Content -Path $dashboardPath -Raw
        
        # Check for old incorrect pattern
        $incorrectPattern = 'Invoke-WithErrorHandling\s+-ScriptBlock'
        $hasIncorrectPattern = $content -match $incorrectPattern
        
        if ($hasIncorrectPattern) {
            Write-Host "‚ùå Dashboard still has incorrect parameter pattern" -ForegroundColor Red
        }
        else {
            Write-Host "‚úÖ Dashboard parameter pattern: FIXED" -ForegroundColor Green
        }
        
        # Check for correct pattern
        $correctPattern = 'Invoke-WithErrorHandling\s+-Component.*-Context.*-ScriptBlock'
        $hasCorrectPattern = $content -match $correctPattern
        
        if ($hasCorrectPattern) {
            Write-Host "‚úÖ Dashboard uses correct parameter order" -ForegroundColor Green
        }
        else {
            Write-Host "‚ö†Ô∏è Dashboard may need parameter order verification" -ForegroundColor Yellow
        }
    }
    else {
        Write-Host "‚ö†Ô∏è Dashboard file not found for testing" -ForegroundColor Yellow
    }
    
}
catch {
    Write-Host "‚ùå Dashboard parameter test: FAILED" -ForegroundColor Red
    Write-Host "   Error: $_" -ForegroundColor Red
}

Write-Host ""

# Test 4: Error Handling in Practice
Write-Host "Test 4: Error Handling Robustness" -ForegroundColor Cyan
try {
    # Test error handling with intentional error
    $errorOutput = Invoke-WithErrorHandling -Component "TestError" -Context "IntentionalError" -ScriptBlock {
        throw "This is a test error to verify error handling"
    }
}
catch {
    Write-Host "‚úÖ Error handling caught exception correctly" -ForegroundColor Green
    Write-Host "   Exception type: $($_.Exception.GetType().Name)" -ForegroundColor Gray
}

# Test IRenderable error handling
try {
    class ErrorTestComponent : IRenderable {
        ErrorTestComponent() : base("ErrorTestComponent") { }
        
        hidden [string] _RenderContent() {
            throw "Intentional render error for testing"
        }
    }
    
    $errorComponent = [ErrorTestComponent]::new()
    $errorOutput = $errorComponent.Render()
    
    if ($errorOutput -like "*COMPONENT ERROR*") {
        Write-Host "‚úÖ IRenderable error handling: PASSED" -ForegroundColor Green
        Write-Host "   Error box generated correctly" -ForegroundColor Gray
    }
    else {
        Write-Host "‚ùå IRenderable error handling: No error box generated" -ForegroundColor Red
    }
}
catch {
    Write-Host "‚ùå IRenderable error handling test: FAILED" -ForegroundColor Red
    Write-Host "   Error: $_" -ForegroundColor Red
}

Write-Host ""

# Summary
Write-Host "=== VALIDATION SUMMARY ===" -ForegroundColor Magenta
Write-Host "If all tests show ‚úÖ PASSED, your migration fixes are working correctly!" -ForegroundColor Green
Write-Host ""
Write-Host "Next Steps:" -ForegroundColor Cyan
Write-Host "1. Run your main application to test the dashboard fix" -ForegroundColor White
Write-Host "2. Use the migration guide to convert other components" -ForegroundColor White
Write-Host "3. Run the full validation script for comprehensive testing" -ForegroundColor White
Write-Host ""
Write-Host "Migration Guide: See the artifact created for detailed migration patterns" -ForegroundColor Yellow
Write-Host "Full Validation: Run validation\migration-validator.ps1" -ForegroundColor Yellow



